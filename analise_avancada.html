<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√°lise Avan√ßada - Cortex Virtual</title>
    <style>
        /* Estilos Base (Copiados do index.html para consist√™ncia) */
        :root {
            --bg-color: #0f0f13; --panel-bg: #1a1a1a; --text-color: #fff; --border-color: #333; --input-bg: #0f0f13;
            --accent: #00d2ff; --accent-blaze: #ff0055; --accent-jonbet: #00ff88; --text-muted: #888;
        }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; }
        .main-container { max-width: 1200px; margin: 0 auto; display: flex; gap: 20px; flex-direction: column; }
        .layout-panel { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9rem; }
        .control-group select, .control-group input[type="time"] {
            width: auto;
            padding: 5px 8px;
            background-color: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
        }
        .control-group input[type="checkbox"] {
            transform: scale(1.2);
            margin-right: 5px;
        }
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
        h1, h2 { margin: 0; }
        h2 { margin-bottom: 15px; color: var(--accent); }
        .cortex-text-anim { background: linear-gradient(90deg, #00d2ff, #ff0055, #ff9800, #00d2ff); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: cortex-gradient 3s linear infinite; font-weight: bold; }
        @keyframes cortex-gradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        
        .btn-back { display: inline-flex; align-items: center; gap: 5px; padding: 8px 15px; background: rgba(255,255,255,0.05); color: #aaa; text-decoration: none; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; border: 1px solid #333; transition: all 0.3s; }
        .btn-back:hover { background: rgba(0, 210, 255, 0.1); border-color: #00d2ff; color: #00d2ff; box-shadow: 0 0 10px rgba(0, 210, 255, 0.2); }

        /* Grid de Bot√µes de An√°lise */
        .analysis-buttons-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; margin-bottom: 30px; }
        .analysis-btn { background: rgba(20, 25, 30, 0.8); border: 1px solid rgba(0, 210, 255, 0.15); border-radius: 12px; padding: 20px; text-align: center; color: #fff; cursor: pointer; transition: all 0.3s; display: flex; flex-direction: column; align-items: center; gap: 10px; position: relative; overflow: hidden; }
        .analysis-btn:hover { transform: translateY(-3px); border-color: var(--accent); box-shadow: 0 0 15px rgba(0, 210, 255, 0.2); background: rgba(0, 210, 255, 0.05); }
        .analysis-icon { font-size: 2rem; }
        .analysis-label { font-weight: bold; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; }

        /* Estilos do Analisador Secund√°rio */
        .platform-switcher { display: flex; gap: 10px; }
        .platform-btn { padding: 6px 12px; border: 1px solid #444; background: #222; color: var(--text-muted); cursor: pointer; border-radius: 4px; transition: all 0.3s; font-size: 0.8rem; }
        .platform-btn.active { background: var(--accent); color: #000; font-weight: bold; border-color: var(--accent); }
        .platform-jonbet .platform-btn.active { background: var(--accent-jonbet); border-color: var(--accent-jonbet); }

        .futuristic-data-box { border: 1px solid #ff9800; padding: 15px; border-radius: 8px; margin-bottom: 20px; background-color: rgba(255, 152, 0, 0.05); }
        
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(20px); }

        .history-grid { display: flex; flex-wrap: wrap; gap: 5px; max-height: 250px; overflow-y: auto; padding: 5px; align-content: flex-start; }
        .history-grid.reverse { flex-direction: row-reverse; justify-content: flex-end; }
        
        .badge { width: 35px; height: 35px; display: flex; justify-content: center; align-items: center; border-radius: 6px; font-weight: bold; font-size: 0.9rem; background: #0f0f13; border: 1px solid #333; color: #fff; position: relative; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        .badge.vermelho { border-color: #ff0055; color: #ff0055; }
        .badge.preto { border-color: #444; color: #888; }
        .badge.branco { border-color: #fff; background: rgba(255,255,255,0.1); color: #fff; text-shadow: 0 0 5px #fff; }
        .badge .time-overlay { position: absolute; bottom: 1px; right: 1px; font-size: 0.4rem; color: rgba(255,255,255,0.5); }

        .stats-box { display: flex; justify-content: space-around; background: #222; padding: 15px; border-radius: 8px; margin-top: 15px; border: 1px solid #333; }
        .stat-item { font-size: 0.9rem; display: flex; align-items: center; gap: 5px; }

        /* --- Modal Styles --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(5px); animation: fadeIn 0.3s; }
        .modal-content { background: #15151a; border: 1px solid #333; border-radius: 16px; padding: 25px; width: 90%; max-width: 900px; max-height: 90vh; overflow-y: auto; position: relative; box-shadow: 0 0 50px rgba(0,0,0,0.7); }
        .modal-close { position: absolute; top: 15px; right: 20px; background: none; border: none; color: #888; font-size: 2rem; cursor: pointer; transition: color 0.3s; line-height: 1; }
        .modal-close:hover { color: #fff; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Heatmap Styles */
        #sec_heatmap_modal .modal-content { border-top: 3px solid #ff0055; }
        .heatmap-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 8px; margin-top: 25px; }
        .heatmap-cell { background: rgba(255,255,255,0.03); border: 1px solid #333; border-radius: 8px; padding: 10px 5px; text-align: center; transition: all 0.3s; position: relative; overflow: hidden; }
        .heatmap-cell:hover { transform: translateY(-3px); z-index: 10; box-shadow: 0 5px 15px rgba(0,0,0,0.5); border-color: #fff; }
        .hm-min { font-size: 0.7rem; color: #888; margin-bottom: 5px; font-family: monospace; }
        .hm-count { font-size: 1.2rem; font-weight: bold; color: #fff; }
        @media (max-width: 700px) { .heatmap-grid { grid-template-columns: repeat(5, 1fr); } }

        /* Cycles Styles */
        #sec_cycles_modal .modal-content { border-top-color: #00d2ff; }

        /* Patterns Styles */
        #sec_patterns_modal .modal-content { border-top-color: #a100ff; }
        .patterns-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .patterns-table th, .patterns-table td { padding: 12px 8px; text-align: left; border-bottom: 1px solid #333; vertical-align: middle; }
        .patterns-table th { color: #a100ff; font-size: 0.8rem; text-transform: uppercase; }
        .pattern-sequence-vis { display: flex; gap: 5px; }
        .pattern-dot { width: 18px; height: 18px; border-radius: 50%; }
        .pattern-dot.red { background-color: #ff0055; } .pattern-dot.black { background-color: #444; } .pattern-dot.white { background-color: #fff; box-shadow: 0 0 5px #fff; }
        .pattern-count { font-weight: bold; font-size: 1.1rem; color: #fff; text-align: center; } .pattern-pct { font-size: 0.9rem; color: #888; text-align: right; }
        .patterns-table tr.highlight-row { background: rgba(161, 0, 255, 0.15); box-shadow: inset 3px 0 0 0 #a100ff; }

        /* AI Prediction Styles */
        #sec_prediction_modal .modal-content { border-top-color: #ff45d4; }
        .prediction-display { text-align: center; margin: 20px 0; }
        .prediction-color-box { padding: 20px; border-radius: 12px; font-size: 1.8rem; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; border: 2px solid; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .prediction-color-box.red { border-color: #ff0055; color: #ff0055; text-shadow: 0 0 10px #ff0055; }
        .prediction-color-box.black { border-color: #888; color: #ccc; }
        .prediction-color-box.white { border-color: #fff; color: #fff; text-shadow: 0 0 15px #fff; background: rgba(255,255,255,0.15); animation: pulse-white 1s infinite alternate; }
        .confidence-bar-container { width: 100%; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 4px; border: 1px solid #444; margin-bottom: 15px; }
        .confidence-bar { height: 12px; border-radius: 4px; background: linear-gradient(90deg, #a100ff, #ff45d4); transition: width 0.5s ease-out; box-shadow: 0 0 10px #ff45d4; }
        .confidence-label { font-size: 0.9rem; color: #ccc; }
        .prediction-reasoning { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; font-size: 0.85rem; color: #aaa; line-height: 1.5; }
        .prediction-reasoning strong { color: #ff45d4; }
        .prediction-reasoning ul { padding-left: 20px; margin: 0; }

        /* Simulation Styles */
        #sec_simulation_modal .modal-content { border-top-color: #00ff88; }
        .sim-result-box { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 1px solid #333; margin-top: 15px; display: none; }
        .sim-stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        .sim-stat-item { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px; text-align: center; }
        .sim-stat-label { font-size: 0.8rem; color: #aaa; display: block; margin-bottom: 3px; }
        .sim-stat-value { font-size: 1.1rem; font-weight: bold; color: #fff; }
        .sim-profit-display { font-size: 1.5rem; font-weight: bold; text-align: center; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid; }
        .sim-profit-positive { background: rgba(0, 255, 136, 0.1); border-color: #00ff88; color: #00ff88; }
        .sim-profit-negative { background: rgba(255, 0, 85, 0.1); border-color: #ff0055; color: #ff0055; }
        .sim-input { width: 100%; padding: 8px; background: #222; border: 1px solid #444; color: #fff; border-radius: 4px; box-sizing: border-box; }
        .sim-label { color: #ccc; font-size: 0.9rem; margin-bottom: 5px; display: block; }

        /* Loading Spinner */
        .spinner { border: 3px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 3px solid #ff9800; width: 20px; height: 20px; animation: spin 1s linear infinite; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* AI Visual Effect (Futuristic Circle) */
        .ai-visual-container { display: flex; justify-content: center; margin-bottom: 25px; animation: glitch-anim 5s infinite; }
        .ai-circle-outer { width: 120px; height: 120px; border-radius: 50%; border: 2px solid transparent; border-top-color: #00d2ff; border-bottom-color: #ff0055; animation: spin-ai 3s linear infinite; position: relative; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 20px rgba(0, 210, 255, 0.2); }
        .ai-circle-inner { width: 80px; height: 80px; border-radius: 50%; border: 2px solid transparent; border-left-color: #a100ff; border-right-color: #ff9800; animation: spin-ai 2s linear infinite reverse; position: absolute; }
        .ai-core-dot { width: 15px; height: 15px; background-color: #fff; border-radius: 50%; box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8); animation: pulse-ai 1s ease-in-out infinite alternate; }
        @keyframes spin-ai { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse-ai { 0% { transform: scale(1); opacity: 0.8; } 100% { transform: scale(1.5); opacity: 1; } }
        @keyframes glitch-anim { 0% { transform: translate(0); opacity: 1; } 92% { transform: translate(0); opacity: 1; } 92.5% { transform: translate(-3px, 2px) skew(10deg); opacity: 0.8; } 93% { transform: translate(3px, -2px) skew(-10deg); opacity: 1; } 93.5% { transform: translate(0); opacity: 1; } 98% { transform: translate(1px, -1px) skew(5deg); } 98.5% { transform: translate(-1px, 1px) skew(-5deg); } 100% { transform: translate(0); } }
        .chart-dot { animation: pulse-chart 1s infinite; } @keyframes pulse-chart { 0% { r: 3; opacity: 0.6; } 50% { r: 5; opacity: 1; box-shadow: 0 0 5px #fff; } 100% { r: 3; opacity: 0.6; } }
        @keyframes pulse-white { 0% { box-shadow: 0 0 15px rgba(255,255,255,0.3); } 100% { box-shadow: 0 0 30px rgba(255,255,255,0.8); } }

        /* Trend Meter Styles */
        .trend-meter-container { margin-bottom: 20px; background: rgba(0,0,0,0.4); padding: 12px; border-radius: 8px; border: 1px solid #333; position: relative; overflow: hidden; }
        .trend-header { display: flex; justify-content: space-between; font-size: 0.75rem; color: #aaa; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; font-weight: bold; }
        .trend-bar-bg { width: 100%; height: 6px; background: #222; border-radius: 3px; overflow: hidden; position: relative; }
        .trend-bar-fill { height: 100%; transition: width 1s cubic-bezier(0.4, 0, 0.2, 1); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="layout-panel suite">
            <a href="index.html" class="btn-back" style="display: none;">‚¨Ö Voltar ao Menu</a>
            <div class="main-header">
                <h1 class="cortex-text-anim">AN√ÅLISE AVAN√áADA</h1>
            </div>

            <!-- SE√á√ÉO 1: NOVOS BOT√ïES DE AN√ÅLISE -->
            <div class="content-section">
                <h3 style="color: #00d2ff; margin-bottom: 15px; border-left: 3px solid #00d2ff; padding-left: 10px;">üõ†Ô∏è Ferramentas Experimentais</h3>
                <div class="analysis-buttons-grid">
                    <!-- Bot√£o 1 -->
                    <div class="analysis-btn" onclick="sec_showCycles()">
                        <div class="analysis-icon">üîÑ</div>
                        <div class="analysis-label">Ciclos de Mercado</div>
                    </div>
                    <!-- Bot√£o 2 -->
                    <div class="analysis-btn" onclick="sec_showRepeatingPatterns()">
                        <div class="analysis-icon">üîÅ</div>
                        <div class="analysis-label">Padr√µes Repetidos</div>
                    </div>
                    <!-- Bot√£o 3 -->
                    <div class="analysis-btn" onclick="sec_showHeatMap()">
                        <div class="analysis-icon">üî•</div>
                        <div class="analysis-label">Mapa de Calor</div>
                    </div>
                    <!-- Bot√£o 4 -->
                    <div class="analysis-btn" onclick="sec_showPrediction()">
                        <div class="analysis-icon">üîÆ</div>
                        <div class="analysis-label">Previs√£o IA</div>
                    </div>
                    <!-- Bot√£o 5 -->
                    <div class="analysis-btn" onclick="sec_showProfitSimulation()">
                        <div class="analysis-icon">üí∞</div>
                        <div class="analysis-label">Simula√ß√£o Lucro</div>
                    </div>
                </div>
            </div>

            <!-- SE√á√ÉO 2: ANALISADOR DE SINAIS EM TEMPO REAL -->
            <div class="content-section" style="border-top: 1px solid #333; padding-top: 20px; margin-top: 20px;">
                <div class="main-header">
                    <h2 style="color: #ff9800; margin: 0;">üì° Analisador de Sinais</h2>
                    <div class="platform-switcher">
                        <input type="hidden" id="sec_platformSelector" value="blaze">
                        <button class="platform-btn active" id="sec_btn-blaze" onclick="sec_selectPlatform('blaze')">Blaze</button>
                        <button class="platform-btn" id="sec_btn-jonbet" onclick="sec_selectPlatform('jonbet')">Jonbet</button>
                    </div>
                </div>

                <div class="futuristic-data-box">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 15px;">
                        <h3 style="color: #ff9800; margin:0; font-size: 1rem;">ü§ñ Monitoramento em Tempo Real</h3>
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <label style="font-size: 0.8rem; color: #aaa; margin: 0;">Inverter:</label>
                                <label class="switch" style="transform: scale(0.8);">
                                    <input type="checkbox" id="sec_reverseToggle" checked onchange="sec_toggleDirection()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <button onclick="sec_fetchData()" style="padding: 8px 15px; background-color: #ff9800; color: #000; font-weight: bold; border: none; border-radius: 4px; cursor: pointer;">
                                üîÑ ATUALIZAR
                            </button>
                            <div id="sec_loading_indicator" class="spinner"></div>
                        </div>
                    </div>

                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                        <label class="switch">
                            <input type="checkbox" id="sec_autoFetchToggle" checked>
                            <span class="slider"></span>
                        </label>
                        <span style="font-size: 0.9rem; color: #fff; font-weight: bold;">Auto-Busca (10s)</span>
                    </div>

                    <div class="history-container" style="border-top: 1px solid #444; padding-top: 15px;">
                        <h4 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #ff9800;">Hist√≥rico <span id="sec_history_count" style="color: #aaa; font-size: 0.8rem;">(0)</span></h4>
                        <div class="history-grid reverse" id="sec_grid_real_time"></div>
                    </div>
                </div>

                <div class="stats-box">
                    <div class="stat-item"><span id="sec_platform-emoji">üî¥</span> <span id="sec_count-red" style="color: #ff0055; font-weight: bold;">0 (0%)</span></div>
                    <div class="stat-item">‚ö´ <span id="sec_count-black" style="color: #aaa; font-weight: bold;">0 (0%)</span></div>
                    <div class="stat-item">‚ö™ <span id="sec_count-white" style="color: #fff; font-weight: bold;">0</span></div>
                    <div class="stat-item" style="border-left: 1px solid #444; padding-left: 15px;">Total: <span id="sec_count-total" style="color: #00d2ff;">0</span></div>
                </div>
            </div>

        </div>
    </div>

    <!-- MODAIS -->
    <div id="sec_heatmap_modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" onclick="document.getElementById('sec_heatmap_modal').style.display='none'">&times;</button>
            <h2 style="color: #ff0055; margin: 0 0 5px 0;">üî• Mapa de Calor (Brancos)</h2>
            <p style="color: #ccc; font-size: 0.9rem; margin: 0;">Frequ√™ncia de brancos por minuto (0-59). Total analisado: <span id="sec_heatmap_total" style="color: #fff; font-weight: bold;">0</span></p>
            <div id="sec_heatmap_content" class="heatmap-grid"></div>
        </div>
    </div>

    <div id="sec_cycles_modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" onclick="document.getElementById('sec_cycles_modal').style.display='none'">&times;</button>
            <h2 style="color: #00d2ff; margin: 0 0 15px 0;">üîÑ Ciclos de Mercado (Brancos)</h2>
            <div id="sec_cycles_content" style="color: #fff;"></div>
        </div>
    </div>

    <div id="sec_patterns_modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" onclick="document.getElementById('sec_patterns_modal').style.display='none'">&times;</button>
            <h2 style="color: #a100ff; margin: 0 0 15px 0;">üîÅ Padr√µes Repetidos</h2>
            <div class="control-group" style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                <div>
                    <label for="sec_pattern_length">Tamanho:</label>
                    <select id="sec_pattern_length" onchange="sec_showRepeatingPatterns()">
                        <option value="3">3 Cores</option>
                        <option value="4" selected>4 Cores</option>
                        <option value="5">5 Cores</option>
                        <option value="6">6 Cores</option>
                    </select>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="sec_include_whites" onchange="sec_showRepeatingPatterns()">
                    <label for="sec_include_whites" style="margin:0; cursor:pointer; font-size: 0.9rem; color: #ccc;">Incluir Brancos</label>
                </div>
                <div style="display: flex; align-items: center; gap: 5px; border-left: 1px solid #444; padding-left: 15px;">
                    <label for="sec_pattern_time_start" style="margin:0; font-size: 0.9rem; color: #ccc;">De:</label>
                    <input type="time" id="sec_pattern_time_start" onchange="sec_showRepeatingPatterns()">
                    <label for="sec_pattern_time_end" style="margin:0; font-size: 0.9rem; color: #ccc;">At√©:</label>
                    <input type="time" id="sec_pattern_time_end" onchange="sec_showRepeatingPatterns()">
                </div>
            </div>
            <div id="sec_patterns_content"></div>
        </div>
    </div>

    <div id="sec_prediction_modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" onclick="document.getElementById('sec_prediction_modal').style.display='none'">&times;</button>
            <h2 style="color: #ff45d4; margin: 0 0 15px 0;">üîÆ Previs√£o IA (Cortex)</h2>
            <div id="sec_prediction_content">
            </div>
        </div>
    </div>

    <!-- Modal Simula√ß√£o de Lucro -->
    <div id="sec_simulation_modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" onclick="document.getElementById('sec_simulation_modal').style.display='none'">&times;</button>
            <h2 style="color: #00ff88; margin: 0 0 15px 0;">üí∞ Simula√ß√£o de Lucro (Backtest)</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label class="sim-label">Valor da Aposta (R$):</label>
                    <input type="number" id="sec_sim_bet" class="sim-input" value="10" min="1">
                </div>
                <div>
                    <label class="sim-label">Estrat√©gia:</label>
                    <select id="sec_sim_strategy" class="sim-input">
                        <option value="red">Sempre Vermelho</option>
                        <option value="black">Sempre Preto</option>
                        <option value="alternating">Alternar (Xadrez)</option>
                        <option value="follow">Seguir a Cor (Surf)</option>
                    </select>
                </div>
                <div>
                    <label class="sim-label">Gales (Multiplicador 2x):</label>
                    <select id="sec_sim_gale" class="sim-input">
                        <option value="0">Sem Gale</option>
                        <option value="1">Gale 1</option>
                        <option value="2">Gale 2</option>
                    </select>
                </div>
                <div style="display: flex; align-items: flex-end;">
                    <div style="display: flex; align-items: center; gap: 8px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px; width: 100%; border: 1px solid #444;">
                        <input type="checkbox" id="sec_sim_cover_white" style="width: auto;">
                        <label for="sec_sim_cover_white" style="margin:0; cursor: pointer; font-size: 0.85rem;">Cobrir Branco (20%)</label>
                    </div>
                </div>
            </div>
            <button onclick="sec_runSimulation()" style="width: 100%; padding: 12px; background: #00ff88; color: #000; font-weight: bold; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 15px;">‚ñ∂ EXECUTAR SIMULA√á√ÉO</button>
            <div id="sec_sim_results" class="sim-result-box"></div>
        </div>
    </div>

    <script>
        // --- Vari√°veis Globais das Ferramentas ---
        let sec_interval = null;
        let sec_last_processed_signature = '';

        function sec_selectPlatform(platform) {
            document.getElementById('sec_platformSelector').value = platform;
            document.getElementById('sec_btn-blaze').classList.remove('active');
            document.getElementById('sec_btn-jonbet').classList.remove('active');
            document.getElementById(`sec_btn-${platform}`).classList.add('active');
            
            const emoji = platform === 'jonbet' ? 'üü¢' : 'üî¥';
            document.getElementById('sec_platform-emoji').innerText = emoji;
            document.getElementById('sec_count-red').style.color = platform === 'jonbet' ? '#00ff88' : '#ff0055';
            
            sec_fetchData();
        }

        function sec_toggleDirection() {
            const grid = document.getElementById('sec_grid_real_time');
            const checkbox = document.getElementById('sec_reverseToggle');
            if (checkbox && grid) {
                if (checkbox.checked) grid.classList.add('reverse');
                else grid.classList.remove('reverse');
                localStorage.setItem('sec_reverse_state', checkbox.checked);
            }
        }

        async function sec_fetchData() {
            const loader = document.getElementById('sec_loading_indicator');
            if (loader) loader.style.display = 'block';

            const rawData = sessionStorage.getItem('raw_blaze_data');

            if (rawData) {
                sec_processData(rawData);
            } else {
                console.warn("An√°lise Avan√ßada: Nenhum dado encontrado no sessionStorage. Aguardando painel principal.");
            }
            
            if (loader) loader.style.display = 'none';
        }

        function sec_processData(rawData) {
            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            const results = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    results.push({ date: tokens[i], roll: parseInt(tokens[i + 1]), time: tokens[i + 2] });
                    i += 2;
                }
            }

            const grid = document.getElementById('sec_grid_real_time');
            if (grid) {
                grid.innerHTML = '';
                let r = 0, b = 0, w = 0;
                const platform = document.getElementById('sec_platformSelector').value;

                results.forEach(game => {
                    const cor = sec_identificarCor(game.roll);
                    if (cor === 'vermelho') r++; else if (cor === 'preto') b++; else if (cor === 'branco') w++;
                    const div = document.createElement('div');
                    div.className = `badge ${cor}`;
                    if (platform === 'jonbet' && cor === 'vermelho') { div.style.borderColor = '#00ff88'; div.style.color = '#00ff88'; }
                    div.innerText = game.roll;
                    const timeDiv = document.createElement('div');
                    timeDiv.className = 'time-overlay';
                    timeDiv.innerText = game.time;
                    div.appendChild(timeDiv);
                    grid.appendChild(div);
                });

                document.getElementById('sec_history_count').innerText = `(${results.length})`;
                const total = r + b + w;
                document.getElementById('sec_count-red').innerText = `${r} (${total > 0 ? ((r/total)*100).toFixed(1) : 0}%)`;
                document.getElementById('sec_count-black').innerText = `${b} (${total > 0 ? ((b/total)*100).toFixed(1) : 0}%)`;
                document.getElementById('sec_count-white').innerText = w;
                document.getElementById('sec_count-total').innerText = total;
            }
            
            if (results.length > 0) {
                const latest = results[0];
                const signature = latest.date + latest.time + latest.roll;
                if (signature !== sec_last_processed_signature) {
                    sec_last_processed_signature = signature;

                    // Atualiza a Previs√£o IA se o modal estiver aberto
                    if (document.getElementById('sec_prediction_modal').style.display === 'flex') {
                        sec_showPrediction();
                    }
                }
            }
        }

        function sec_identificarCor(numero) {
            numero = parseInt(numero);
            if (numero === 0) return 'branco';
            if (numero >= 1 && numero <= 7) return 'vermelho';
            if (numero >= 8 && numero <= 14) return 'preto';
            return 'desconhecido';
        }

        // --- L√≥gica do Mapa de Calor ---
        function sec_showHeatMap() {
            const rawData = sessionStorage.getItem('raw_blaze_data');
            if (!rawData) { alert("‚ö†Ô∏è Sem dados para gerar o mapa."); return; }
            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            const minuteCounts = Array(60).fill(0);
            let totalWhites = 0;
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    const roll = parseInt(tokens[i + 1]);
                    const time = tokens[i + 2];
                    if (roll === 0) {
                        const minute = parseInt(time.split(':')[1]);
                        if (!isNaN(minute) && minute >= 0 && minute < 60) {
                            minuteCounts[minute]++;
                            totalWhites++;
                        }
                    }
                    i += 2;
                }
            }
            if (totalWhites === 0) { alert("‚ö†Ô∏è Nenhum branco encontrado nos dados."); return; }
            const container = document.getElementById('sec_heatmap_content');
            container.innerHTML = '';
            const maxCount = Math.max(...minuteCounts);
            minuteCounts.forEach((count, minute) => {
                const intensity = maxCount > 0 ? count / maxCount : 0;
                const cell = document.createElement('div');
                cell.className = 'heatmap-cell';
                if (count > 0) {
                    const alpha = 0.1 + (intensity * 0.7);
                    cell.style.backgroundColor = `rgba(255, 0, 85, ${alpha})`;
                    cell.style.borderColor = `rgba(255, 0, 85, ${alpha + 0.3})`;
                    if (intensity === 1) cell.style.boxShadow = '0 0 15px rgba(255, 0, 85, 0.6)';
                }
                cell.innerHTML = `<div class="hm-min" style="${count > 0 ? 'color: rgba(255,255,255,0.9);' : ''}">${minute.toString().padStart(2, '0')}</div><div class="hm-count">${count}</div>`;
                container.appendChild(cell);
            });
            document.getElementById('sec_heatmap_total').innerText = totalWhites;
            document.getElementById('sec_heatmap_modal').style.display = 'flex';
        }

        // --- L√≥gica de Ciclos de Mercado ---
        function sec_showCycles() {
            const rawData = sessionStorage.getItem('raw_blaze_data');
            if (!rawData) { alert("‚ö†Ô∏è Sem dados para analisar."); return; }
            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            
            // Pega o hor√°rio do jogo mais recente para refer√™ncia
            let latestGameTime = null;
            if (tokens.length >= 3 && tokens[0].includes('/') && tokens[2].includes(':')) {
                 const [d, m, y] = tokens[0].split('/').map(Number);
                 const timeParts = tokens[2].split(':').map(Number);
                 latestGameTime = new Date(y, m - 1, d, timeParts[0], timeParts[1], timeParts[2] || 0);
            }

            const whiteTimes = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    if (parseInt(tokens[i + 1]) === 0) {
                        const [day, month, year] = tokens[i].split('/').map(Number);
                        const timeParts = tokens[i + 2].split(':').map(Number);
                        whiteTimes.push(new Date(year, month - 1, day, timeParts[0], timeParts[1], timeParts[2] || 0));
                    }
                    i += 2;
                }
            }
            if (whiteTimes.length < 2) { alert("‚ö†Ô∏è M√≠nimo 2 brancos para calcular ciclos."); return; }
            whiteTimes.sort((a, b) => a - b);
            const intervals = [];
            for (let i = 1; i < whiteTimes.length; i++) {
                const diffMins = Math.floor((whiteTimes[i] - whiteTimes[i - 1]) / 60000);
                if (diffMins > 0) intervals.push(diffMins);
            }
            if (intervals.length === 0) { alert("‚ö†Ô∏è N√£o foi poss√≠vel calcular intervalos."); return; }
            const avg = Math.round(intervals.reduce((a, b) => a + b, 0) / intervals.length);
            const min = Math.min(...intervals);
            const max = Math.max(...intervals);
            
            // An√°lise de Frequ√™ncia por Hora
            const hourlyCounts = Array(24).fill(0);
            whiteTimes.forEach(date => {
                const hour = date.getHours();
                hourlyCounts[hour]++;
            });

            const maxHourlyCount = Math.max(...hourlyCounts, 1);
            const chartW_hourly = 500;
            const chartH_hourly = 100;
            const barWidth_hourly = chartW_hourly / 24;

            let bars_hourly = '';
            hourlyCounts.forEach((count, hour) => {
                const barHeight = (count / maxHourlyCount) * (chartH_hourly - 20);
                const x = hour * barWidth_hourly;
                const y = chartH_hourly - barHeight;
                const isHot = count > 0 && count >= maxHourlyCount * 0.8;
                const barColor = isHot ? '#ff9800' : '#00d2ff';
                bars_hourly += `<g transform="translate(${x}, 0)">
                                <rect x="2" y="${y}" width="${barWidth_hourly - 4}" height="${barHeight}" fill="${barColor}" opacity="0.7" rx="2"><title>Hora ${hour}: ${count} branco(s)</title></rect>
                                <text x="${barWidth_hourly / 2}" y="${chartH_hourly - 5}" font-size="10" fill="#888" text-anchor="middle">${hour}</text>
                             </g>`;
            });

            const hourlyChartHtml = `
                <div style="margin-top: 20px; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 15px; border: 1px solid #333;">
                    <h4 style="margin: 0 0 10px 0; color: #ccc; font-size: 0.8rem; text-transform: uppercase;">Frequ√™ncia de Brancos por Hora do Dia</h4>
                    <svg viewBox="0 0 ${chartW_hourly} ${chartH_hourly}" style="width: 100%; height: 100px;">
                        ${bars_hourly}
                    </svg>
                </div>
            `;

            // C√°lculo do Countdown Estimado
            let countdownHtml = '';
            let minutesSinceLast = 0;
            if (latestGameTime && whiteTimes.length > 0) {
                const lastWhiteTime = whiteTimes[whiteTimes.length - 1];
                minutesSinceLast = Math.floor((latestGameTime - lastWhiteTime) / 60000);
                const remaining = avg - minutesSinceLast;
                
                let statusColor = '#00ff88';
                let statusText = `Em aprox. ${remaining} min`;
                let progressPercent = Math.min(100, (minutesSinceLast / avg) * 100);
                
                if (remaining <= 0) {
                    statusColor = '#ff0055';
                    statusText = `ATRASADO H√Å ${Math.abs(remaining)} MIN`;
                    progressPercent = 100;
                } else if (remaining < 5) {
                    statusColor = '#ff9800';
                }

                countdownHtml = `
                    <div style="margin-bottom: 20px; background: rgba(0,0,0,0.3); border: 1px solid #333; border-radius: 8px; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px; align-items: center;">
                            <span style="color: #aaa; font-size: 0.9rem;">Pr√≥ximo Branco Estimado:</span>
                            <span style="color: ${statusColor}; font-weight: bold; font-size: 1.1rem; animation: pulse-text 1s infinite alternate;">${statusText}</span>
                        </div>
                        <div style="width: 100%; height: 8px; background: #222; border-radius: 4px; overflow: hidden;">
                            <div style="width: ${progressPercent}%; height: 100%; background: ${statusColor}; transition: width 0.5s; box-shadow: 0 0 10px ${statusColor};"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.75rem; color: #666;">
                            <span>√öltimo: ${minutesSinceLast}m atr√°s</span>
                            <span>M√©dia: ${avg}m</span>
                        </div>
                    </div>
                    <style>@keyframes pulse-text { 0% { opacity: 0.8; } 100% { opacity: 1; text-shadow: 0 0 10px; } }</style>
                `;
            }

            // Gr√°fico Futurista de Distribui√ß√£o de Probabilidade
            const maxIntervalAxis = Math.max(max, minutesSinceLast) + 15; // Eixo X estendido
            const distMap = new Array(maxIntervalAxis).fill(0);
            intervals.forEach(i => {
                if(i < distMap.length) distMap[i]++;
            });
            
            // Suaviza√ß√£o da curva (M√©dia M√≥vel)
            const smoothed = distMap.map((v, i, arr) => {
                const prev = arr[i-1] || 0;
                const next = arr[i+1] || 0;
                return (prev + v + next) / 3;
            });

            // C√°lculo de Probabilidade (√Årea sob a curva para os pr√≥ximos 5 min)
            let probNext5 = 0;
            let sumRemaining = 0;
            let sumNext5 = 0;
            for (let i = minutesSinceLast; i < smoothed.length; i++) {
                sumRemaining += smoothed[i];
                if (i < minutesSinceLast + 5) sumNext5 += smoothed[i];
            }
            if (sumRemaining > 0) probNext5 = (sumNext5 / sumRemaining) * 100;
            
            const distMaxVal = Math.max(...smoothed, 1);
            const distW = 500;
            const distH = 100;
            const distXScale = distW / (distMap.length - 1 || 1);
            
            let distPath = `M 0 ${distH}`;
            smoothed.forEach((val, i) => {
                const x = i * distXScale;
                const y = distH - ((val / distMaxVal) * (distH - 10)); 
                distPath += ` L ${x} ${y}`;
            });
            distPath += ` L ${distW} ${distH} Z`;
            
            const markerX = Math.min(minutesSinceLast * distXScale, distW);
            const avgX = Math.min(avg * distXScale, distW);
            
            const probChartHtml = `
                <div style="margin-bottom: 20px; background: rgba(0,0,0,0.3); border: 1px solid #333; border-radius: 8px; padding: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px; align-items: flex-end;">
                        <div>
                            <h4 style="margin: 0; color: #ccc; font-size: 0.8rem; text-transform: uppercase;">Distribui√ß√£o de Probabilidade</h4>
                            <span style="font-size: 0.7rem; color: #ff9800; font-weight: bold;">VOC√ä EST√Å AQUI: ${minutesSinceLast}m</span>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 0.65rem; color: #aaa; text-transform: uppercase;">Chance (Pr√≥x. 5 min)</div>
                            <div style="font-size: 1.1rem; font-weight: bold; color: ${probNext5 > 40 ? '#00ff88' : '#fff'}; text-shadow: 0 0 10px ${probNext5 > 40 ? 'rgba(0,255,136,0.3)' : 'rgba(255,255,255,0.1)'};">${probNext5.toFixed(1)}%</div>
                        </div>
                    </div>
                    <svg viewBox="0 0 ${distW} ${distH}" style="width: 100%; height: 100px; overflow: visible;"><defs><linearGradient id="gradDist" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#00d2ff;stop-opacity:0.4" /><stop offset="100%" style="stop-color:#00d2ff;stop-opacity:0" /></linearGradient><filter id="glowDist"><feGaussianBlur stdDeviation="2.5" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><path d="${distPath}" fill="url(#gradDist)" stroke="#00d2ff" stroke-width="2" filter="url(#glowDist)" /><line x1="${avgX}" y1="0" x2="${avgX}" y2="${distH}" stroke="#a100ff" stroke-width="2" stroke-dasharray="3,3" opacity="0.8" /><text x="${avgX}" y="-5" fill="#a100ff" font-size="10" text-anchor="middle" font-weight="bold">M√âDIA</text><line x1="${markerX}" y1="0" x2="${markerX}" y2="${distH}" stroke="#ff9800" stroke-width="2" stroke-dasharray="5,5" /><circle cx="${markerX}" cy="${distH}" r="4" fill="#ff9800" class="chart-dot" /></svg>
                    <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: #666; margin-top: 5px;"><span>0m</span><span>${Math.round(maxIntervalAxis/2)}m</span><span>${maxIntervalAxis}m</span></div>
                </div>
            `;

            const chartData = intervals.slice(-30);
            const viewBoxW = 500, viewBoxH = 100, padding = 10;
            const maxValChart = Math.max(...chartData, 1);
            let svgLines = "", circles = "", prevX = 0, prevY = 0;
            chartData.forEach((val, idx) => {
                const x = (idx / (chartData.length - 1 || 1)) * (viewBoxW - 2 * padding) + padding;
                const y = (viewBoxH - padding) - ((val / maxValChart) * (viewBoxH - 2 * padding));
                const color = val > avg ? '#ff0055' : '#00d2ff';
                if (idx > 0) svgLines += `<line x1="${prevX}" y1="${prevY}" x2="${x}" y2="${y}" stroke="${color}" stroke-width="2" />`;
                circles += `<circle cx="${x}" cy="${y}" r="3" fill="${color}"><title>${val} min</title></circle>`;
                prevX = x; prevY = y;
            });
            const content = document.getElementById('sec_cycles_content');
            content.innerHTML = `${countdownHtml}${probChartHtml}${hourlyChartHtml}<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 20px;"><div style="background: rgba(0, 210, 255, 0.1); padding: 15px; border-radius: 8px; text-align: center; border: 1px solid #00d2ff;"><div style="font-size: 0.8rem; color: #aaa;">M√âDIA</div><div style="font-size: 1.5rem; font-weight: bold; color: #fff;">${avg}m</div></div><div style="background: rgba(0, 255, 136, 0.1); padding: 15px; border-radius: 8px; text-align: center; border: 1px solid #00ff88;"><div style="font-size: 0.8rem; color: #aaa;">M√çNIMO</div><div style="font-size: 1.5rem; font-weight: bold; color: #fff;">${min}m</div></div><div style="background: rgba(255, 0, 85, 0.1); padding: 15px; border-radius: 8px; text-align: center; border: 1px solid #ff0055;"><div style="font-size: 0.8rem; color: #aaa;">M√ÅXIMO</div><div style="font-size: 1.5rem; font-weight: bold; color: #fff;">${max}m</div></div></div><div style="margin-bottom: 20px; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 10px; border: 1px solid #333;"><h4 style="margin: 0 0 10px 0; color: #ccc; font-size: 0.8rem;">Varia√ß√£o (√öltimos 30)</h4><svg viewBox="0 0 500 100" style="width: 100%; height: 100px; overflow: visible;">${svgLines}${circles}</svg></div><div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;"><h4 style="margin-top: 0; color: #ccc;">√öltimos 10 Intervalos:</h4><div style="font-family: monospace; color: #00d2ff; word-break: break-all;">${intervals.slice(-10).join('m ‚ûî ')}m</div></div>`;
            document.getElementById('sec_cycles_modal').style.display = 'flex';
        }

        // --- L√≥gica de Padr√µes Repetidos ---
        function sec_showRepeatingPatterns() {
            const rawData = sessionStorage.getItem('raw_blaze_data');
            if (!rawData) { alert("‚ö†Ô∏è Sem dados para analisar."); return; }
            const includeWhites = document.getElementById('sec_include_whites').checked;
            const startTime = document.getElementById('sec_pattern_time_start').value;
            const endTime = document.getElementById('sec_pattern_time_end').value;
            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            const resultsWithTime = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    const roll = parseInt(tokens[i + 1]);
                    const time = tokens[i + 2];
                    const color = sec_identificarCor(roll);
                    if (color === 'vermelho' || color === 'preto' || (includeWhites && color === 'branco')) {
                        resultsWithTime.push({ color: color, time: time });
                    }
                    i += 2;
                }
            }
            resultsWithTime.reverse();
            const length = parseInt(document.getElementById('sec_pattern_length').value) || 4;
            const patterns = {};
            let totalSequences = 0;
            for (let i = 0; i <= resultsWithTime.length - length; i++) {
                const sequenceSlice = resultsWithTime.slice(i, i + length);
                const sequenceStartTime = sequenceSlice[0].time;
                if (startTime && endTime && (sequenceStartTime < startTime || sequenceStartTime > endTime)) continue;
                totalSequences++;
                const sequenceColors = sequenceSlice.map(item => item.color);
                const key = sequenceColors.join(',');
                patterns[key] = (patterns[key] || 0) + 1;
            }
            const sortedPatterns = Object.entries(patterns).sort(([, a], [, b]) => b - a).slice(0, 15);
            const container = document.getElementById('sec_patterns_content');
            if (sortedPatterns.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#888;">Nenhum padr√£o repetido encontrado com os filtros atuais.</p>';
                document.getElementById('sec_patterns_modal').style.display = 'flex';
                return;
            }
            let tableHTML = '<table class="patterns-table"><thead><tr><th>Padr√£o</th><th>Contagem</th><th>Frequ√™ncia</th></tr></thead><tbody>';
            sortedPatterns.forEach(([key, count], index) => {
                const sequence = key.split(',');
                const sequenceVis = sequence.map(color => {
                    let dotClass = 'black';
                    if (color === 'vermelho') dotClass = 'red';
                    else if (color === 'branco') dotClass = 'white';
                    return `<div class="pattern-dot ${dotClass}"></div>`;
                }).join('');
                const percentage = totalSequences > 0 ? ((count / totalSequences) * 100).toFixed(2) : 0;
                const rowClass = index === 0 ? 'highlight-row' : '';
                tableHTML += `<tr class="${rowClass}"><td><div class="pattern-sequence-vis">${sequenceVis}</div></td><td class="pattern-count">${count}x</td><td class="pattern-pct">${percentage}%</td></tr>`;
            });
            tableHTML += '</tbody></table>';
            container.innerHTML = tableHTML;
            document.getElementById('sec_patterns_modal').style.display = 'flex';
        }

        // --- L√≥gica de Previs√£o IA ---
        function sec_showPrediction() {
            const rawData = sessionStorage.getItem('raw_blaze_data');
            if (!rawData) { alert("‚ö†Ô∏è Sem dados para analisar."); return; }
            
            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            const history = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    history.push({ roll: parseInt(tokens[i + 1]), color: sec_identificarCor(parseInt(tokens[i + 1])), time: tokens[i+2] });
                    i += 2;
                }
            }
            
            if (history.length < 5) { alert("‚ö†Ô∏è Dados insuficientes para previs√£o."); return; }

            const last = history[0];
            
            // L√≥gica Simples de Previs√£o
            let predictionColor = 'vermelho';
            let confidence = 50;
            let reasoning = [];

            // Analisar Sequ√™ncia Atual
            let streak = 1;
            for(let i=1; i<history.length; i++) {
                if(history[i].color === last.color) streak++;
                else break;
            }

            if (last.color === 'branco') {
                predictionColor = 'vermelho'; // Padr√£o comum p√≥s-branco
                confidence = 60;
                reasoning.push("P√≥s-branco: Retorno √† cor de maior frequ√™ncia.");
            } else if (streak >= 4) {
                predictionColor = last.color === 'vermelho' ? 'preto' : 'vermelho';
                confidence = 70 + (streak * 2);
                reasoning.push(`Quebra de sequ√™ncia longa (${streak}x ${last.color}).`);
            } else {
                predictionColor = last.color === 'vermelho' ? 'preto' : 'vermelho';
                confidence = 55;
                reasoning.push("Altern√¢ncia de padr√£o de curto prazo.");
            }
            
            if (confidence > 95) confidence = 95;

            const colorMap = { 'vermelho': 'red', 'preto': 'black', 'branco': 'white' };
            const predClass = colorMap[predictionColor];
            const predLabel = predictionColor === 'vermelho' ? 'üî¥ VERMELHO' : (predictionColor === 'preto' ? '‚ö´ PRETO' : '‚ö™ BRANCO');

            const html = `
                <div class="prediction-display">
                    <div style="font-size: 0.9rem; color: #aaa; margin-bottom: 10px;">√öltimo: <span style="color:#fff; font-weight:bold;">${last.roll}</span> (${last.time})</div>
                    <div class="prediction-color-box ${predClass}">${predLabel}</div>
                    <div class="confidence-bar-container"><div class="confidence-bar" style="width: ${confidence}%"></div></div>
                    <div class="confidence-label">Confian√ßa: ${confidence.toFixed(1)}%</div>
                </div>
                <div class="prediction-reasoning"><strong>üß† An√°lise:</strong><ul>${reasoning.map(r => `<li>${r}</li>`).join('')}</ul></div>
            `;
            document.getElementById('sec_prediction_content').innerHTML = html;
            document.getElementById('sec_prediction_modal').style.display = 'flex';
        }

        // --- L√≥gica de Simula√ß√£o de Lucro (Backtest) ---
        function sec_showProfitSimulation() {
            document.getElementById('sec_simulation_modal').style.display = 'flex';
        }

        function sec_runSimulation() {
            const rawData = sessionStorage.getItem('raw_blaze_data');
            if (!rawData) { alert("‚ö†Ô∏è Sem dados para simular."); return; }

            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            const history = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    history.push({ roll: parseInt(tokens[i + 1]), color: sec_identificarCor(parseInt(tokens[i + 1])) });
                    i += 2;
                }
            }
            // Inverte para ordem cronol√≥gica (Antigo -> Novo) para simular a passagem do tempo
            history.reverse();

            const baseBet = parseFloat(document.getElementById('sec_sim_bet').value) || 10;
            const strategy = document.getElementById('sec_sim_strategy').value;
            const maxGales = parseInt(document.getElementById('sec_sim_gale').value);
            const coverWhite = document.getElementById('sec_sim_cover_white').checked;
            const whiteBetAmount = coverWhite ? baseBet * 0.2 : 0; // 20% da aposta no branco

            let balance = 0;
            let wins = 0;
            let losses = 0;
            let currentBet = baseBet;
            let currentGale = 0;
            let targetColor = null; // 'vermelho' ou 'preto'
            
            // Para estrat√©gias que dependem do anterior, come√ßamos do segundo item
            for (let i = 0; i < history.length; i++) {
                const result = history[i];
                
                // Define a cor alvo se n√£o estivermos no meio de um gale
                if (currentGale === 0) {
                    if (strategy === 'red') targetColor = 'vermelho';
                    else if (strategy === 'black') targetColor = 'preto';
                    else if (strategy === 'alternating') {
                        // Se anterior foi vermelho, aposta preto. Se n√£o tem anterior, default vermelho.
                        if (i > 0) targetColor = history[i-1].color === 'vermelho' ? 'preto' : 'vermelho';
                        else targetColor = 'vermelho';
                    }
                    else if (strategy === 'follow') {
                        if (i > 0 && history[i-1].color !== 'branco') targetColor = history[i-1].color;
                        else targetColor = 'vermelho'; // Default
                    }
                }

                // Executa a aposta
                let roundProfit = 0;
                let totalBet = currentBet + whiteBetAmount;
                let won = false;

                // Verifica Branco (14x)
                if (result.color === 'branco') {
                    if (coverWhite) {
                        roundProfit += (whiteBetAmount * 14); // Ganha 14x no branco
                        won = true;
                    }
                    // Aposta na cor perde no branco
                } else {
                    // Verifica Cor (2x)
                    if (result.color === targetColor) {
                        roundProfit += (currentBet * 2); // Ganha 2x na cor
                        won = true;
                    }
                }

                balance -= totalBet; // Deduz a aposta
                balance += roundProfit; // Adiciona o pr√™mio (se houver)

                if (won) {
                    wins++;
                    currentBet = baseBet;
                    currentGale = 0;
                } else {
                    // Loss
                    if (currentGale < maxGales) {
                        currentGale++;
                        currentBet *= 2; // Martingale simples
                        // No Gale, mantemos o targetColor (insist√™ncia)
                    } else {
                        losses++;
                        currentBet = baseBet;
                        currentGale = 0;
                    }
                }
            }

            const resultBox = document.getElementById('sec_sim_results');
            const profitClass = balance >= 0 ? 'sim-profit-positive' : 'sim-profit-negative';
            const profitSign = balance >= 0 ? '+' : '';
            
            resultBox.innerHTML = `
                <div class="sim-profit-display ${profitClass}">LUCRO: ${profitSign}R$ ${balance.toFixed(2)}</div>
                <div class="sim-stat-grid">
                    <div class="sim-stat-item"><span class="sim-stat-label">Entradas</span><span class="sim-stat-value">${history.length}</span></div>
                    <div class="sim-stat-item"><span class="sim-stat-label">Wins</span><span class="sim-stat-value" style="color:#00ff88">${wins}</span></div>
                    <div class="sim-stat-item"><span class="sim-stat-label">Losses (Hit Stop)</span><span class="sim-stat-value" style="color:#ff0055">${losses}</span></div>
                    <div class="sim-stat-item"><span class="sim-stat-label">Assertividade</span><span class="sim-stat-value">${((wins/(wins+losses))*100).toFixed(1)}%</span></div>
                </div>
                <div style="font-size: 0.7rem; color: #888; text-align: center; margin-top: 10px;">*Simula√ß√£o baseada no hist√≥rico atual (${history.length} rodadas). Resultados passados n√£o garantem lucros futuros.</div>
            `;
            resultBox.style.display = 'block';
        }

        // Inicializa√ß√£o
        const savedReverse = localStorage.getItem('sec_reverse_state');
        if (savedReverse !== null) {
            const toggle = document.getElementById('sec_reverseToggle');
            if(toggle) toggle.checked = (savedReverse === 'true');
        }
        sec_toggleDirection();
        
        const autoFetch = document.getElementById('sec_autoFetchToggle');
        if (autoFetch) {
            autoFetch.addEventListener('change', (e) => {
                if (e.target.checked) { sec_fetchData(); sec_interval = setInterval(sec_fetchData, 10000); } 
                else { clearInterval(sec_interval); }
            });
            // Inicia a busca automaticamente ao carregar (sem abrir a IA)
            sec_fetchData();
            sec_interval = setInterval(sec_fetchData, 10000);
        }
    </script>
</body>
</html>