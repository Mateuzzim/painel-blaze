<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estat√≠sticas Num√©ricas</title>
    <style>
        /* Estilos Base (Mesmo padr√£o do ciclo_mercado.html) */
        :root {
            --bg-color: #050507; 
            --panel-bg: rgba(20, 25, 30, 0.6); 
            --text-color: #e0e6ed; 
            --border-color: rgba(0, 242, 255, 0.15); 
            --input-bg: #0a0a0c;
            --accent: #00f2ff; 
            --accent-glow: rgba(0, 242, 255, 0.6);
            --accent-blaze: #ff0055; 
            --accent-jonbet: #00ff9d; 
            --text-muted: #8899a6;
            --color-red: #ff0055; 
            --color-black: #111; 
            --color-white: #fff;
        }
        body { 
            background-color: var(--bg-color); 
            color: var(--text-color); 
            font-family: 'Segoe UI', 'Roboto', sans-serif; 
            margin: 0; 
            padding: 20px; 
            background-image: 
                radial-gradient(circle at 50% 0%, #1a2c38 0%, transparent 70%),
                linear-gradient(rgba(0, 242, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 242, 255, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
            background-attachment: fixed;
            overflow-x: hidden;
        }
        /* Scrollbar Futurista */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        ::-webkit-scrollbar-thumb { background: rgba(0, 242, 255, 0.1); border-radius: 4px; border: 1px solid rgba(0, 242, 255, 0.2); }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); box-shadow: 0 0 15px var(--accent-glow); }

        .main-container { max-width: 98%; margin: 0 auto; }
        
        .layout-panel { 
            background: transparent; 
            border: none; 
            padding: 10px; 
        }
        
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
        h1 { margin: 0; }
        .cortex-text-anim { background: linear-gradient(90deg, var(--accent), var(--accent-blaze), #ff9800, var(--accent)); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: cortex-gradient 3s linear infinite; font-weight: bold; text-shadow: 0 0 10px rgba(0, 242, 255, 0.3); }
        @keyframes cortex-gradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        
        .btn-back { display: inline-flex; align-items: center; gap: 5px; padding: 8px 15px; background: rgba(0, 242, 255, 0.05); color: var(--accent); text-decoration: none; border-radius: 4px; margin-bottom: 15px; font-size: 0.9rem; border: 1px solid var(--border-color); transition: all 0.3s; text-transform: uppercase; letter-spacing: 1px; }
        .btn-back:hover { background: rgba(0, 242, 255, 0.15); border-color: var(--accent); color: #fff; box-shadow: 0 0 15px var(--accent-glow); }
        
        /* Switch Toggle */
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 2px; border: 1px solid #555; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); border-color: var(--accent); box-shadow: 0 0 10px var(--accent-glow); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Estilos Espec√≠ficos da An√°lise Num√©rica */
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px; }
        
        /* Futuristic Card Design */
        .stat-card { 
            background: var(--panel-bg); 
            backdrop-filter: blur(10px); 
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color); 
            border-radius: 4px; 
            padding: 20px; 
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: cardEntry 0.6s ease-out backwards;
        }
        /* Staggered Animation */
        .stats-grid > div:nth-child(1) { animation-delay: 0.05s; }
        .stats-grid > div:nth-child(2) { animation-delay: 0.1s; }
        .stats-grid > div:nth-child(3) { animation-delay: 0.15s; }
        .stats-grid > div:nth-child(4) { animation-delay: 0.2s; }
        .stats-grid > div:nth-child(5) { animation-delay: 0.25s; }
        .stats-grid > div:nth-child(6) { animation-delay: 0.3s; }
        .stats-grid > div:nth-child(7) { animation-delay: 0.35s; }

        @keyframes cardEntry {
            from { opacity: 0; transform: translateY(30px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .stat-card:hover { 
            transform: translateY(-5px) scale(1.02); 
            border-color: var(--accent); 
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.2), inset 0 0 20px rgba(0, 242, 255, 0.05); 
            z-index: 10; 
        }

        /* Tech Corners */
        .stat-card::after { content: ''; position: absolute; top: -1px; right: -1px; width: 10px; height: 10px; border-top: 2px solid var(--accent); border-right: 2px solid var(--accent); transition: all 0.3s; opacity: 0.5; pointer-events: none; }
        .stat-card::before { content: ''; position: absolute; bottom: -1px; left: -1px; width: 10px; height: 10px; border-bottom: 2px solid var(--accent); border-left: 2px solid var(--accent); transition: all 0.3s; opacity: 0.5; pointer-events: none; }
        .stat-card:hover::after, .stat-card:hover::before { width: 100%; height: 100%; opacity: 1; border-color: rgba(0, 242, 255, 0.1); }

        .stat-title { 
            font-family: 'Segoe UI', sans-serif; 
            font-size: 0.8rem; 
            letter-spacing: 1.5px; 
            color: var(--accent); 
            text-transform: uppercase; 
            margin-bottom: 15px; 
            border-bottom: 1px solid rgba(0, 242, 255, 0.2); 
            padding-bottom: 8px; 
            text-shadow: 0 0 5px rgba(0, 242, 255, 0.4);
        }
        
        .color-bar-container { display: flex; height: 25px; border-radius: 4px; overflow: hidden; margin-top: 10px; }
        .color-bar { display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: bold; color: #fff; transition: width 0.5s; text-shadow: 0 0 2px rgba(0,0,0,0.8); }
        .bg-red { background: var(--color-red); }
        .bg-black { background: #222; border-right: 1px solid #444; }
        .bg-white { background: #fff; color: #000; text-shadow: none; }

        .numbers-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 10px; }
        .number-box { 
            background: rgba(0,0,0,0.4); border: 1px solid #333; border-radius: 2px; padding: 10px 5px; 
            text-align: center; position: relative; transition: transform 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }
        .number-box:hover { transform: translateY(-3px); border-color: var(--accent); background: rgba(0, 242, 255, 0.1); }
        .number-box.hot { border-color: var(--accent-jonbet); box-shadow: 0 0 10px rgba(0,255,136,0.2); }
        .number-box.cold { border-color: #ff0055; opacity: 0.7; }
        
        .n-val { font-size: 1.4rem; font-weight: bold; margin-bottom: 5px; }
        .n-red { color: var(--color-red); }
        .n-black { color: #8899a6; }
        .n-white { color: #fff; text-shadow: 0 0 5px #fff; }
        
        .n-count { font-size: 0.75rem; color: var(--text-muted); }
        .n-bar { height: 3px; background: #222; margin-top: 5px; border-radius: 2px; overflow: hidden; }
        .n-fill { height: 100%; background: var(--accent); box-shadow: 0 0 5px var(--accent); }

        .hot-cold-row { display: flex; gap: 10px; margin-top: 5px; }
        .badge { padding: 4px 8px; border-radius: 2px; font-size: 0.8rem; font-weight: bold; color: #fff; clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%); }
        .badge-hot { background: rgba(0, 255, 136, 0.15); color: #00ff88; border: 1px solid rgba(0, 255, 136, 0.3); }
        .badge-cold { background: rgba(255, 0, 85, 0.2); color: #ff0055; border: 1px solid rgba(255, 0, 85, 0.3); }

        /* Estilos para Sequ√™ncia e Previs√£o */
        .seq-badge { width: 30px; height: 30px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.8rem; border: 1px solid #333; margin-right: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .seq-red { background: var(--color-red); border-color: #ff0055; color: #fff; }
        .seq-black { background: #222; border-color: #444; color: #fff; }
        .seq-white { background: #fff; border-color: #fff; color: #000; }

        /* Estilo para a bolha de previs√£o */
        .prediction-bubble {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, #ff8a8a, #ff0055);
            border-radius: 50%;
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 0 10px rgba(255, 255, 255, 0.5),
                0 5px 15px rgba(255, 0, 85, 0.4),
                0 0 30px rgba(255, 0, 85, 0.3);
            margin: 0 auto;
        }
        .prediction-bubble.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: 
                inset 0 0 10px rgba(255, 255, 255, 0.2),
                0 5px 15px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(255, 255, 255, 0.1);
        }
        .prediction-bubble::before {
            content: '';
            position: absolute;
            top: 10%; left: 20%; width: 15px; height: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            filter: blur(2px);
        }
        .prediction-bubble-text { font-size: 1.5rem; font-weight: bold; color: #fff; text-shadow: 0 0 5px rgba(0,0,0,0.5); }

        @keyframes blink-success {
            0%, 100% { border-color: #444; box-shadow: none; }
            50% { border-color: #00ff88; box-shadow: 0 0 15px rgba(0, 255, 136, 0.6); }
        }
        .blink-alert {
            animation: blink-success 0.5s ease-in-out 4;
        }
    </style>
    <style>
        /* Estilos para o filtro de giros */
        .filter-buttons { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }
        .filter-btn {
            background: rgba(255,255,255,0.05); border: 1px solid #333; color: #aaa;
            padding: 8px 20px; border-radius: 20px; cursor: pointer;
            font-size: 0.9rem; transition: all 0.3s;
        }
        .filter-btn:hover { 
            background: rgba(0, 210, 255, 0.1); color: #00d2ff; border-color: #00d2ff;
        }
        .filter-btn:active { transform: translateY(0) scale(0.98); }
        .filter-btn.active {
            background: #00d2ff; color: #000; border-color: #00d2ff; 
        }

        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 768px) {
            body { padding: 5px; }
            .layout-panel { padding: 10px; }
            .stats-grid {
                /* Opcional: Descomente a linha abaixo para for√ßar 1 coluna em telas muito pequenas */
                grid-template-columns: 1fr;
            }
            .numbers-grid {
                grid-template-columns: repeat(auto-fit, minmax(45px, 1fr));
                gap: 5px;
            }
            .number-box { padding: 5px; }
            .n-val { font-size: 1rem; }
            .hot-cold-row {
                flex-wrap: wrap;
                justify-content: center;
            }
            #pie_chart_container {
                flex-direction: column;
                gap: 15px;
                padding: 10px;
            }
            #pie_chart_container > div {
                margin-left: 0 !important; /* Remove a margem da legenda no mobile */
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="layout-panel">
            <div class="main-header" style="display: none;">
                <h1 class="cortex-text-anim">ESTAT√çSTICAS NUM√âRICAS</h1>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 0.8rem; color: #aaa;">Auto-Atualizar:</span>
                    <label class="switch" style="transform: scale(0.8);">
                        <input type="checkbox" id="autoUpdateToggle" checked onchange="toggleAutoUpdate()">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <a href="index.html" class="btn-back" style="display: none;">‚Üê Voltar ao Painel</a>

            <!-- Filtro de Giros -->
            <div class="control-group" style="margin-bottom: 20px; text-align: center; display: none;">
                <div class="filter-buttons">
                    <button class="filter-btn" onclick="setAnalysisLimit(50)">50</button>
                    <button class="filter-btn active" onclick="setAnalysisLimit(100)">100</button>
                    <button class="filter-btn" onclick="setAnalysisLimit(500)">500</button>
                    <button class="filter-btn" onclick="setAnalysisLimit(null)">Todos</button>
                </div>
            </div>

            <div id="loading" style="text-align: center; color: #888; padding: 20px;">Carregando dados...</div>
            
            <div id="content" style="display: none;">
                <!-- Grupo 2: Tend√™ncias e Previs√£o -->
                <div class="stats-grid">
                    <!-- Previs√£o de Padr√£o -->
                    <div class="stat-card">
                        <div class="stat-title">üîÆ Previs√£o de Padr√£o (√öltimos 5)</div>
                        
                        <!-- Placar Win/Loss -->
                        <div style="display: flex; justify-content: space-around; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 6px; margin-bottom: 15px; border: 1px solid #333;">
                            <div style="text-align: center;">
                                <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 2px;">WIN</div>
                                <div id="pred_wins" style="font-size: 1.1rem; font-weight: bold; color: #00ff88;">0</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 2px;">LOSS</div>
                                <div id="pred_losses" style="font-size: 1.1rem; font-weight: bold; color: #ff0055;">0</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 2px;">ASSERTIVIDADE</div>
                                <div id="pred_rate" style="font-size: 1.1rem; font-weight: bold; color: #fff;">0%</div>
                            </div>
                        </div>

                                                                                                                                                                                                                                            <!-- Hist√≥rico Visual de Entradas -->
                        <div style="margin-bottom: 15px;">
                            <div style="font-size: 0.75rem; color: #aaa; margin-bottom: 5px; text-align: center;">√öltimas 10 Entradas</div>
                            <div id="entry_history_container" style="display: flex; justify-content: center; gap: 6px; flex-wrap: wrap; min-height: 14px;"></div>
                        </div>

                        <!-- Indicador de For√ßa do Sinal -->
                        <div style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: #aaa; margin-bottom: 4px;">
                                <span>For√ßa do Sinal</span>
                                <span id="signal_strength_text" style="font-weight: bold;">--</span>
                            </div>
                            <div style="height: 6px; background: #222; border-radius: 3px; overflow: hidden; border: 1px solid #333;">
                                <div id="signal_strength_bar" style="width: 0%; height: 100%; background: #444; transition: all 0.5s ease;"></div>
                            </div>
                        </div>

                        <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 15px; flex-wrap: wrap; gap: 10px;">
                            <div id="last_5_sequence" style="display: flex;"></div>
                            <div style="text-align: left; flex: 1;">
                                <div style="font-size: 0.8rem; color: #aaa;">üö® ALERTA DE ENTRADA:</div>
                                <div id="prediction_result" style="font-size: 1.1rem; font-weight: bold; color: #fff;">Aguardando...</div>
                            </div>
                        </div>
                    </div>
                    <!-- Gr√°fico de Tend√™ncia -->
                    <div class="stat-card">
                        <div class="stat-title" style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="trend_chart_title">üìà Tend√™ncia de Saldo (Vermelho vs Preto - √öltimos 100)</span>
                            <span id="trend_strength_indicator" style="font-size: 0.7rem; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.1);">Calculando...</span>
                        </div>
                        <div id="trend_chart_container" style="width: 100%; height: 120px; margin-top: 10px;"></div>
                    </div>
                </div>

                <!-- Simula√ß√£o de Estrat√©gia (Movido para c√° - Linha √önica) -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-title">üéÆ Simula√ß√£o de Estrat√©gia (Backtest)</div>
                        <div style="display: flex; gap: 10px; margin: 10px 0; align-items: center; justify-content: center; flex-wrap: wrap;">
                            <select id="sim_strategy" onchange="handleStrategyChange()" style="padding: 5px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px;">
                                <option value="alternating">Alternar (Xadrez)</option>
                                <option value="follow">Seguir a Cor (Surf)</option>
                                <option value="majority">Maioria (√öltimos 5)</option>
                                <option value="ia_cores">IA Cores (Preditiva)</option>
                                <option value="analise_cores">An√°lise Cores (H√≠brida)</option>
                                <option value="alignment">Padr√£o Alinhamento (Tend√™ncia 20)</option>
                                <option value="euler">Onda de Euler (C√≠clico)</option>
                                <option value="gauss">Curva de Gauss (√öltimos 7)</option>
                                <option value="fibonacci">Fibonacci (Retra√ß√£o)</option>
                                <option value="sniper">Sniper (Alta Precis√£o)</option>
                            </select>
                            <select id="sim_gale_level" onchange="runSimulation()" style="padding: 5px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px;">
                                <option value="0">Sem Gale</option>
                                <option value="1" selected>Gale 1</option>
                                <option value="2">Gale 2</option>
                                <option value="3">Gale 3</option>
                            </select>
                            <button class="filter-btn" onclick="runSimulation()" style="background: #00d2ff; color: #000; border: none; padding: 6px 15px;">Recalcular</button>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Auto Melhor:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="best_strategy_toggle" checked onchange="toggleBestStrategy()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Analisar Branco:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="analyze_white_toggle" checked onchange="runSimulation()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Manter 4 Rodadas:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="persistence_toggle" checked>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Gale Invertido:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="gale_invert_toggle" onchange="runSimulation()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Confirma√ß√£o:</span>
                                <button onclick="changeConfirmation(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="confirmation_display" style="font-weight: bold; color: #00d2ff; min-width: 15px; text-align: center;">2</span>
                                <button onclick="changeConfirmation(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                        </div>
                        <div id="golden_hour_results" style="margin-top: 10px;"></div>
                        <div style="display: flex; justify-content: space-around; text-align: center; margin-top: 15px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                            <div><div style="font-size: 0.8rem; color: #aaa;">Wins</div><div id="sim_wins" style="font-size: 1.2rem; font-weight: bold; color: #00ff88;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Losses</div><div id="sim_losses" style="font-size: 1.2rem; font-weight: bold; color: #ff0055;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Assertividade</div><div id="sim_rate" style="font-size: 1.2rem; font-weight: bold; color: #fff;">0%</div></div>
                            <div>
                                <div style="font-size: 0.8rem; color: #aaa;">Saldo (R$10)</div>
                                <div id="sim_balance" style="font-size: 1.2rem; font-weight: bold; color: #00d2ff;">R$ 0</div>
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-around; text-align: center; margin-top: 5px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                            <div><div style="font-size: 0.8rem; color: #aaa;">Maior Seq. Vit√≥rias</div><div id="sim_max_win" style="font-size: 1.2rem; font-weight: bold; color: #00ff88;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Maior Seq. Derrotas</div><div id="sim_max_loss" style="font-size: 1.2rem; font-weight: bold; color: #ff0055;">0</div></div>
                        </div>
                        <div id="gale_distribution_chart_container" style="width: 100%; height: 120px; margin-top: 15px;"></div>
                        <div style="font-size: 0.7rem; color: #666; text-align: center; margin-top: 5px;">*Simula√ß√£o baseada nos dados filtrados acima.</div>
                    </div>
                </div>

                <!-- Grupo 3: Estat√≠sticas B√°sicas -->
                <div class="stats-grid">
                    <!-- Hot Numbers -->
                    <div class="stat-card">
                        <div class="stat-title">üî• N√∫meros Quentes (Top 3)</div>
                        <div id="hot_numbers" class="hot-cold-row"></div>
                    </div>
                    <!-- Cold Numbers -->
                    <div class="stat-card">
                        <div class="stat-title">‚ùÑÔ∏è N√∫meros Frios (Top 3)</div>
                        <div id="cold_numbers" class="hot-cold-row"></div>
                    </div>
                    <!-- Par/√çmpar -->
                    <div class="stat-card">
                        <div class="stat-title">‚öñÔ∏è Par vs √çmpar (Sem o 0)</div>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
                            <div style="flex: 1; text-align: center;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #00d2ff;" id="even_pct">0%</div>
                                <div style="font-size: 0.7rem; color: #666;">PARES</div>
                            </div>
                            <div style="width: 1px; height: 30px; background: #333;"></div>
                            <div style="flex: 1; text-align: center;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #ff9800;" id="odd_pct">0%</div>
                                <div style="font-size: 0.7rem; color: #666;">√çMPARES</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Grupo 4: An√°lise de Sequ√™ncia -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-title">üîç Ap√≥s o <span id="last_number_display" style="color:#fff; font-weight:bold;">--</span> vem...</div>
                        <div id="post_number_stats" style="font-size: 0.9rem; color: #ccc; margin-top: 10px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
                            Aguardando dados...
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">‚ö™ Gatilhos do Branco (Top 3)</div>
                        <div id="white_triggers_stats" style="font-size: 0.9rem; color: #ccc; margin-top: 10px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
                            Aguardando dados...
                        </div>
                    </div>
                </div>

                <!-- Grupo 5: An√°lise Profunda -->
                <div class="stats-grid">
                    <!-- Compara√ß√£o de Per√≠odos -->
                    <div class="stat-card">
                        <div class="stat-title">‚öñÔ∏è Compara√ß√£o de Per√≠odos (Extremos da Sele√ß√£o)</div>
                        <div style="display: flex; gap: 20px; justify-content: space-around; flex-wrap: wrap; margin-top: 10px;">
                            <div style="flex: 1; min-width: 200px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                                <div style="text-align: center; color: #00ff88; font-weight: bold; margin-bottom: 10px; font-size: 0.9rem;">Recentes (50)</div>
                                <div id="comp_recent_stats"></div>
                            </div>
                            <div style="flex: 1; min-width: 200px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                                <div style="text-align: center; color: #ff9800; font-weight: bold; margin-bottom: 10px; font-size: 0.9rem;">Antigos (50)</div>
                                <div id="comp_old_stats"></div>
                            </div>
                        </div>
                        <div id="comp_message" style="text-align: center; color: #666; font-size: 0.8rem; margin-top: 10px;"></div>
                    </div>
                </div>

                <!-- Grupo 6: Frequ√™ncia e Hor√°rios -->
                <div class="stats-grid">
                    <!-- Grid de Todos os N√∫meros -->
                    <div class="stat-card">
                        <div class="stat-title">üìä Frequ√™ncia por N√∫mero (0-14)</div>
                        <div class="numbers-grid" id="numbers_grid"></div>
                    </div>
                    <!-- Gr√°fico de Hor√°rios Quentes -->
                    <div class="stat-card">
                        <div class="stat-title">‚è∞ Hor√°rios Quentes (Frequ√™ncia por Hora)</div>
                        <div style="display: flex; justify-content: center; gap: 10px; margin: 10px 0;">
                            <button class="filter-btn active" onclick="setHotHoursColor('red')" id="btn_hh_red" style="border-color: #ff0055; color: #ff0055; background: rgba(255, 0, 85, 0.2);">Vermelho</button>
                            <button class="filter-btn" onclick="setHotHoursColor('white')" id="btn_hh_white" style="border-color: #fff; color: #fff;">Branco</button>
                            <button class="filter-btn" onclick="setHotHoursColor('black')" id="btn_hh_black" style="border-color: #888; color: #888;">Preto</button>
                        </div>
                        <div id="hot_hours_chart_container" style="width: 100%; height: 150px; margin-top: 10px;"></div>
                    </div>
                </div>

                <!-- Grupo 7: Ferramentas -->
                <div class="stats-grid">
                    <!-- Gr√°fico de Dispers√£o -->
                    <div class="stat-card">
                        <div class="stat-title">üåå Dispers√£o (Minuto vs N√∫mero)</div>
                        <div id="scatter_chart_container" style="width: 100%; height: 200px; margin-top: 10px;"></div>
                    </div>
                    <!-- Alerta de Padr√£o Personalizado -->
                    <div class="stat-card" style="display: flex; flex-direction: column; justify-content: space-between;">
                        <div class="stat-title">üîî Alerta de Padr√£o Personalizado</div>
                        <div style="display: flex; gap: 8px; justify-content: center; margin-top: 15px; flex-wrap: wrap;">
                            <button class="filter-btn" onclick="addToPattern('red')" style="border-color: #ff0055; color: #ff0055;">V</button>
                            <button class="filter-btn" onclick="addToPattern('black')" style="border-color: #888; color: #888;">P</button>
                            <button class="filter-btn" onclick="addToPattern('white')" style="border-color: #fff; color: #fff;">B</button>
                            <button class="filter-btn" onclick="clearPattern()" style="border-color: #ff9800; color: #ff9800;">Limpar</button>
                        </div>
                        <div id="custom_pattern_display" style="min-height: 40px; margin: 15px 0; display: flex; justify-content: center; gap: 8px; align-items: center; background: rgba(0,0,0,0.2); border-radius: 8px;"></div>
                        <div id="pattern_alert_status" style="text-align: center; font-weight: bold; min-height: 20px;"></div>
                    </div>
                    <!-- Controle de Tamanho (Movido) -->
                    <div class="stat-card" style="display: flex; flex-direction: column; justify-content: center;">
                        <div class="stat-title">üîç Tamanho da Vela (Zoom)</div>
                        <div class="filter-buttons" style="margin-top: 20px; justify-content: center; gap: 15px;">
                            <button class="filter-btn" onclick="changeChartScale(-0.2)">Diminuir</button>
                            <button class="filter-btn" onclick="resetChartScale()">Padr√£o</button>
                            <button class="filter-btn" onclick="changeChartScale(0.2)">Aumentar</button>
                        </div>
                    </div>
                </div>

                <!-- Grupo 1: Vis√£o Geral (Movido) -->
                <div class="stats-grid">
                    <!-- Resumo de Cores -->
                    <div class="stat-card">
                        <div class="stat-title">Distribui√ß√£o de Cores (√öltimos <span id="total_spins">0</span> giros)</div>
                        <div class="color-bar-container">
                            <div id="bar_red" class="color-bar bg-red" style="width: 0%">0%</div>
                            <div id="bar_white" class="color-bar bg-white" style="width: 0%">0%</div>
                            <div id="bar_black" class="color-bar bg-black" style="width: 0%">0%</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.75rem; color: #888;">
                            <span id="count_red">Vermelho: 0</span>
                            <span id="count_white">Branco: 0</span>
                            <span id="count_black">Preto: 0</span>
                        </div>
                    </div>
                    <!-- Gr√°fico de Pizza Futurista -->
                    <div class="stat-card">
                        <div class="stat-title">üç∞ Distribui√ß√£o Visual (Pizza Futurista)</div>
                        <div id="pie_chart_container" style="display: flex; justify-content: center; align-items: center; padding: 20px; position: relative;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let updateInterval;
        let fullBlazeData = []; // Armazena todos os dados buscados
        let analysisLimit = 100; // Limite padr√£o de an√°lise
        let hotHoursColor = 'red'; // Cor padr√£o para hor√°rios quentes
        let customPattern = []; // Padr√£o personalizado
        let chartScale = 1; // Escala dos gr√°ficos
        let autoStrategyCounter = 0; // Contador para persist√™ncia
        let confirmationLevel = 2; // N√≠vel de confirma√ß√£o (velas)

        document.addEventListener('DOMContentLoaded', () => {
            fetchBlazeData();
            if(document.getElementById('autoUpdateToggle').checked) toggleAutoUpdate();
        });

        function setAnalysisLimit(limit) {
            analysisLimit = limit;

            // Atualiza o bot√£o ativo
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            const limitValue = limit === null ? 'null' : limit;
            const activeButton = document.querySelector(`.filter-btn[onclick="setAnalysisLimit(${limitValue})"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }

            if (fullBlazeData.length > 0) {
                analyzeData(fullBlazeData);
            }
        }

        function changeChartScale(delta) {
            chartScale += delta;
            if (chartScale < 0.5) chartScale = 0.5;
            if (chartScale > 3) chartScale = 3;
            if (fullBlazeData.length > 0) analyzeData(fullBlazeData);
        }

        function resetChartScale() {
            chartScale = 1;
            if (fullBlazeData.length > 0) analyzeData(fullBlazeData);
        }

        function changeConfirmation(delta) {
            confirmationLevel += delta;
            if (confirmationLevel < 1) confirmationLevel = 1;
            if (confirmationLevel > 6) confirmationLevel = 6;
            document.getElementById('confirmation_display').innerText = confirmationLevel;
            runSimulation();
        }

        function toggleAutoUpdate() {
            const toggle = document.getElementById('autoUpdateToggle');
            if (toggle && toggle.checked) {
                if (updateInterval) clearInterval(updateInterval);
                updateInterval = setInterval(fetchBlazeData, 10000);
            } else {
                if (updateInterval) clearInterval(updateInterval);
            }
        }

        async function fetchBlazeData() {
            try {
                const agora = new Date();
                const ontem = new Date();
                ontem.setHours(ontem.getHours() - 24);
                
                const endDate = agora.toISOString();
                const startDate = ontem.toISOString();
                
                let allGames = [];
                // Busca p√°ginas 1 a 5 para garantir dados suficientes (aprox 500 jogos)
                for (let page = 1; page <= 5; page++) {
                    const baseUrl = `https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/history/${page}`;
                    const params = `?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}&page=${page}&_nc=${Date.now()}`;
                    const targetUrl = `${baseUrl}${params}`;
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                    
                    try {
                        const response = await fetch(proxyUrl);
                        if (response.ok) {
                            const data = await response.json();
                            const records = Array.isArray(data) ? data : (data.records || []);
                            if (records.length === 0) break;
                            allGames = allGames.concat(records);
                        }
                    } catch (e) { console.warn(`Erro na p√°gina ${page}`, e); }
                }

                // Remove duplicatas e ordena
                const seenIds = new Set();
                fullBlazeData = allGames.filter(game => {
                    if (game.id && !seenIds.has(game.id)) { seenIds.add(game.id); return true; }
                    return false;
                }).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                if (fullBlazeData.length === 0) throw new Error("Nenhum dado encontrado.");

                analyzeData(fullBlazeData, true);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
            } catch (error) {
                console.error("Erro:", error);
                document.getElementById('loading').innerHTML = '<span style="color: #ff0055;">Erro ao carregar dados. Verifique sua conex√£o ou tente mais tarde.</span>';
            }
        }

        function analyzeData(fullData, isAutoUpdate = false) {
            // Corta os dados com base no limite selecionado
            const data = analysisLimit ? fullData.slice(0, analysisLimit) : fullData;

            if (!data || data.length === 0) {
                return; // N√£o faz nada se n√£o houver dados
            }
            
            const total = data.length;
            const counts = Array(15).fill(0);
            let red = 0, black = 0, white = 0;
            let even = 0, odd = 0;

            data.forEach(game => {
                const r = game.roll;
                counts[r]++;
                
                if (r === 0) white++;
                else if (r >= 1 && r <= 7) red++;
                else if (r >= 8 && r <= 14) black++;

                if (r !== 0) {
                    if (r % 2 === 0) even++; else odd++;
                }
            });

            // Atualiza Cores
            const pRed = ((red/total)*100).toFixed(1);
            const pWhite = ((white/total)*100).toFixed(1);
            const pBlack = ((black/total)*100).toFixed(1);

            document.getElementById('total_spins').innerText = total;
            
            document.getElementById('bar_red').style.width = `${pRed}%`;
            document.getElementById('bar_red').innerText = pRed > 5 ? `${pRed}%` : '';
            document.getElementById('count_red').innerText = `Vermelho: ${red}`;

            document.getElementById('bar_white').style.width = `${pWhite}%`;
            document.getElementById('bar_white').innerText = pWhite > 3 ? `${pWhite}%` : '';
            document.getElementById('count_white').innerText = `Branco: ${white}`;

            document.getElementById('bar_black').style.width = `${pBlack}%`;
            document.getElementById('bar_black').innerText = pBlack > 5 ? `${pBlack}%` : '';
            document.getElementById('count_black').innerText = `Preto: ${black}`;

            // Atualiza Par/√çmpar
            const totalNonZero = even + odd;
            document.getElementById('even_pct').innerText = totalNonZero ? Math.round((even/totalNonZero)*100) + '%' : '0%';
            document.getElementById('odd_pct').innerText = totalNonZero ? Math.round((odd/totalNonZero)*100) + '%' : '0%';

            // Prepara Grid e Hot/Cold
            const maxCount = Math.max(...counts);
            const numberObjects = counts.map((count, num) => ({ num, count })).sort((a, b) => b.count - a.count);
            
            const hot = numberObjects.slice(0, 3);
            const cold = numberObjects.slice(-3).reverse();

            const renderBadge = (item, type) => `
                <div style="text-align: center;">
                    <div class="badge ${type === 'hot' ? 'badge-hot' : 'badge-cold'}">${item.num}</div>
                    <div style="font-size: 0.7rem; color: #888; margin-top: 2px;">${item.count}x</div>
                </div>`;

            document.getElementById('hot_numbers').innerHTML = hot.map(i => renderBadge(i, 'hot')).join('');
            document.getElementById('cold_numbers').innerHTML = cold.map(i => renderBadge(i, 'cold')).join('');

            // Renderiza Grid
            let gridHtml = '';
            for(let i=0; i<=14; i++) {
                const count = counts[i];
                const pct = ((count/total)*100).toFixed(0);
                const barPct = (count/maxCount)*100;
                
                let colorClass = 'n-white';
                if (i >= 1 && i <= 7) colorClass = 'n-red';
                if (i >= 8 && i <= 14) colorClass = 'n-black';

                let borderClass = '';
                if (hot.some(h => h.num === i)) borderClass = 'hot';
                if (cold.some(c => c.num === i)) borderClass = 'cold';

                gridHtml += `
                    <div class="number-box ${borderClass}">
                        <div class="n-val ${colorClass}">${i}</div>
                        <div class="n-count">${count}x (${pct}%)</div>
                        <div class="n-bar"><div class="n-fill" style="width: ${barPct}%; background: ${i===0 ? '#fff' : (i<=7 ? '#ff0055' : '#888')}"></div></div>
                    </div>
                `;
            }
            document.getElementById('numbers_grid').innerHTML = gridHtml;
            
            updatePrediction(fullData);
            renderHotHoursChart(fullData);
            runSimulation(false, isAutoUpdate);
            analyzeSequences(fullData);
            renderPieChart(data);
            renderPeriodComparison(data);
            checkPattern(); // Verifica padr√£o ao atualizar dados
            renderScatterChart(data);
        }

        function renderTrendChart(points, title) {
            const container = document.getElementById('trend_chart_container');
            if (!container) return;

            if (title) {
                const titleEl = document.getElementById('trend_chart_title');
                if (titleEl) titleEl.innerText = title;
            }

            if (!points || points.length === 0) return;

            const width = container.clientWidth || 500;
            const height = 120 * chartScale;
            container.style.height = height + 'px';
            const padding = 15;

            const minVal = Math.min(0, ...points);
            const maxVal = Math.max(0, ...points);
            const range = (maxVal - minVal) || 1;

            const getX = (i) => padding + (i / (points.length - 1)) * (width - 2 * padding);
            const getY = (val) => height - padding - ((val - minVal) / range) * (height - 2 * padding);

            let pathD = `M ${getX(0)} ${getY(points[0])}`;
            for (let i = 1; i < points.length; i++) {
                pathD += ` L ${getX(i)} ${getY(points[i])}`;
            }

            const zeroY = getY(0);
            const zeroOffset = Math.max(0, Math.min(1, zeroY / height));
            const lastVal = points[points.length - 1];
            const svgId = 'trend_' + Math.random().toString(36).substr(2, 9);

            const svg = `
                <svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 100%; overflow: visible;">
                    <defs>
                        <linearGradient id="grad_${svgId}" x1="0" y1="0" x2="0" y2="${height}" gradientUnits="userSpaceOnUse">
                            <stop offset="0" stop-color="#00ff88" />
                            <stop offset="${zeroOffset}" stop-color="#00ff88" />
                            <stop offset="${zeroOffset}" stop-color="#ff0055" />
                            <stop offset="1" stop-color="#ff0055" />
                        </linearGradient>
                        <filter id="glow_${svgId}" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    <line x1="${padding}" y1="${zeroY}" x2="${width - padding}" y2="${zeroY}" stroke="#444" stroke-dasharray="4" stroke-width="1" />
                    <path d="${pathD}" fill="none" stroke="url(#grad_${svgId})" stroke-width="2.5" filter="url(#glow_${svgId})" stroke-linecap="round" stroke-linejoin="round">
                        <animate attributeName="stroke-dasharray" from="0, 5000" to="5000, 0" dur="2.5s" fill="freeze" calcMode="spline" keySplines="0.4 0 0.2 1" keyTimes="0;1" />
                    </path>
                    <circle cx="${getX(points.length - 1)}" cy="${getY(lastVal)}" r="4" fill="#fff" filter="url(#glow_${svgId})">
                        <animate attributeName="r" values="3;6;3" dur="1.5s" repeatCount="indefinite" />
                        <animate attributeName="opacity" values="1;0.6;1" dur="1.5s" repeatCount="indefinite" />
                    </circle>
                    <text x="${width - padding}" y="${getY(lastVal) - 10}" fill="${lastVal >= 0 ? '#00ff88' : '#ff0055'}" font-size="12" text-anchor="end" font-weight="bold" style="text-shadow: 0 0 5px rgba(0,0,0,0.8);">
                        ${lastVal > 0 ? '+' : ''}${lastVal}
                    </text>
                </svg>
            `;
            container.innerHTML = svg;
            updateTrendIndicator(points);
        }

        function updatePrediction(data) {
            if (!data || data.length < 1) return;
            
            const strategy = document.getElementById('sim_strategy').value;
            const analyzeWhite = document.getElementById('analyze_white_toggle')?.checked || false;
            const last5 = data.slice(0, 5);
            const container = document.getElementById('last_5_sequence');
            const predictionEl = document.getElementById('prediction_result');
            
            if (!container || !predictionEl) return;

            // 1. Renderiza a sequ√™ncia visual (√öltimos 5)
            let html = '';
            for(let i = last5.length - 1; i >= 0; i--) {
                const r = last5[i].roll;
                let colorClass = 'seq-white';
                if (r >= 1 && r <= 7) colorClass = 'seq-red';
                else if (r >= 8 && r <= 14) colorClass = 'seq-black';
                html += `<div class="seq-badge ${colorClass}">${r}</div>`;
            }
            container.innerHTML = html;

            // Helper: Previs√£o baseada na estrat√©gia selecionada (History: Newest -> Oldest)
            const getStratPrediction = (hist) => {
                if (!hist || hist.length === 0) return null;
                
                // Fun√ß√µes auxiliares de cor
                const getColorRaw = (r) => (r === 0) ? 'white' : ((r >= 1 && r <= 7) ? 'red' : 'black');

                const getColor = (idx) => {
                    if (idx >= hist.length) return 'white';
                    const r = hist[idx].roll;
                    const c = getColorRaw(r);
                    if (c === 'white' && analyzeWhite) {
                        let rC = 0, bC = 0;
                        for(let k=1; k<=5; k++) {
                            if (idx + k < hist.length) {
                                const val = hist[idx + k].roll;
                                if (val >= 1 && val <= 7) rC++;
                                else if (val >= 8 && val <= 14) bC++;
                            }
                        }
                        return rC >= bC ? 'red' : 'black';
                    }
                    return c;
                };
                
                // Helper para verificar sequ√™ncia
                const checkPattern = (type, len) => {
                    if (hist.length < len) return false;
                    const first = getColor(0);
                    if (first === 'white') return false;
                    for (let k = 1; k < len; k++) {
                        const curr = getColor(k);
                        if (type === 'follow' && curr !== first) return false;
                        if (type === 'alternating') {
                            const expected = (k % 2 === 0) ? first : (first === 'red' ? 'black' : 'red');
                            if (curr !== expected) return false;
                        }
                    }
                    return true;
                };

                if (strategy === 'alternating') {
                    if (checkPattern('alternating', confirmationLevel)) {
                        const lastColor = getColor(0);
                        return (lastColor === 'red' ? 'black' : 'red');
                    }
                } 
                else if (strategy === 'follow') {
                    if (checkPattern('follow', confirmationLevel)) {
                        return getColor(0);
                    }
                }
                else if (strategy === 'majority') {
                    if (hist.length < 5) return null;
                    let r=0, b=0;
                    for(let i=0; i<5; i++) {
                        const c = getColor(i);
                        if(c === 'red') r++; else if(c === 'black') b++;
                    }
                    // Assertividade: Exige margem de pelo menos 2 (Ex: 4v1 ou 5v0)
                    if (r >= b + 2) return 'red';
                    if (b >= r + 2) return 'black';
                }
                else if (strategy === 'ia_cores') {
                    if (hist.length < 5) return null;
                    let rScore=0, bScore=0;
                    const hColors = [];
                    for(let i=0; i<5; i++) hColors.push(getColor(i));
                    
                    if(hColors[0]===hColors[1] && hColors[1]===hColors[2]) {
                        if(hColors[0]==='red') rScore+=2; else if(hColors[0]==='black') bScore+=2;
                    }
                    if(hColors[0]!==hColors[1] && hColors[1]!==hColors[2]) {
                        if(hColors[0]==='red') bScore+=2; else if(hColors[0]==='black') rScore+=2;
                    }
                    const rCount = hColors.filter(c=>c==='red').length;
                    const bCount = hColors.filter(c=>c==='black').length;
                    if(rCount > bCount) rScore++; else bScore++;
                    
                    if(rScore > bScore) return 'red';
                    if(bScore > rScore) return 'black';
                }
                else if (strategy === 'analise_cores') {
                    if (checkPattern('follow', confirmationLevel)) return getColor(0);
                    else if (checkPattern('alternating', confirmationLevel)) {
                        const last = getColor(0);
                        return (last === 'red' ? 'black' : 'red');
                    }
                }
                else if (strategy === 'alignment') {
                    if (hist.length < 20) return null;
                    let r=0, b=0;
                    for(let i=0; i<20; i++) {
                        const c = getColor(i);
                        if(c==='red') r++; else if(c==='black') b++;
                    }
                    // Assertividade: Exige maioria simples mas consistente
                    if(r > b + 2) return 'red';
                    if(b > r + 2) return 'black';
                }
                else if (strategy === 'euler') {
                    if (checkPattern('alternating', confirmationLevel)) {
                        const last = getColor(0);
                        return (last === 'red' ? 'black' : 'red');
                    } else if (checkPattern('follow', confirmationLevel)) {
                        return getColor(0);
                    }
                }
                else if (strategy === 'gauss') {
                    if (hist.length < 7) return null;
                    let r=0, b=0;
                    for(let i=0; i<7; i++) {
                        const c = getColor(i);
                        if(c==='red') r++; else if(c==='black') b++;
                    }
                    // Assertividade: Margem de seguran√ßa
                    if(r >= b + 2) return 'red';
                    if(b >= r + 2) return 'black';
                }
                else if (strategy === 'fibonacci') {
                    const fibs = [1, 2, 3, 5, 8, 13];
                    let r=0, b=0;
                    fibs.forEach(fib => {
                        if(hist.length > fib) {
                            const c = getColor(fib-1); // -1 pois array come√ßa em 0
                            if(c==='red') r++; else if(c==='black') b++;
                        }
                    });
                    // Assertividade: Margem de seguran√ßa
                    if(r >= b + 1) return 'red';
                    if(b >= r + 1) return 'black';
                }
                else if (strategy === 'sniper') {
                    // Sniper agora usa confirmationLevel para definir o tamanho da sequ√™ncia a reverter
                    if (checkPattern('follow', confirmationLevel)) {
                        const last = getColor(0);
                        return (last === 'red' ? 'black' : 'red');
                    }
                }
                
                return null;
            };

            // Gera Previs√£o Atual (Alerta de Entrada)
            const currentPred = getStratPrediction(data);
            let suggestion = 'Aguardando Padr√£o...';
            let suggestionColor = '#aaa';

            if (currentPred === 'red') {
                suggestion = 'üî¥ ENTRAR NO VERMELHO';
                suggestionColor = '#ff0055';
            } else if (currentPred === 'black') {
                suggestion = '‚ö´ ENTRAR NO PRETO';
                suggestionColor = '#fff';
            }

            predictionEl.innerHTML = suggestion;
            predictionEl.style.color = suggestionColor;
        }

        function setHotHoursColor(color) {
            hotHoursColor = color;
            // Atualiza bot√µes
            ['red', 'white', 'black'].forEach(c => {
                const btn = document.getElementById(`btn_hh_${c}`);
                if (btn) {
                    if (c === color) {
                        btn.classList.add('active');
                        btn.style.background = c === 'red' ? 'rgba(255, 0, 85, 0.2)' : (c === 'white' ? 'rgba(255, 255, 255, 0.2)' : 'rgba(136, 136, 136, 0.2)');
                    } else {
                        btn.classList.remove('active');
                        btn.style.background = 'transparent';
                    }
                }
            });
            if (fullBlazeData.length > 0) renderHotHoursChart(fullBlazeData);
        }

        function renderHotHoursChart(data) {
            const container = document.getElementById('hot_hours_chart_container');
            if (!container || !data || data.length === 0) return;

            const hourlyCounts = new Array(24).fill(0);
            
            data.forEach(game => {
                if (!game.created_at) return;
                const date = new Date(game.created_at);
                const hour = date.getHours();
                const r = game.roll;
                
                let isMatch = false;
                if (hotHoursColor === 'red' && r >= 1 && r <= 7) isMatch = true;
                else if (hotHoursColor === 'black' && r >= 8 && r <= 14) isMatch = true;
                else if (hotHoursColor === 'white' && r === 0) isMatch = true;

                if (isMatch) hourlyCounts[hour]++;
            });

            const maxCount = Math.max(...hourlyCounts, 1);
            const width = container.clientWidth || 500;
            const height = 150 * chartScale;
            container.style.height = height + 'px';
            const barWidth = (width / 24) - 2;
            
            let svgContent = '';
            let fillColor = hotHoursColor === 'red' ? '#ff0055' : (hotHoursColor === 'white' ? '#fff' : '#888');

            hourlyCounts.forEach((count, hour) => {
                const barHeight = (count / maxCount) * (height - 20);
                const x = hour * (width / 24);
                const y = height - barHeight - 15;
                const opacity = 0.3 + (count / maxCount) * 0.7;

                svgContent += `
                    <rect x="${x + 1}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${fillColor}" fill-opacity="${opacity}" rx="2">
                        <title>${hour}h: ${count}x</title>
                    </rect>
                    <text x="${x + barWidth/2}" y="${height - 2}" font-size="9" fill="#888" text-anchor="middle">${hour}</text>
                    ${count > 0 ? `<text x="${x + barWidth/2}" y="${y - 2}" font-size="9" fill="#fff" text-anchor="middle">${count}</text>` : ''}
                `;
            });

            container.innerHTML = `<svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 100%; overflow: visible;">${svgContent}</svg>`;
        }

        function handleStrategyChange() {
            const toggle = document.getElementById('best_strategy_toggle');
            if (toggle && toggle.checked) toggle.checked = false;
            runSimulation();
            updatePrediction(fullBlazeData);
        }

        function toggleBestStrategy() {
            const toggle = document.getElementById('best_strategy_toggle');
            if (toggle && toggle.checked) {
                autoStrategyCounter = 0;
                findBestStrategy();
            }
        }

        function findBestStrategy(isAutoUpdate = false) {
            if (!fullBlazeData || fullBlazeData.length === 0) return;
            
            const persistenceToggle = document.getElementById('persistence_toggle');
            if (persistenceToggle && persistenceToggle.checked) {
                if (autoStrategyCounter > 0) {
                    if (isAutoUpdate) autoStrategyCounter--;
                    runSimulation(true);
                    return;
                }
            }

            const limit = analysisLimit || fullBlazeData.length;
            const dataSlice = fullBlazeData.slice(0, limit);
            const simData = [...dataSlice].reverse();
            const galeLevel = parseInt(document.getElementById('sim_gale_level').value);
            const analyzeWhite = document.getElementById('analyze_white_toggle')?.checked || false;
            const invertGale = document.getElementById('gale_invert_toggle')?.checked || false;
            
            const select = document.getElementById('sim_strategy');
            const previousStrategy = select.value;
            let bestStrategy = previousStrategy;
            let bestRate = 0.85; // Filtro: Apenas acima de 85%
            let bestBalance = -Infinity;

            for (let i = 0; i < select.options.length; i++) {
                const strategy = select.options[i].value;
                const result = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationLevel);
                
                const total = result.wins + result.losses;
                const rate = total > 0 ? (result.wins / total) : 0;

                if (rate > bestRate) {
                    bestRate = rate;
                    bestBalance = result.balance;
                    bestStrategy = strategy;
                } else if (rate === bestRate && rate > 0.85) {
                    if (result.balance > bestBalance) {
                        bestBalance = result.balance;
                        bestStrategy = strategy;
                    }
                }
            }

            select.value = bestStrategy;
            
            if (persistenceToggle && persistenceToggle.checked) {
                autoStrategyCounter = 4;
            }
            runSimulation(true);

            if (bestStrategy !== previousStrategy) {
                triggerStrategyChangeAlert();
            }
        }

        function updateStrategyLabels(simData, galeLevel, analyzeWhite, invertGale) {
            const select = document.getElementById('sim_strategy');
            if (!select) return;

            for (let i = 0; i < select.options.length; i++) {
                const option = select.options[i];
                if (!option.hasAttribute('data-original-text')) {
                    option.setAttribute('data-original-text', option.text);
                }
                
                const strategy = option.value;
                const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationLevel);
                const total = stats.wins + stats.losses;
                const rate = total > 0 ? (stats.wins / total) * 100 : 0;
                
                const originalText = option.getAttribute('data-original-text');
                option.text = `${originalText} (${rate.toFixed(0)}%)`;
            }
        }

        function runSimulation(skipBestCheck = false, isAutoUpdate = false) {
            if (!fullBlazeData || fullBlazeData.length === 0) return;
            
            if (!skipBestCheck) {
                const toggle = document.getElementById('best_strategy_toggle');
                if (toggle && toggle.checked) {
                    findBestStrategy(isAutoUpdate);
                    return;
                }
            }
            
            const limit = analysisLimit || fullBlazeData.length;
            const dataSlice = fullBlazeData.slice(0, limit);
            const simData = [...dataSlice].reverse();
            
            const strategy = document.getElementById('sim_strategy').value;
            const galeLevel = parseInt(document.getElementById('sim_gale_level').value);
            const analyzeWhite = document.getElementById('analyze_white_toggle')?.checked || false;
            const invertGale = document.getElementById('gale_invert_toggle')?.checked || false;
            
            updateStrategyLabels(simData, galeLevel, analyzeWhite, invertGale);

            const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationLevel);

            document.getElementById('sim_wins').innerText = stats.wins;
            document.getElementById('sim_losses').innerText = stats.losses;
            const total = stats.wins + stats.losses;
            document.getElementById('sim_rate').innerText = total > 0 ? ((stats.wins/total)*100).toFixed(1) + '%' : '0%';
            const balEl = document.getElementById('sim_balance');
            balEl.innerText = `R$ ${stats.balance}`;
            balEl.style.color = stats.balance >= 0 ? '#00ff88' : '#ff0055';
            document.getElementById('sim_max_win').innerText = stats.maxWinStreak;
            document.getElementById('sim_max_loss').innerText = stats.maxLossStreak;

            // Renderiza hist√≥rico visual de entradas
            renderEntryHistory(stats.entryHistory);

            // Atualiza tamb√©m o placar da Previs√£o de Padr√£o (Vinculado ao Backtest/Gale)
            document.getElementById('pred_wins').innerText = stats.wins;
            document.getElementById('pred_losses').innerText = stats.losses;
            const rateVal = total > 0 ? (stats.wins / total) * 100 : 0;
            document.getElementById('pred_rate').innerText = Math.round(rateVal) + '%';

            // Atualiza For√ßa do Sinal
            const strengthBar = document.getElementById('signal_strength_bar');
            const strengthText = document.getElementById('signal_strength_text');
            if (strengthBar && strengthText) {
                strengthBar.style.width = `${rateVal}%`;
                let label = 'BAIXA';
                let color = '#ff0055';
                if (rateVal >= 60) { label = 'EXCELENTE üöÄ'; color = '#00ff88'; }
                else if (rateVal >= 50) { label = 'ALTA üî•'; color = '#ccff00'; }
                else if (rateVal >= 40) { label = 'MODERADA ‚öñÔ∏è'; color = '#ff9800'; }
                else { label = 'FRACA ‚ö†Ô∏è'; color = '#ff0055'; }
                strengthBar.style.background = color;
                strengthBar.style.boxShadow = `0 0 10px ${color}`;
                strengthText.innerText = label;
                strengthText.style.color = color;
            }

            const strategySelect = document.getElementById('sim_strategy');
            const strategyName = strategySelect.options[strategySelect.selectedIndex].text;
            renderTrendChart(stats.balanceHistory, `üìà Tend√™ncia de Saldo (${strategyName})`);
            renderGaleDistributionChart(stats.winsDistribution);
            showGoldenHourStrategies();
        }

        function calculateSimulation(strategy, galeLevel, simData, analyzeWhite = false, invertGale = false, confirmLvl = 2) {
            if (!simData || simData.length === 0) return { wins: 0, losses: 0, balance: 0, balanceHistory: [0], winsDistribution: [0,0,0,0], maxWinStreak: 0, maxLossStreak: 0, entryHistory: [] };

            let wins = 0, losses = 0, balance = 0;
            const bet = 10; // Aposta fixa
            const balanceHistory = [0]; // Hist√≥rico para o gr√°fico
            let winsDistribution = [0, 0, 0, 0]; // G0, G1, G2, G3
            let currentWinStreak = 0, maxWinStreak = 0;
            let currentLossStreak = 0, maxLossStreak = 0;
            const entryHistory = [];
            let cooldownUntil = 0;

            // Helper interno para cores
            const getC = (r) => (r === 0) ? 'white' : ((r >= 1 && r <= 7) ? 'red' : 'black');

            // Helper para resolver cor (considerando toggle de branco)
            const getStratColor = (idx) => {
                if (idx < 0) return 'white';
                const r = simData[idx].roll;
                const c = getC(r);
                if (c === 'white' && analyzeWhite) {
                    let rC = 0, bC = 0;
                    for(let k=1; k<=5; k++) {
                        if(idx-k >= 0) {
                            const val = simData[idx-k].roll;
                            if(val >= 1 && val <= 7) rC++;
                            else if(val >= 8 && val <= 14) bC++;
                        }
                    }
                    return rC >= bC ? 'red' : 'black';
                }
                return c;
            };

            // Helper para verificar sequ√™ncia no hist√≥rico de simula√ß√£o
            const checkSimPattern = (idx, type, len) => {
                if (idx < len) return false; // Precisa de hist√≥rico anterior
                const first = getStratColor(idx - 1);
                if (first === 'white') return false;
                
                for (let k = 1; k < len; k++) {
                    const curr = getStratColor(idx - 1 - k);
                    if (type === 'follow' && curr !== first) return false;
                    if (type === 'alternating') {
                        const expected = (k % 2 === 0) ? first : (first === 'red' ? 'black' : 'red');
                        if (curr !== expected) return false;
                    }
                }
                return true;
            };

            for(let i=0; i<simData.length; i++) {
                const result = simData[i];

                let targetColor = null;
                let isCooldown = false;
                if (result.created_at) {
                    const currentTime = new Date(result.created_at).getTime();
                    if (currentTime < cooldownUntil) isCooldown = true;
                }

                if (!isCooldown) {
                    if (strategy === 'alternating') {
                        if (checkSimPattern(i, 'alternating', confirmLvl)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                        }
                    } else if (strategy === 'follow') {
                        if (checkSimPattern(i, 'follow', confirmLvl)) {
                            targetColor = getStratColor(i-1);
                        }
                    } else if (strategy === 'majority') {
                        if (i >= 5) {
                            let rCount = 0, bCount = 0;
                            for(let j=1; j<=5; j++) {
                                const c = getStratColor(i-j);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                            if (rCount >= bCount + 2) targetColor = 'red';
                            else if (bCount >= rCount + 2) targetColor = 'black';
                        }
                    } else if (strategy === 'ia_cores') {
                        // L√≥gica baseada na Previs√£o I.A. (Pontua√ß√£o Simplificada)
                        if (i >= 5) {
                            let redScore = 0, blackScore = 0;
                            const history = [];
                            for(let j=1; j<=5; j++) {
                                history.push(getStratColor(i-j));
                            }
                            // 1. Surf (3+)
                            if (history[0] === history[1] && history[1] === history[2]) {
                                if (history[0] === 'red') redScore += 2; else if (history[0] === 'black') blackScore += 2;
                            }
                            // 2. Xadrez (Altern√¢ncia)
                            if (history[0] !== history[1] && history[1] !== history[2]) {
                                if (history[0] === 'red') blackScore += 2; else if (history[0] === 'black') redScore += 2;
                            }
                            // 3. Maioria Recente
                            const rCount = history.filter(c => c === 'red').length;
                            const bCount = history.filter(c => c === 'black').length;
                            if (rCount > bCount) redScore += 1; else blackScore += 1;

                            if (redScore > blackScore) targetColor = 'red';
                            else if (blackScore > redScore) targetColor = 'black';
                        }
                    } else if (strategy === 'analise_cores') {
                        // L√≥gica H√≠brida (Surf se tend√™ncia, Xadrez se lateral)
                        if (checkSimPattern(i, 'follow', confirmLvl)) {
                            targetColor = getStratColor(i-1);
                        } else if (checkSimPattern(i, 'alternating', confirmLvl)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                            } else {
                                // Se houve branco recente, aposta na maioria dos √∫ltimos 5
                                if (i >= 5) {
                                    let rCount = 0, bCount = 0;
                                    for(let j=1; j<=5; j++) {
                                        const c = getStratColor(i-j);
                                        if (c === 'red') rCount++; else if (c === 'black') bCount++;
                                    }
                                    targetColor = rCount > bCount ? 'red' : 'black';
                                }
                            }
                    } else if (strategy === 'alignment') {
                        // Padr√£o Alinhamento: Segue a maioria dos √∫ltimos 20 (Tend√™ncia de M√©dio Prazo)
                        if (i >= 20) {
                            let rCount = 0, bCount = 0;
                            for(let j=1; j<=20; j++) {
                                const c = getStratColor(i-j);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                            if (rCount > bCount + 2) targetColor = 'red';
                            else if (bCount > rCount + 2) targetColor = 'black';
                        }
                    } else if (strategy === 'euler') {
                        // Onda de Euler: Tenta surfar na onda (Altern√¢ncia) ou na crista (Repeti√ß√£o)
                        if (checkSimPattern(i, 'alternating', confirmLvl)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                        } else if (checkSimPattern(i, 'follow', confirmLvl)) {
                            targetColor = getStratColor(i-1);
                        }
                    } else if (strategy === 'gauss') {
                        // Curva de Gauss: Maioria dos √∫ltimos 7 (Distribui√ß√£o Local)
                        if (i >= 7) {
                            let rCount = 0, bCount = 0;
                            for(let j=1; j<=7; j++) {
                                const c = getStratColor(i-j);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                            if (rCount >= bCount + 2) targetColor = 'red';
                            else if (bCount >= rCount + 2) targetColor = 'black';
                        }
                    } else if (strategy === 'fibonacci') {
                        // Fibonacci: Verifica posi√ß√µes 1, 2, 3, 5, 8, 13 atr√°s
                        const fibs = [1, 2, 3, 5, 8, 13];
                        let rCount = 0, bCount = 0;
                        fibs.forEach(fib => {
                            if (i >= fib) {
                                const c = getStratColor(i-fib);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                        });
                        if (rCount >= bCount + 1) targetColor = 'red';
                        else if (bCount >= rCount + 1) targetColor = 'black';
                    } else if (strategy === 'sniper') {
                        // Sniper: Revers√£o ap√≥s sequ√™ncia definida por confirmLvl
                        if (checkSimPattern(i, 'follow', confirmLvl)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                        }
                    }
                }

                if (targetColor) {
                    let currentBet = bet;
                    let totalLoss = 0;
                    let wonSequence = false;
                    let stepsTaken = 0;

                    // Loop para tentar ganhar na rodada atual ou nos gales subsequentes
                    for (let g = 0; g <= galeLevel; g++) {
                        // Verifica se temos dados futuros suficientes
                        if (i + g >= simData.length) {
                            // Sem dados para completar o gale, encerra como perda do acumulado
                            break;
                        }

                        const stepResult = simData[i + g];
                        const stepR = stepResult.roll;
                        let stepColor = 'white';
                        if (stepR >= 1 && stepR <= 7) stepColor = 'red';
                        else if (stepR >= 8 && stepR <= 14) stepColor = 'black';

                        // L√ìGICA DE GALE:
                        // Mant√©m a mesma cor da estrat√©gia original (targetColor) ap√≥s um Loss,
                        // garantindo a persist√™ncia da estrat√©gia durante o Gale.
                        let effectiveTarget = targetColor;
                        if (g > 0 && invertGale) {
                            effectiveTarget = (targetColor === 'red' ? 'black' : 'red');
                        }

                        // Verifica Vit√≥ria (Cor Alvo ou Branco Prote√ß√£o)
                        if (stepColor === effectiveTarget || stepColor === 'white') {
                            wonSequence = true;
                            stepsTaken = g;
                            break;
                        }

                        // Se perdeu essa etapa
                        totalLoss += currentBet;
                        currentBet *= 2; // Martingale: dobra a aposta
                        stepsTaken = g;
                    }

                    if (wonSequence) {
                        wins++;
                        balance += bet; // Recupera perdas e lucra a aposta base
                        if (stepsTaken < 4) winsDistribution[stepsTaken]++;
                        
                        currentWinStreak++;
                        currentLossStreak = 0;
                        if(currentWinStreak > maxWinStreak) maxWinStreak = currentWinStreak;
                        entryHistory.push('win');
                    } else {
                        losses++;
                        balance -= totalLoss;
                        
                        currentLossStreak++;
                        currentWinStreak = 0;
                        if(currentLossStreak > maxLossStreak) maxLossStreak = currentLossStreak;
                        entryHistory.push('loss');
                    }

                    // Cooldown: 2 min para Win, 3 min para Loss
                    const lastGameIndex = i + stepsTaken;
                    if (lastGameIndex < simData.length && simData[lastGameIndex].created_at) {
                        const lastGameTime = new Date(simData[lastGameIndex].created_at).getTime();
                        cooldownUntil = lastGameTime + (wonSequence ? 2 : 3) * 60 * 1000;
                    }
                    
                    // Avan√ßa o √≠ndice principal pelos passos de gale utilizados
                    i += stepsTaken;
                }
                balanceHistory.push(balance);
            }
            
            return { wins, losses, balance, balanceHistory, winsDistribution, maxWinStreak, maxLossStreak, entryHistory };
        }

        function analyzeSequences(data) {
            if (!data || data.length < 2) return;

            // 1. An√°lise P√≥s-N√∫mero (O que vem depois do √∫ltimo resultado)
            const lastRoll = data[0].roll;
            const lastColor = (lastRoll === 0) ? 'white' : ((lastRoll >= 1 && lastRoll <= 7) ? 'red' : 'black');
            const lastColorHex = (lastColor === 'red') ? '#ff0055' : ((lastColor === 'white') ? '#fff' : '#888');
            
            const displayEl = document.getElementById('last_number_display');
            if(displayEl) {
                displayEl.innerText = lastRoll;
                displayEl.style.color = lastColorHex;
                displayEl.style.textShadow = lastColor === 'white' ? '0 0 5px #fff' : 'none';
            }

            const followingCounts = Array(15).fill(0);
            let totalOccurrences = 0;

            // data[i] √© o gatilho. O resultado seguinte no tempo √© data[i-1] (pois a lista √© Newest->Oldest)
            for (let i = 1; i < data.length; i++) {
                if (data[i].roll === lastRoll) {
                    const nextResult = data[i-1];
                    followingCounts[nextResult.roll]++;
                    totalOccurrences++;
                }
            }

            if (totalOccurrences > 0) {
                const topFollowing = followingCounts
                    .map((count, num) => ({ num, count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3);
                
                let html = '<div style="display:flex; gap:15px; justify-content:center; width:100%;">';
                topFollowing.forEach(item => {
                    if (item.count > 0) {
                        const pct = Math.round((item.count / totalOccurrences) * 100);
                        const c = (item.num === 0) ? 'white' : ((item.num >= 1 && item.num <= 7) ? 'red' : 'black');
                        const bg = (c === 'red') ? '#ff0055' : ((c === 'white') ? '#fff' : '#333');
                        const fg = (c === 'white') ? '#000' : '#fff';
                        html += `
                            <div style="text-align:center;">
                                <div style="background:${bg}; color:${fg}; width:35px; height:35px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; margin:0 auto; border: 1px solid #444;">${item.num}</div>
                                <div style="font-size:0.75rem; color:#888; margin-top:4px;">${pct}%</div>
                            </div>
                        `;
                    }
                });
                html += '</div>';
                
                // Barra de distribui√ß√£o de cores p√≥s-n√∫mero
                let r=0, b=0, w=0;
                followingCounts.forEach((count, num) => {
                    if (num === 0) w += count;
                    else if (num >= 1 && num <= 7) r += count;
                    else b += count;
                });
                const total = r+b+w;
                html += `<div style="margin-top:15px; width:100%;"><div style="display:flex; height:6px; border-radius:3px; overflow:hidden; width:100%;">
                    <div style="width:${(r/total)*100}%; background:#ff0055;"></div>
                    <div style="width:${(w/total)*100}%; background:#fff;"></div>
                    <div style="width:${(b/total)*100}%; background:#333;"></div>
                </div>
                <div style="display:flex; justify-content:space-between; font-size:0.65rem; color:#aaa; margin-top:2px;">
                    <span>üî¥ ${Math.round((r/total)*100)}%</span>
                    <span>‚ö™ ${Math.round((w/total)*100)}%</span>
                    <span>‚ö´ ${Math.round((b/total)*100)}%</span>
                </div></div>`;

                document.getElementById('post_number_stats').innerHTML = html;
                document.getElementById('post_number_stats').style.flexDirection = 'column';
            } else {
                document.getElementById('post_number_stats').innerHTML = '<div style="text-align:center; color:#666;">Sem hist√≥rico suficiente para este n√∫mero.</div>';
            }

            // 2. Gatilhos do Branco (N√∫meros que antecedem o 0)
            const triggerCounts = Array(15).fill(0);
            let totalWhites = 0;

            // data[i] == 0. O n√∫mero anterior no tempo √© data[i+1].
            for (let i = 0; i < data.length - 1; i++) {
                if (data[i].roll === 0) {
                    const prevResult = data[i+1];
                    triggerCounts[prevResult.roll]++;
                    totalWhites++;
                }
            }

            if (totalWhites > 0) {
                const topTriggers = triggerCounts
                    .map((count, num) => ({ num, count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3);

                let html = '<div style="display:flex; gap:15px; justify-content:center;">';
                topTriggers.forEach(item => {
                    if (item.count > 0) {
                        const c = (item.num === 0) ? 'white' : ((item.num >= 1 && item.num <= 7) ? 'red' : 'black');
                        const bg = (c === 'red') ? '#ff0055' : ((c === 'white') ? '#fff' : '#333');
                        const fg = (c === 'white') ? '#000' : '#fff';
                        html += `
                            <div style="text-align:center;">
                                <div style="background:${bg}; color:${fg}; width:35px; height:35px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; margin:0 auto; border: 1px solid #444;">${item.num}</div>
                                <div style="font-size:0.75rem; color:#888; margin-top:4px;">${item.count}x</div>
                            </div>
                        `;
                    }
                });
                html += '</div>';
                document.getElementById('white_triggers_stats').innerHTML = html;
            } else {
                document.getElementById('white_triggers_stats').innerHTML = '<div style="text-align:center; color:#666;">Nenhum branco no hist√≥rico recente.</div>';
            }
        }

        function renderPieChart(data) {
            const container = document.getElementById('pie_chart_container');
            if (!container || !data || data.length === 0) return;

            let red = 0, black = 0, white = 0;
            data.forEach(game => {
                const r = game.roll;
                if (r === 0) white++;
                else if (r >= 1 && r <= 7) red++;
                else if (r >= 8 && r <= 14) black++;
            });
            const total = red + black + white;
            
            if (total === 0) return;

            const pRed = (red / total) * 100;
            const pBlack = (black / total) * 100;
            const pWhite = (white / total) * 100;

            const size = window.innerWidth <= 768 ? 120 : 160;
            const strokeWidth = 12;
            const radius = (size - strokeWidth) / 2;
            const circumference = 2 * Math.PI * radius;
            const cx = size / 2;
            const cy = size / 2;

            const dashRed = (pRed / 100) * circumference;
            const dashBlack = (pBlack / 100) * circumference;
            const dashWhite = (pWhite / 100) * circumference;

            const offsetRed = 0;
            const offsetBlack = -dashRed;
            const offsetWhite = -(dashRed + dashBlack);

            const svg = `
                <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="transform: rotate(-90deg);">
                    <circle cx="${cx}" cy="${cy}" r="${radius}" fill="none" stroke="#ff0055" stroke-width="${strokeWidth}" stroke-dasharray="${dashRed} ${circumference - dashRed}" stroke-dashoffset="${offsetRed}" style="transition: stroke-dasharray 0.5s ease-out; filter: drop-shadow(0 0 5px #ff0055);" />
                    <circle cx="${cx}" cy="${cy}" r="${radius}" fill="none" stroke="#333" stroke-width="${strokeWidth}" stroke-dasharray="${dashBlack} ${circumference - dashBlack}" stroke-dashoffset="${offsetBlack}" style="transition: stroke-dasharray 0.5s ease-out;" />
                    <circle cx="${cx}" cy="${cy}" r="${radius}" fill="none" stroke="#fff" stroke-width="${strokeWidth}" stroke-dasharray="${dashWhite} ${circumference - dashWhite}" stroke-dashoffset="${offsetWhite}" style="transition: stroke-dasharray 0.5s ease-out; filter: drop-shadow(0 0 8px #fff);" />
                </svg>
                <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 8px; font-size: 0.85rem;">
                    <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 10px; height: 10px; background: #ff0055; border-radius: 50%; box-shadow: 0 0 5px #ff0055;"></span> Vermelho: <b style="color: #ff0055;">${pRed.toFixed(1)}%</b></div>
                    <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 10px; height: 10px; background: #333; border: 1px solid #555; border-radius: 50%;"></span> Preto: <b style="color: #aaa;">${pBlack.toFixed(1)}%</b></div>
                    <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 10px; height: 10px; background: #fff; border-radius: 50%; box-shadow: 0 0 5px #fff;"></span> Branco: <b style="color: #fff;">${pWhite.toFixed(1)}%</b></div>
                </div>
            `;
            container.innerHTML = svg;
        }

        function renderPeriodComparison(data) {
            const containerRecent = document.getElementById('comp_recent_stats');
            const containerOld = document.getElementById('comp_old_stats');
            const msg = document.getElementById('comp_message');
            
            if (!containerRecent || !containerOld) return;

            if (!data || data.length < 50) {
                msg.innerText = "Dados insuficientes para compara√ß√£o (M√≠nimo 50 jogos na sele√ß√£o).";
                containerRecent.innerHTML = '';
                containerOld.innerHTML = '';
                return;
            }
            msg.innerText = "";

            // data is sorted Newest -> Oldest
            const recentData = data.slice(0, 50);
            const oldData = data.slice(-50); 

            const calculateStats = (subset) => {
                let r = 0, b = 0, w = 0;
                subset.forEach(g => {
                    if (g.roll === 0) w++;
                    else if (g.roll >= 1 && g.roll <= 7) r++;
                    else b++;
                });
                const total = subset.length;
                return {
                    rPct: ((r/total)*100).toFixed(1),
                    bPct: ((b/total)*100).toFixed(1),
                    wPct: ((w/total)*100).toFixed(1)
                };
            };

            const recentStats = calculateStats(recentData);
            const oldStats = calculateStats(oldData);

            const generateHTML = (stats) => `
                <div style="display: flex; flex-direction: column; gap: 6px; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between;"><span style="color: #ff0055;">Vermelho</span><span>${stats.rPct}%</span></div>
                    <div style="width: 100%; height: 4px; background: #333; border-radius: 2px;"><div style="width: ${stats.rPct}%; background: #ff0055; height: 100%; border-radius: 2px;"></div></div>
                    
                    <div style="display: flex; justify-content: space-between;"><span style="color: #aaa;">Preto</span><span>${stats.bPct}%</span></div>
                    <div style="width: 100%; height: 4px; background: #333; border-radius: 2px;"><div style="width: ${stats.bPct}%; background: #888; height: 100%; border-radius: 2px;"></div></div>

                    <div style="display: flex; justify-content: space-between;"><span style="color: #fff;">Branco</span><span>${stats.wPct}%</span></div>
                    <div style="width: 100%; height: 4px; background: #333; border-radius: 2px;"><div style="width: ${stats.wPct}%; background: #fff; height: 100%; border-radius: 2px;"></div></div>
                </div>
            `;

            containerRecent.innerHTML = generateHTML(recentStats);
            containerOld.innerHTML = generateHTML(oldStats);
        }

        function addToPattern(color) {
            customPattern.push(color);
            updatePatternDisplay();
            checkPattern();
        }

        function clearPattern() {
            customPattern = [];
            updatePatternDisplay();
            document.getElementById('pattern_alert_status').innerHTML = '';
        }

        function updatePatternDisplay() {
            const container = document.getElementById('custom_pattern_display');
            container.innerHTML = customPattern.map(c => {
                let colorClass = c === 'red' ? 'seq-red' : (c === 'black' ? 'seq-black' : 'seq-white');
                let label = c === 'red' ? 'V' : (c === 'black' ? 'P' : 'B');
                return `<div class="seq-badge ${colorClass}" style="width: 25px; height: 25px; font-size: 0.7rem;">${label}</div>`;
            }).join('');
        }

        function checkPattern() {
            if (customPattern.length === 0 || !fullBlazeData || fullBlazeData.length < customPattern.length) return;
            
            let match = true;
            for(let i=0; i<customPattern.length; i++) {
                const patternColor = customPattern[customPattern.length - 1 - i];
                const result = fullBlazeData[i];
                const r = result.roll;
                let resultColor = (r === 0) ? 'white' : ((r >= 1 && r <= 7) ? 'red' : 'black');
                
                if (patternColor !== resultColor) { match = false; break; }
            }
            
            const statusEl = document.getElementById('pattern_alert_status');
            statusEl.innerHTML = match ? '<span style="color: #00ff88; animation: pulse-text 1s infinite;">‚úÖ PADR√ÉO ENCONTRADO AGORA!</span>' : '<span style="color: #666;">Aguardando padr√£o...</span>';
        }

        function renderScatterChart(data) {
            const container = document.getElementById('scatter_chart_container');
            if (!container || !data || data.length === 0) return;

            const width = 800; 
            const height = 200 * chartScale;
            container.style.height = height + 'px';
            const padding = 30;

            let circles = '';
            
            data.forEach(game => {
                if (!game.created_at) return;
                const date = new Date(game.created_at);
                const minute = date.getMinutes();
                const seconds = date.getSeconds();
                const exactMinute = minute + (seconds / 60);
                const roll = game.roll;
                
                const x = padding + (exactMinute / 60) * (width - 2 * padding);
                const y = height - padding - (roll / 14) * (height - 2 * padding);
                
                let color = '#fff'; 
                if (roll >= 1 && roll <= 7) color = '#ff0055'; 
                else if (roll >= 8 && roll <= 14) color = '#888'; 
                
                circles += `<circle cx="${x}" cy="${y}" r="3" fill="${color}" opacity="0.7"><title>${minute}m ${seconds}s: ${roll}</title></circle>`;
            });

            const svg = `
                <svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 100%; overflow: visible; background: rgba(0,0,0,0.2); border-radius: 4px;">
                    <text x="${padding - 5}" y="${height - padding}" fill="#666" font-size="10" text-anchor="end">0</text>
                    <text x="${padding - 5}" y="${height/2}" fill="#666" font-size="10" text-anchor="end">7</text>
                    <text x="${padding - 5}" y="${padding + 5}" fill="#666" font-size="10" text-anchor="end">14</text>
                    ${[0, 10, 20, 30, 40, 50, 60].map(m => {
                        const xPos = padding + (m / 60) * (width - 2 * padding);
                        return `<text x="${xPos}" y="${height - 5}" fill="#666" font-size="10" text-anchor="middle">${m}m</text><line x1="${xPos}" y1="${padding}" x2="${xPos}" y2="${height - padding}" stroke="#333" stroke-dasharray="2" opacity="0.3" />`;
                    }).join('')}
                    ${circles}
                </svg>
            `;
            container.innerHTML = svg;
        }

        function updateTrendIndicator(points) {
            const indicator = document.getElementById('trend_strength_indicator');
            if (!indicator || !points || points.length === 0) return;

            // Analisa os √∫ltimos 20 pontos para determinar a tend√™ncia recente
            const lookback = Math.min(points.length, 20);
            const recentPoints = points.slice(-lookback);
            const startVal = recentPoints[0];
            const endVal = recentPoints[recentPoints.length - 1];
            const diff = endVal - startVal;

            let text = "LATERAL";
            let color = "#aaa";
            let bg = "rgba(255,255,255,0.1)";
            let icon = "‚û°Ô∏è";

            if (diff >= 5) { text = "ALTA FORTE"; color = "#00ff88"; bg = "rgba(0, 255, 136, 0.2)"; icon = "üöÄ"; }
            else if (diff >= 2) { text = "ALTA"; color = "#00ff88"; bg = "rgba(0, 255, 136, 0.1)"; icon = "‚ÜóÔ∏è"; }
            else if (diff <= -5) { text = "BAIXA FORTE"; color = "#ff0055"; bg = "rgba(255, 0, 85, 0.2)"; icon = "üìâ"; }
            else if (diff <= -2) { text = "BAIXA"; color = "#ff0055"; bg = "rgba(255, 0, 85, 0.1)"; icon = "‚ÜòÔ∏è"; }

            indicator.innerHTML = `${icon} ${text}`;
            indicator.style.color = color;
            indicator.style.background = bg;
            indicator.style.border = `1px solid ${color}`;
        }

        function renderGaleDistributionChart(counts) {
            const container = document.getElementById('gale_distribution_chart_container');
            if (!container) return;

            const labels = ['Win Direto', 'Gale 1', 'Gale 2', 'Gale 3'];
            const colors = ['#00ff88', '#ccff00', '#ff9800', '#ff0055'];
            const maxCount = Math.max(...counts, 1);
            const width = container.clientWidth || 500;
            const height = 120;
            const barWidth = (width / 4) - 20;
            const padding = 10;

            let svgContent = '';

            counts.forEach((count, index) => {
                if (index >= 4) return;
                
                const barHeight = (count / maxCount) * (height - 30);
                const x = padding + index * (width / 4) + 10;
                const y = height - barHeight - 20;
                
                // S√≥ desenha se houver contagem ou para manter o label
                const opacity = count > 0 ? 0.8 : 0.2;
                
                svgContent += `
                    <rect x="${x}" y="${y}" width="${barWidth}" height="${Math.max(barHeight, 2)}" fill="${colors[index]}" fill-opacity="${opacity}" rx="4">
                        <title>${labels[index]}: ${count}</title>
                    </rect>
                    <text x="${x + barWidth/2}" y="${height - 5}" font-size="10" fill="#aaa" text-anchor="middle">${labels[index]}</text>
                    ${count > 0 ? `<text x="${x + barWidth/2}" y="${y - 5}" font-size="11" fill="#fff" font-weight="bold" text-anchor="middle">${count}</text>` : ''}
                `;
            });

            container.innerHTML = `<svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 100%; overflow: visible;">${svgContent}</svg>`;
        }

        function renderEntryHistory(history) {
            const container = document.getElementById('entry_history_container');
            if (!container) return;
            
            const last10 = history ? history.slice(-10) : [];
            
            let html = '';
            if (last10.length === 0) {
                html = '<span style="color: #444; font-size: 0.8rem;">--</span>';
            } else {
                last10.forEach(result => {
                    const color = result === 'win' ? '#00ff88' : '#ff0055';
                    const shadow = result === 'win' ? '0 0 8px rgba(0, 255, 136, 0.6)' : '0 0 8px rgba(255, 0, 85, 0.6)';
                    html += `<div style="width: 10px; height: 10px; border-radius: 50%; background: ${color}; box-shadow: ${shadow}; margin: 2px;" title="${result.toUpperCase()}"></div>`;
                });
            }
            container.innerHTML = html;
        }

        function triggerStrategyChangeAlert() {
            const select = document.getElementById('sim_strategy');
            select.classList.remove('blink-alert');
            void select.offsetWidth; // Trigger reflow
            select.classList.add('blink-alert');
        }

        function showGoldenHourStrategies() {
            const container = document.getElementById('golden_hour_results');
            if (!container) return;
            
            if (!fullBlazeData || fullBlazeData.length === 0) return;

            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            
            const lastHourData = [];
            for (const game of fullBlazeData) {
                if (new Date(game.created_at) >= oneHourAgo) {
                    lastHourData.push(game);
                } else {
                    break; 
                }
            }

            if (lastHourData.length < 10) {
                container.innerHTML = '<div style="text-align: center; color: #aaa; padding: 10px;">Dados insuficientes na √∫ltima hora.</div>';
                return;
            }

            const simData = [...lastHourData].reverse();
            const galeLevel = parseInt(document.getElementById('sim_gale_level').value);
            const select = document.getElementById('sim_strategy');
            const analyzeWhite = document.getElementById('analyze_white_toggle')?.checked || false;
            const invertGale = document.getElementById('gale_invert_toggle')?.checked || false;
            
            let html = '<div style="background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 6px; padding: 10px;">';
            html += '<div style="color: #ffd700; font-weight: bold; margin-bottom: 8px; text-align: center;">üèÜ Estrat√©gias > 80% (√öltima Hora)</div>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">';

            let found = false;
            for (let i = 0; i < select.options.length; i++) {
                const strategy = select.options[i].value;
                const name = select.options[i].text;
                const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationLevel);
                const total = stats.wins + stats.losses;
                
                if (total > 0) {
                    const rate = (stats.wins / total) * 100;
                    if (rate >= 80) {
                        found = true;
                        html += `<div onclick="selectStrategy('${strategy}')" style="cursor: pointer; background: rgba(0,0,0,0.4); padding: 5px 10px; border-radius: 4px; border: 1px solid #ffd700; font-size: 0.8rem; color: #fff; transition: all 0.2s;">${name}: <span style="color: #00ff88; font-weight: bold;">${rate.toFixed(0)}%</span></div>`;
                    }
                }
            }

            if (!found) html += '<div style="color: #aaa; font-size: 0.8rem;">Nenhuma estrat√©gia atingiu 80% na √∫ltima hora.</div>';
            html += '</div></div>';
            container.innerHTML = html;
        }

        function selectStrategy(val) {
            const select = document.getElementById('sim_strategy');
            select.value = val;
            handleStrategyChange();
        }
    </script>
</body>
</html>