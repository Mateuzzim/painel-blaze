<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estat√≠sticas Num√©ricas</title>
    <style>
        /* Estilos Base (Mesmo padr√£o do ciclo_mercado.html) */
        :root {
            --bg-color: #050507; 
            --panel-bg: rgba(20, 25, 30, 0.6); 
            --text-color: #e0e6ed; 
            --border-color: rgba(0, 242, 255, 0.15); 
            --input-bg: #0a0a0c;
            --accent: #00f2ff; 
            --accent-glow: rgba(0, 242, 255, 0.6);
            --accent-blaze: #ff0055; 
            --accent-jonbet: #00ff9d; 
            --text-muted: #8899a6;
            --color-red: #ff0055; 
            --color-black: #111; 
            --color-white: #fff;
        }
        body { 
            background-color: var(--bg-color); 
            color: var(--text-color); 
            font-family: 'Segoe UI', 'Roboto', sans-serif; 
            margin: 0; 
            padding: 20px; 
            background-image: 
                radial-gradient(circle at 50% 0%, #1a2c38 0%, transparent 70%),
                linear-gradient(rgba(0, 242, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 242, 255, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
            background-attachment: fixed;
            overflow-x: hidden;
        }
        /* Scrollbar Futurista */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        ::-webkit-scrollbar-thumb { background: rgba(0, 242, 255, 0.1); border-radius: 4px; border: 1px solid rgba(0, 242, 255, 0.2); }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); box-shadow: 0 0 15px var(--accent-glow); }

        .main-container { max-width: 98%; margin: 0 auto; }
        
        .layout-panel { 
            background: transparent; 
            border: none; 
            padding: 10px; 
        }
        
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
        h1 { margin: 0; }
        .cortex-text-anim { background: linear-gradient(90deg, var(--accent), var(--accent-blaze), #ff9800, var(--accent)); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: cortex-gradient 3s linear infinite; font-weight: bold; text-shadow: 0 0 10px rgba(0, 242, 255, 0.3); }
        @keyframes cortex-gradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        
        .btn-back { display: inline-flex; align-items: center; gap: 5px; padding: 8px 15px; background: rgba(0, 242, 255, 0.05); color: var(--accent); text-decoration: none; border-radius: 4px; margin-bottom: 15px; font-size: 0.9rem; border: 1px solid var(--border-color); transition: all 0.3s; text-transform: uppercase; letter-spacing: 1px; }
        .btn-back:hover { background: rgba(0, 242, 255, 0.15); border-color: var(--accent); color: #fff; box-shadow: 0 0 15px var(--accent-glow); }
        
        /* Switch Toggle */
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 2px; border: 1px solid #555; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); border-color: var(--accent); box-shadow: 0 0 10px var(--accent-glow); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Estilos Espec√≠ficos da An√°lise Num√©rica */
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px; }
        
        /* Futuristic Card Design */
        .stat-card { 
            background: var(--panel-bg); 
            backdrop-filter: blur(10px); 
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color); 
            border-radius: 4px; 
            padding: 20px; 
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: cardEntry 0.6s ease-out backwards;
        }
        /* Staggered Animation */
        .stats-grid > div:nth-child(1) { animation-delay: 0.05s; }
        .stats-grid > div:nth-child(2) { animation-delay: 0.1s; }
        .stats-grid > div:nth-child(3) { animation-delay: 0.15s; }
        .stats-grid > div:nth-child(4) { animation-delay: 0.2s; }
        .stats-grid > div:nth-child(5) { animation-delay: 0.25s; }
        .stats-grid > div:nth-child(6) { animation-delay: 0.3s; }
        .stats-grid > div:nth-child(7) { animation-delay: 0.35s; }

        @keyframes cardEntry {
            from { opacity: 0; transform: translateY(30px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .stat-card:hover { 
            transform: translateY(-5px) scale(1.02); 
            border-color: var(--accent); 
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.2), inset 0 0 20px rgba(0, 242, 255, 0.05); 
            z-index: 10; 
        }

        /* Tech Corners */
        .stat-card::after { content: ''; position: absolute; top: -1px; right: -1px; width: 10px; height: 10px; border-top: 2px solid var(--accent); border-right: 2px solid var(--accent); transition: all 0.3s; opacity: 0.5; pointer-events: none; }
        .stat-card::before { content: ''; position: absolute; bottom: -1px; left: -1px; width: 10px; height: 10px; border-bottom: 2px solid var(--accent); border-left: 2px solid var(--accent); transition: all 0.3s; opacity: 0.5; pointer-events: none; }
        .stat-card:hover::after, .stat-card:hover::before { width: 100%; height: 100%; opacity: 1; border-color: rgba(0, 242, 255, 0.1); }

        .stat-title { 
            font-family: 'Segoe UI', sans-serif; 
            font-size: 0.8rem; 
            letter-spacing: 1.5px; 
            color: var(--accent); 
            text-transform: uppercase; 
            margin-bottom: 15px; 
            border-bottom: 1px solid rgba(0, 242, 255, 0.2); 
            padding-bottom: 8px; 
            text-shadow: 0 0 5px rgba(0, 242, 255, 0.4);
        }
        
        .color-bar-container { display: flex; height: 25px; border-radius: 4px; overflow: hidden; margin-top: 10px; }
        .color-bar { display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: bold; color: #fff; transition: width 0.5s; text-shadow: 0 0 2px rgba(0,0,0,0.8); }
        .bg-red { background: var(--color-red); }
        .bg-black { background: #222; border-right: 1px solid #444; }
        .bg-white { background: #fff; color: #000; text-shadow: none; }

        .numbers-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 10px; }
        .number-box { 
            background: rgba(0,0,0,0.4); border: 1px solid #333; border-radius: 2px; padding: 10px 5px; 
            text-align: center; position: relative; transition: transform 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }
        .number-box:hover { transform: translateY(-3px); border-color: var(--accent); background: rgba(0, 242, 255, 0.1); }
        .number-box.hot { border-color: var(--accent-jonbet); box-shadow: 0 0 10px rgba(0,255,136,0.2); }
        .number-box.cold { border-color: #ff0055; opacity: 0.7; }
        
        .n-val { font-size: 1.4rem; font-weight: bold; margin-bottom: 5px; }
        .n-red { color: var(--color-red); }
        .n-black { color: #8899a6; }
        .n-white { color: #fff; text-shadow: 0 0 5px #fff; }
        
        .n-count { font-size: 0.75rem; color: var(--text-muted); }
        .n-bar { height: 3px; background: #222; margin-top: 5px; border-radius: 2px; overflow: hidden; }
        .n-fill { height: 100%; background: var(--accent); box-shadow: 0 0 5px var(--accent); }

        .hot-cold-row { display: flex; gap: 10px; margin-top: 5px; }
        .badge { padding: 4px 8px; border-radius: 2px; font-size: 0.8rem; font-weight: bold; color: #fff; clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%); }
        .badge-hot { background: rgba(0, 255, 136, 0.15); color: #00ff88; border: 1px solid rgba(0, 255, 136, 0.3); }
        .badge-cold { background: rgba(255, 0, 85, 0.2); color: #ff0055; border: 1px solid rgba(255, 0, 85, 0.3); }

        /* Estilos para Sequ√™ncia e Previs√£o */
        .seq-badge { width: 30px; height: 30px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.8rem; border: 1px solid #333; margin-right: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .seq-red { background: var(--color-red); border-color: #ff0055; color: #fff; }
        .seq-black { background: #222; border-color: #444; color: #fff; }
        .seq-white { background: #fff; border-color: #fff; color: #000; }

        /* Estilo para a bolha de previs√£o */
        .prediction-bubble {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, #ff8a8a, #ff0055);
            border-radius: 50%;
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 0 10px rgba(255, 255, 255, 0.5),
                0 5px 15px rgba(255, 0, 85, 0.4),
                0 0 30px rgba(255, 0, 85, 0.3);
            margin: 0 auto;
        }
        .prediction-bubble.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: 
                inset 0 0 10px rgba(255, 255, 255, 0.2),
                0 5px 15px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(255, 255, 255, 0.1);
        }
        .prediction-bubble::before {
            content: '';
            position: absolute;
            top: 10%; left: 20%; width: 15px; height: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            filter: blur(2px);
        }
        .prediction-bubble-text { font-size: 1.5rem; font-weight: bold; color: #fff; text-shadow: 0 0 5px rgba(0,0,0,0.5); }

        @keyframes blink-success {
            0%, 100% { border-color: #444; box-shadow: none; }
            50% { border-color: #00ff88; box-shadow: 0 0 15px rgba(0, 255, 136, 0.6); }
        }
        .blink-alert {
            animation: blink-success 0.5s ease-in-out 4;
        }
        @keyframes blink-save-anim { 0%, 100% { border-color: #00ff88; color: #00ff88; box-shadow: none; } 50% { border-color: #ff9800; color: #ff9800; box-shadow: 0 0 15px rgba(255, 152, 0, 0.4); } }
        .blink-save {
            animation: blink-save-anim 1.5s infinite ease-in-out;
        }
        @keyframes pulse-green-anim { 
            0%, 100% { transform: scale(1); text-shadow: 0 0 5px rgba(0, 255, 136, 0.5); } 
            50% { transform: scale(1.15); text-shadow: 0 0 20px rgba(0, 255, 136, 1); } 
        }
        .pulse-green {
            animation: pulse-green-anim 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        /* Bot√£o Flutuante Salvar */
        .fab-save {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(20, 25, 30, 0.9);
            border: 2px solid #00ff88;
            border-radius: 50%;
            color: #00ff88;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            z-index: 9999;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(5px);
        }
        .fab-save:hover {
            transform: scale(1.1) rotate(15deg);
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
        }
        .fab-save:active {
            transform: scale(0.95);
        }
        @keyframes blink-fab-anim { 
            0%, 100% { border-color: #00ff88; color: #00ff88; box-shadow: 0 0 15px rgba(0,0,0,0.5); } 
            50% { border-color: #ff9800; color: #ff9800; box-shadow: 0 0 25px rgba(255, 152, 0, 0.6); } 
        }
        .fab-save.blink-save {
            animation: blink-fab-anim 1.5s infinite ease-in-out;
        }
    </style>
    <style>
        /* Estilos para o filtro de giros */
        .filter-buttons { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }
        .filter-btn {
            background: rgba(255,255,255,0.05); border: 1px solid #333; color: #aaa;
            padding: 8px 20px; border-radius: 20px; cursor: pointer;
            font-size: 0.9rem; transition: all 0.3s;
        }
        .filter-btn:hover { 
            background: rgba(0, 210, 255, 0.1); color: #00d2ff; border-color: #00d2ff;
        }
        .filter-btn:active { transform: translateY(0) scale(0.98); }
        .filter-btn.active {
            background: #00d2ff; color: #000; border-color: #00d2ff; 
        }

        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 768px) {
            body { padding: 5px; }
            .layout-panel { padding: 10px; }
            .stats-grid {
                /* Opcional: Descomente a linha abaixo para for√ßar 1 coluna em telas muito pequenas */
                grid-template-columns: 1fr;
            }
            .numbers-grid {
                grid-template-columns: repeat(auto-fit, minmax(45px, 1fr));
                gap: 5px;
            }
            .number-box { padding: 5px; }
            .n-val { font-size: 1rem; }
            .hot-cold-row {
                flex-wrap: wrap;
                justify-content: center;
            }
            #pie_chart_container {
                flex-direction: column;
                gap: 15px;
                padding: 10px;
            }
            #pie_chart_container > div {
                margin-left: 0 !important; /* Remove a margem da legenda no mobile */
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="layout-panel">
            <div class="main-header" style="display: none;">
                <h1 class="cortex-text-anim">ESTAT√çSTICAS NUM√âRICAS</h1>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 0.8rem; color: #aaa;">Auto-Atualizar:</span>
                    <label class="switch" style="transform: scale(0.8);">
                        <input type="checkbox" id="autoUpdateToggle" checked onchange="toggleAutoUpdate()">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <a href="index.html" class="btn-back" style="display: none;">‚Üê Voltar ao Painel</a>

            <!-- Filtro de Giros -->
            <div class="control-group" style="margin-bottom: 20px; text-align: center; display: none;">
                <div class="filter-buttons">
                    <button class="filter-btn" onclick="setAnalysisLimit(50)">50</button>
                    <button class="filter-btn active" onclick="setAnalysisLimit(100)">100</button>
                    <button class="filter-btn" onclick="setAnalysisLimit(500)">500</button>
                    <button class="filter-btn" onclick="setAnalysisLimit(null)">Todos</button>
                </div>
            </div>

            <div id="loading" style="text-align: center; color: #888; padding: 20px;">Carregando dados...</div>
            
            <div id="content" style="display: none;">
                <!-- Grupo 2: Tend√™ncias e Previs√£o -->
                <div class="stats-grid">
                    <!-- Previs√£o de Padr√£o -->
                    <div class="stat-card">
                        <div class="stat-title" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>üîÆ Previs√£o de Padr√£o</span>
                            <div style="display: flex; align-items: center; gap: 5px; font-size: 0.7rem; text-transform: none;">
                                <span id="pred_active_source" style="color: #00d2ff; font-weight: bold;">Melhor: Calculando...</span>
                            </div>
                        </div>

                        <!-- Controle de Meta de Assertividade -->
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <span style="font-size: 0.8rem; color: #aaa;">Meta:</span>
                            <button onclick="changePredictionThreshold(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                            <span id="prediction_threshold_display" style="font-weight: bold; color: #fff; min-width: 30px; text-align: center;">95%</span>
                            <button onclick="changePredictionThreshold(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                        </div>

                        <!-- Placar Win/Loss -->
                        <div style="display: flex; justify-content: space-around; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 6px; margin-bottom: 15px; border: 1px solid #333;">
                            <div style="text-align: center;">
                                <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 2px;">WIN</div>
                                <div id="pred_wins" style="font-size: 1.1rem; font-weight: bold; color: #00ff88;">0</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 2px;">LOSS</div>
                                <div id="pred_losses" style="font-size: 1.1rem; font-weight: bold; color: #ff0055;">0</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 2px;">ASSERTIVIDADE</div>
                                <div id="pred_rate" style="font-size: 1.1rem; font-weight: bold; color: #fff;">0%</div>
                            </div>
                        </div>

                                                                                                                                                                                                                                            <!-- Hist√≥rico Visual de Entradas -->
                        <div style="margin-bottom: 15px;">
                            <div style="font-size: 0.75rem; color: #aaa; margin-bottom: 5px; text-align: center;">√öltimas 20 Entradas</div>
                            <div id="entry_history_container" style="display: flex; justify-content: center; gap: 6px; flex-wrap: wrap; min-height: 14px;"></div>
                        </div>

                        <!-- Indicador de For√ßa do Sinal -->
                        <div style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: #aaa; margin-bottom: 4px;">
                                <span>For√ßa do Sinal</span>
                                <span id="signal_strength_text" style="font-weight: bold;">--</span>
                            </div>
                            <div style="height: 6px; background: #222; border-radius: 3px; overflow: hidden; border: 1px solid #333;">
                                <div id="signal_strength_bar" style="width: 0%; height: 100%; background: #444; transition: all 0.5s ease;"></div>
                            </div>
                        </div>

                        <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 15px; flex-wrap: wrap; gap: 10px;">
                            <div id="last_5_sequence" style="display: flex;"></div>
                            <div style="text-align: left; flex: 1;">
                                <div style="font-size: 0.8rem; color: #aaa;">üö® ALERTA DE ENTRADA:</div>
                                <div id="prediction_result" style="font-size: 1.1rem; font-weight: bold; color: #fff;">Aguardando...</div>
                            </div>
                        </div>
                    </div>
                    <!-- Gr√°fico de Tend√™ncia -->
                    <div class="stat-card">
                        <div class="stat-title" style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="trend_chart_title">üìà Tend√™ncia de Saldo (Vermelho vs Preto - √öltimos 100)</span>
                            <span id="trend_strength_indicator" style="font-size: 0.7rem; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.1);">Calculando...</span>
                        </div>
                        <div id="trend_chart_container" style="width: 100%; height: 120px; margin-top: 10px;"></div>
                        <div id="trend_summary_container" style="margin-top: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px 5px; font-size: 0.8rem; text-align: center; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px;">
                            <div>
                                <div style="color: #aaa; font-size: 0.7rem; text-transform: uppercase;">Pico</div>
                                <div id="trend_peak" style="color: #00ff88; font-weight: bold; font-size: 1rem;">R$ 0</div>
                            </div>
                            <div>
                                <div style="color: #aaa; font-size: 0.7rem; text-transform: uppercase;">Vale</div>
                                <div id="trend_trough" style="color: #ff0055; font-weight: bold; font-size: 1rem;">R$ 0</div>
                            </div>
                            <div>
                                <div style="color: #aaa; font-size: 0.7rem; text-transform: uppercase;">Entradas</div>
                                <div id="trend_entries" style="color: #fff; font-weight: bold; font-size: 1rem;">0</div>
                            </div>
                            <div>
                                <div style="color: #aaa; font-size: 0.7rem; text-transform: uppercase;">Saldo Final</div>
                                <div id="trend_final_balance" style="color: #00d2ff; font-weight: bold; font-size: 1rem;">R$ 0</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Simula√ß√£o de Estrat√©gia (Movido para c√° - Linha √önica) -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-title">üéÆ Simula√ß√£o 1 (Filtro Din√¢mico)</div>
                        <div style="display: flex; gap: 10px; margin: 10px 0 15px 0; align-items: center; justify-content: center; flex-wrap: wrap;">
                            <select id="sim_strategy" onchange="handleStrategyChange()" style="padding: 5px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px;">
                                <option value="alternating">Alternar (Xadrez)</option>
                                <option value="follow">Seguir a Cor (Surf)</option>
                                <option value="majority">Maioria (√öltimos 5)</option>
                                <option value="ia_cores">IA Cores (Preditiva)</option>
                                <option value="analise_cores">An√°lise Cores (H√≠brida)</option>
                                <option value="alignment">Padr√£o Alinhamento (Tend√™ncia 20)</option>
                                <option value="euler">Onda de Euler (C√≠clico)</option>
                                <option value="gauss">Curva de Gauss (√öltimos 7)</option>
                                <option value="fibonacci">Fibonacci (Retra√ß√£o)</option>
                                <option value="sniper">Sniper (Alta Precis√£o)</option>
                                <option value="olho_de_deus">Olho de Deus (100 Pedras)</option>
                                <option value="ciclo_lunar">Ciclo Lunar (15 Pedras)</option>
                                <option value="espelho_magico">Espelho M√°gico (10 Pedras)</option>
                                <option value="fibonacci_sequence">Sequ√™ncia de Fibonacci</option>
                                <option value="mare_vermelha">Mar√© Vermelha</option>
                                <option value="vortex_numerico">Vortex Num√©rico (Soma 4)</option>
                                <option value="reversao_quantica">Revers√£o Qu√¢ntica (Frio 25)</option>
                                <option value="pulso_eletromagnetico">Pulso Eletromagn√©tico (Tempo)</option>
                                <option value="cacador_de_zeros">Ca√ßador de Zeros (Branco)</option>
                                <option value="sombra_do_branco">Sombra do Branco (Ciclo)</option>
                                <option value="convergencia_numerica">Converg√™ncia Num√©rica (Branco)</option>
                                <option value="horario_do_branco">Hor√°rio do Branco (Minuto 7)</option>
                            </select>
                            <button class="filter-btn" onclick="runSimulation()" style="background: #00d2ff; color: #000; border: none; padding: 6px 15px;">Recalcular</button>
                        </div>
                        <div style="display: flex; gap: 8px; margin-bottom: 10px; align-items: center; justify-content: center; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Auto Melhor:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="best_strategy_toggle" checked onchange="toggleBestStrategy()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Gale 1:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="gale_active_toggle" checked onchange="runSimulation()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Analisar Branco:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="analyze_white_toggle" checked onchange="runSimulation()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Manter:</span>
                                <button onclick="changePersistence(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="persistence_display" style="font-weight: bold; color: #00d2ff; min-width: 15px; text-align: center;">4</span>
                                <button onclick="changePersistence(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Gale Invertido:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="gale_invert_toggle" onchange="runSimulation()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Pausa Win:</span>
                                <button onclick="changePauseWin(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="pause_win_display" style="font-weight: bold; color: #00d2ff; min-width: 15px; text-align: center;">0</span>
                                <button onclick="changePauseWin(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Pausa Loss:</span>
                                <button onclick="changePauseLoss(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="pause_loss_display" style="font-weight: bold; color: #ff0055; min-width: 15px; text-align: center;">0</span>
                                <button onclick="changePauseLoss(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Tempo Loss:</span>
                                <button onclick="changeTimePauseLoss(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="time_pause_loss_display" style="font-weight: bold; color: #ff0055; min-width: 15px; text-align: center;">3m</span>
                                <button onclick="changeTimePauseLoss(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Confirma√ß√£o:</span>
                                <button onclick="changeConfirmation(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="confirmation_display" style="font-weight: bold; color: #00d2ff; min-width: 15px; text-align: center;">2</span>
                                <button onclick="changeConfirmation(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                        </div>
                        <div id="golden_hour_results" style="margin-top: 10px;"></div>
                        <div style="display: flex; justify-content: space-around; text-align: center; margin-top: 15px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                            <div><div style="font-size: 0.8rem; color: #aaa;">Wins</div><div id="sim_wins" style="font-size: 1.2rem; font-weight: bold; color: #00ff88;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Losses</div><div id="sim_losses" style="font-size: 1.2rem; font-weight: bold; color: #ff0055;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Assertividade</div><div id="sim_rate" style="font-size: 1.2rem; font-weight: bold; color: #fff;">0%</div></div>
                            <div>
                                <div style="font-size: 0.8rem; color: #aaa;">Saldo (R$10)</div>
                                <div id="sim_balance" style="font-size: 1.2rem; font-weight: bold; color: #00d2ff;">R$ 0</div>
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-around; text-align: center; margin-top: 5px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                            <div><div style="font-size: 0.8rem; color: #aaa;">Maior Seq. Vit√≥rias</div><div id="sim_max_win" style="font-size: 1.2rem; font-weight: bold; color: #00ff88;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Maior Seq. Derrotas</div><div id="sim_max_loss" style="font-size: 1.2rem; font-weight: bold; color: #ff0055;">0</div></div>
                        </div>
                        <div id="gale_distribution_chart_container" style="width: 100%; height: 120px; margin-top: 15px;"></div>
                        <div style="font-size: 0.7rem; color: #666; text-align: center; margin-top: 5px;">*Simula√ß√£o baseada nos dados filtrados acima.</div>
                    </div>

                    <!-- Simula√ß√£o Secund√°ria (Fixa 100) -->
                    <div class="stat-card">
                        <div class="stat-title">üéÆ Simula√ß√£o 2 (Fixa 100 Rodadas)</div>
                        <div style="display: flex; gap: 10px; margin: 10px 0 15px 0; align-items: center; justify-content: center; flex-wrap: wrap;">
                            <select id="sim2_strategy" onchange="handleStrategyChange2()" style="padding: 5px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px;">
                                <option value="">-- Selecione --</option>
                                <option value="olho_de_deus_90">Olho de Deus (90)</option>
                                <option value="mhi_minoria">MHI (Minoria 3)</option>
                                <option value="quebra_2x2">Quebra de Padr√£o 2x2</option>
                                <option value="eco_passado">Eco do Passado (P√≥s-N√∫mero)</option>
                                <option value="padrao_espelhado">Padr√£o Espelhado (3)</option>
                                <option value="mare_minutos">Mar√© de Minutos</option>
                                <option value="sincronia_horaria">Sincronia Hor√°ria</option>
                                <option value="inercia_newton">In√©rcia (Tend√™ncia 6)</option>
                                <option value="reacao_newton">Rea√ß√£o (3¬™ Lei)</option>
                                <option value="entropia_caos">Entropia (Quebra Xadrez)</option>
                                <option value="soma_dragao">Soma do Drag√£o (Chin√™s)</option>
                                <option value="codigo_muralha">C√≥digo da Muralha (Chin√™s)</option>
                                <option value="lotus_dourada">L√≥tus Dourada (Chin√™s)</option>
                                <option value="yin_yang">Yin Yang (Hist√≥rico 100)</option>
                                <option value="caos_ordem">Caos e Ordem (Alterna 10)</option>
                                <option value="guardiao_real">Guardi√£o Real (Revers√£o 8)</option>
                                <option value="estrela_cadente">Estrela Cadente (Quebra Xadrez 6)</option>
                                <option value="horizonte_eventos">Horizonte de Eventos (Soma Extrema)</option>
                                <option value="anomalia_temporal_b">Anomalia Temporal (Branco)</option>
                                <option value="eco_numerico_b">Eco Num√©rico (Branco)</option>
                                <option value="vacuo_de_cor_b">V√°cuo de Cor (Branco)</option>
                                <option value="sincronicidade_primos_b">Sincronicidade (Primos Branco)</option>
                            </select>
                            <button class="filter-btn" onclick="runSimulation2()" style="background: #00d2ff; color: #000; border: none; padding: 6px 15px;">Recalcular</button>
                        </div>
                        <div style="display: flex; gap: 8px; margin-bottom: 10px; align-items: center; justify-content: center; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Auto Melhor:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="sim2_best_strategy_toggle" checked onchange="toggleBestStrategy2()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Gale 1:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="sim2_gale_active" checked onchange="runSimulation2()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Analisar Branco:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="sim2_analyze_white" checked onchange="runSimulation2()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Manter:</span>
                                <button onclick="changePersistence2(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="sim2_persistence_display" style="font-weight: bold; color: #00d2ff; min-width: 15px; text-align: center;">4</span>
                                <button onclick="changePersistence2(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Gale Invertido:</span>
                                <label class="switch" style="transform: scale(0.7); margin: 0;">
                                    <input type="checkbox" id="sim2_gale_invert_toggle" onchange="runSimulation2()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Pausa Win:</span>
                                <button onclick="changePauseWin2(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="sim2_pause_win_display" style="font-weight: bold; color: #00d2ff; min-width: 15px; text-align: center;">0</span>
                                <button onclick="changePauseWin2(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Pausa Loss:</span>
                                <button onclick="changePauseLoss2(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="sim2_pause_loss_display" style="font-weight: bold; color: #ff0055; min-width: 15px; text-align: center;">0</span>
                                <button onclick="changePauseLoss2(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Tempo Loss:</span>
                                <button onclick="changeTimePauseLoss2(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="sim2_time_pause_loss_display" style="font-weight: bold; color: #ff0055; min-width: 15px; text-align: center;">3m</span>
                                <button onclick="changeTimePauseLoss2(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; border: 1px solid #444;">
                                <span style="font-size: 0.8rem; color: #aaa;">Confirma√ß√£o:</span>
                                <button onclick="changeConfirmation2(-1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">-</button>
                                <span id="sim2_confirmation_display" style="font-weight: bold; color: #00d2ff; min-width: 15px; text-align: center;">2</span>
                                <button onclick="changeConfirmation2(1)" style="background: transparent; border: 1px solid #666; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                        </div>
                        <div id="sim2_golden_hour_results" style="margin-top: 10px;"></div>
                        <div style="display: flex; justify-content: space-around; text-align: center; margin-top: 15px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                            <div><div style="font-size: 0.8rem; color: #aaa;">Wins</div><div id="sim2_wins" style="font-size: 1.2rem; font-weight: bold; color: #00ff88;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Losses</div><div id="sim2_losses" style="font-size: 1.2rem; font-weight: bold; color: #ff0055;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Assertividade</div><div id="sim2_rate" style="font-size: 1.2rem; font-weight: bold; color: #fff;">0%</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Saldo</div><div id="sim2_balance" style="font-size: 1.2rem; font-weight: bold; color: #00d2ff;">R$ 0</div></div>
                        </div>
                        <div style="display: flex; justify-content: space-around; text-align: center; margin-top: 5px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                            <div><div style="font-size: 0.8rem; color: #aaa;">Maior Seq. Vit√≥rias</div><div id="sim2_max_win" style="font-size: 1.2rem; font-weight: bold; color: #00ff88;">0</div></div>
                            <div><div style="font-size: 0.8rem; color: #aaa;">Maior Seq. Derrotas</div><div id="sim2_max_loss" style="font-size: 1.2rem; font-weight: bold; color: #ff0055;">0</div></div>
                        </div>
                        <div id="sim2_gale_distribution_chart_container" style="width: 100%; height: 120px; margin-top: 15px;"></div>
                        <div style="font-size: 0.7rem; color: #666; text-align: center; margin-top: 5px;">*Simula√ß√£o fixa nas √∫ltimas 100 rodadas.</div>
                    </div>
                </div>

                <!-- Grupo 3: Estat√≠sticas B√°sicas -->
                <div class="stats-grid">
                    <!-- Salvar Momento -->
                    <div class="stat-card" style="display: flex; flex-direction: column; justify-content: center; align-items: center;">
                        <div class="stat-title">üíæ Sistema</div>
                        <button id="btn_save_moment" class="filter-btn" onclick="saveMoment()" style="border-color: #00ff88; color: #00ff88; width: 100%; margin-top: 10px;">Salvar Momento</button>
                        <div id="save_status" style="margin-top: 10px; font-size: 0.8rem; color: #aaa; min-height: 20px; text-align: center;"></div>
                    </div>
                    <!-- Hot Numbers -->
                    <div class="stat-card">
                        <div class="stat-title">üî• N√∫meros Quentes (Top 3)</div>
                        <div id="hot_numbers" class="hot-cold-row"></div>
                    </div>
                    <!-- Cold Numbers -->
                    <div class="stat-card">
                        <div class="stat-title">‚ùÑÔ∏è N√∫meros Frios (Top 3)</div>
                        <div id="cold_numbers" class="hot-cold-row"></div>
                    </div>
                    <!-- Par/√çmpar -->
                    <div class="stat-card">
                        <div class="stat-title">‚öñÔ∏è Par vs √çmpar (Sem o 0)</div>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
                            <div style="flex: 1; text-align: center;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #00d2ff;" id="even_pct">0%</div>
                                <div style="font-size: 0.7rem; color: #666;">PARES</div>
                            </div>
                            <div style="width: 1px; height: 30px; background: #333;"></div>
                            <div style="flex: 1; text-align: center;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #ff9800;" id="odd_pct">0%</div>
                                <div style="font-size: 0.7rem; color: #666;">√çMPARES</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Grupo 4: An√°lise de Sequ√™ncia -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-title">üîç Ap√≥s o <span id="last_number_display" style="color:#fff; font-weight:bold;">--</span> vem...</div>
                        <div id="post_number_stats" style="font-size: 0.9rem; color: #ccc; margin-top: 10px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
                            Aguardando dados...
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">‚ö™ Gatilhos do Branco (Top 3)</div>
                        <div id="white_triggers_stats" style="font-size: 0.9rem; color: #ccc; margin-top: 10px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
                            Aguardando dados...
                        </div>
                    </div>
                </div>

                <!-- Grupo 5: An√°lise Profunda -->
                <div class="stats-grid">
                    <!-- Compara√ß√£o de Per√≠odos -->
                    <div class="stat-card">
                        <div class="stat-title">‚öñÔ∏è Compara√ß√£o de Per√≠odos (Extremos da Sele√ß√£o)</div>
                        <div style="display: flex; gap: 20px; justify-content: space-around; flex-wrap: wrap; margin-top: 10px;">
                            <div style="flex: 1; min-width: 200px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                                <div style="text-align: center; color: #00ff88; font-weight: bold; margin-bottom: 10px; font-size: 0.9rem;">Recentes (50)</div>
                                <div id="comp_recent_stats"></div>
                            </div>
                            <div style="flex: 1; min-width: 200px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;">
                                <div style="text-align: center; color: #ff9800; font-weight: bold; margin-bottom: 10px; font-size: 0.9rem;">Antigos (50)</div>
                                <div id="comp_old_stats"></div>
                            </div>
                        </div>
                        <div id="comp_message" style="text-align: center; color: #666; font-size: 0.8rem; margin-top: 10px;"></div>
                    </div>
                </div>

                <!-- Grupo 6: Frequ√™ncia e Hor√°rios -->
                <div class="stats-grid">
                    <!-- Grid de Todos os N√∫meros -->
                    <div class="stat-card">
                        <div class="stat-title">üìä Frequ√™ncia por N√∫mero (0-14)</div>
                        <div class="numbers-grid" id="numbers_grid"></div>
                    </div>
                    <!-- Gr√°fico de Hor√°rios Quentes -->
                    <div class="stat-card">
                        <div class="stat-title">‚è∞ Hor√°rios Quentes (Frequ√™ncia por Hora)</div>
                        <div style="display: flex; justify-content: center; gap: 10px; margin: 10px 0;">
                            <button class="filter-btn active" onclick="setHotHoursColor('red')" id="btn_hh_red" style="border-color: #ff0055; color: #ff0055; background: rgba(255, 0, 85, 0.2);">Vermelho</button>
                            <button class="filter-btn" onclick="setHotHoursColor('white')" id="btn_hh_white" style="border-color: #fff; color: #fff;">Branco</button>
                            <button class="filter-btn" onclick="setHotHoursColor('black')" id="btn_hh_black" style="border-color: #888; color: #888;">Preto</button>
                        </div>
                        <div id="hot_hours_chart_container" style="width: 100%; height: 150px; margin-top: 10px;"></div>
                    </div>
                </div>

                <!-- Grupo 7: Ferramentas -->
                <div class="stats-grid">
                    <!-- Gr√°fico de Dispers√£o -->
                    <div class="stat-card">
                        <div class="stat-title">üåå Dispers√£o (Minuto vs N√∫mero)</div>
                        <div id="scatter_chart_container" style="width: 100%; height: 200px; margin-top: 10px;"></div>
                    </div>
                    <!-- Alerta de Padr√£o Personalizado -->
                    <div class="stat-card" style="display: flex; flex-direction: column; justify-content: space-between;">
                        <div class="stat-title">üîî Alerta de Padr√£o Personalizado</div>
                        <div style="display: flex; gap: 8px; justify-content: center; margin-top: 15px; flex-wrap: wrap;">
                            <button class="filter-btn" onclick="addToPattern('red')" style="border-color: #ff0055; color: #ff0055;">V</button>
                            <button class="filter-btn" onclick="addToPattern('black')" style="border-color: #888; color: #888;">P</button>
                            <button class="filter-btn" onclick="addToPattern('white')" style="border-color: #fff; color: #fff;">B</button>
                            <button class="filter-btn" onclick="clearPattern()" style="border-color: #ff9800; color: #ff9800;">Limpar</button>
                        </div>
                        <div id="custom_pattern_display" style="min-height: 40px; margin: 15px 0; display: flex; justify-content: center; gap: 8px; align-items: center; background: rgba(0,0,0,0.2); border-radius: 8px;"></div>
                        <div id="pattern_alert_status" style="text-align: center; font-weight: bold; min-height: 20px;"></div>
                    </div>
                    <!-- Controle de Tamanho (Movido) -->
                    <div class="stat-card" style="display: flex; flex-direction: column; justify-content: center;">
                        <div class="stat-title">üîç Tamanho da Vela (Zoom)</div>
                        <div class="filter-buttons" style="margin-top: 20px; justify-content: center; gap: 15px;">
                            <button class="filter-btn" onclick="changeChartScale(-0.2)">Diminuir</button>
                            <button class="filter-btn" onclick="resetChartScale()">Padr√£o</button>
                            <button class="filter-btn" onclick="changeChartScale(0.2)">Aumentar</button>
                        </div>
                    </div>
                </div>

                <!-- Grupo 1: Vis√£o Geral (Movido) -->
                <div class="stats-grid">
                    <!-- Resumo de Cores -->
                    <div class="stat-card">
                        <div class="stat-title">Distribui√ß√£o de Cores (√öltimos <span id="total_spins">0</span> giros)</div>
                        <div class="color-bar-container">
                            <div id="bar_red" class="color-bar bg-red" style="width: 0%">0%</div>
                            <div id="bar_white" class="color-bar bg-white" style="width: 0%">0%</div>
                            <div id="bar_black" class="color-bar bg-black" style="width: 0%">0%</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.75rem; color: #888;">
                            <span id="count_red">Vermelho: 0</span>
                            <span id="count_white">Branco: 0</span>
                            <span id="count_black">Preto: 0</span>
                        </div>
                    </div>
                    <!-- Gr√°fico de Pizza Futurista -->
                    <div class="stat-card">
                        <div class="stat-title">üç∞ Distribui√ß√£o Visual (Pizza Futurista)</div>
                        <div id="pie_chart_container" style="display: flex; justify-content: center; align-items: center; padding: 20px; position: relative;"></div>
                    </div>
                </div>

                <!-- Grupo 8: Hist√≥rico Completo -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-title">üìú Hist√≥rico (√öltimas 100 Pedras)</div>
                        <div id="history_100_container" style="display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; flex-direction: row-reverse; margin-top: 15px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bot√£o Flutuante -->
    <button id="fab_save_moment" class="fab-save" onclick="saveMoment()" title="Salvar Momento">üíæ</button>

    <script>
        let updateInterval;
        let fullBlazeData = []; // Armazena todos os dados buscados
        let analysisLimit = 100; // Limite padr√£o de an√°lise
        let hotHoursColor = 'red'; // Cor padr√£o para hor√°rios quentes
        let customPattern = []; // Padr√£o personalizado
        let chartScale = 1; // Escala dos gr√°ficos
        let autoStrategyCounter = 0; // Contador para persist√™ncia
        let confirmationLevel = 2; // N√≠vel de confirma√ß√£o (velas)
        let pauseWinCount = 0; // Pausa ap√≥s Win (rodadas)
        let pauseLossCount = 0; // Pausa ap√≥s Loss (rodadas)
        let persistenceCount = 4; // Manter estrat√©gia (rodadas)
        let autoStrategyCounter2 = 0;
        let confirmationLevel2 = 2;
        let pauseWinCount2 = 0;
        let pauseLossCount2 = 0;
        let timePauseLoss = 3;
        let timePauseLoss2 = 3;
        let persistenceCount2 = 4;
        let sim1RateVal = 0;
        let sim2RateVal = 0;
        let sim1Stats = null;
        let sim2Stats = null;
        let strategyConfigs = {};
        let lastPeakSim1 = 0;
        let lastPeakSim2 = 0;
        let predictionThreshold = 95;
        let lastSavedSettings = null;

        document.addEventListener('DOMContentLoaded', () => {
            loadMoment();
            if (!lastSavedSettings) lastSavedSettings = JSON.stringify(getCurrentSettings());
            fetchBlazeData();
            if(document.getElementById('autoUpdateToggle').checked) toggleAutoUpdate();
        });

        function setAnalysisLimit(limit) {
            analysisLimit = limit;

            // Atualiza o bot√£o ativo
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            const limitValue = limit === null ? 'null' : limit;
            const activeButton = document.querySelector(`.filter-btn[onclick="setAnalysisLimit(${limitValue})"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }

            if (fullBlazeData.length > 0) {
                analyzeData(fullBlazeData);
                checkUnsavedChanges();
            }
        }

        function changeChartScale(delta) {
            chartScale += delta;
            if (chartScale < 0.5) chartScale = 0.5;
            if (chartScale > 3) chartScale = 3;
            if (fullBlazeData.length > 0) analyzeData(fullBlazeData);
            checkUnsavedChanges();
        }

        function resetChartScale() {
            chartScale = 1;
            if (fullBlazeData.length > 0) analyzeData(fullBlazeData);
            checkUnsavedChanges();
        }

        function changeConfirmation(delta) {
            const strategyId = document.getElementById('sim_strategy').value;
            if (!strategyConfigs[strategyId]) strategyConfigs[strategyId] = {};
            
            let currentVal = strategyConfigs[strategyId].confirmation !== undefined ? strategyConfigs[strategyId].confirmation : confirmationLevel;
            currentVal += delta;
            if (currentVal < 1) currentVal = 1;
            if (currentVal > 6) currentVal = 6;
            
            strategyConfigs[strategyId].confirmation = currentVal;
            document.getElementById('confirmation_display').innerText = currentVal;
            runSimulation();
            checkUnsavedChanges();
        }

        function changePauseWin(delta) {
            const strategyId = document.getElementById('sim_strategy').value;
            if (!strategyConfigs[strategyId]) strategyConfigs[strategyId] = {};

            let currentVal = strategyConfigs[strategyId].pauseWin !== undefined ? strategyConfigs[strategyId].pauseWin : pauseWinCount;
            currentVal += delta;
            if (currentVal < 0) currentVal = 0;
            if (currentVal > 6) currentVal = 6;

            strategyConfigs[strategyId].pauseWin = currentVal;
            document.getElementById('pause_win_display').innerText = currentVal;
            runSimulation();
            checkUnsavedChanges();
        }

        function changePauseLoss(delta) {
            const strategyId = document.getElementById('sim_strategy').value;
            if (!strategyConfigs[strategyId]) strategyConfigs[strategyId] = {};

            let currentVal = strategyConfigs[strategyId].pauseLoss !== undefined ? strategyConfigs[strategyId].pauseLoss : pauseLossCount;
            currentVal += delta;
            if (currentVal < 0) currentVal = 0;
            if (currentVal > 6) currentVal = 6;

            strategyConfigs[strategyId].pauseLoss = currentVal;
            document.getElementById('pause_loss_display').innerText = currentVal;
            runSimulation();
            checkUnsavedChanges();
        }

        function changeTimePauseLoss(delta) {
            // Tempo de loss n√£o √© por estrat√©gia por enquanto, √© global para a simula√ß√£o
            timePauseLoss += delta; 
            if (timePauseLoss < 0) timePauseLoss = 0; 
            if (timePauseLoss > 60) timePauseLoss = 60; 
            document.getElementById('time_pause_loss_display').innerText = timePauseLoss + 'm'; 
            runSimulation();
            checkUnsavedChanges();
        }

        function changeTimePauseLoss2(delta) {
            // Tempo de loss n√£o √© por estrat√©gia por enquanto, √© global para a simula√ß√£o
            timePauseLoss2 += delta; 
            if (timePauseLoss2 < 0) timePauseLoss2 = 0; 
            if (timePauseLoss2 > 60) timePauseLoss2 = 60; 
            document.getElementById('sim2_time_pause_loss_display').innerText = timePauseLoss2 + 'm'; 
            runSimulation2();
            checkUnsavedChanges();
        }

        function changePersistence(delta) {
            persistenceCount += delta;
            if (persistenceCount < 0) persistenceCount = 0;
            if (persistenceCount > 20) persistenceCount = 20;
            document.getElementById('persistence_display').innerText = persistenceCount;
            checkUnsavedChanges();
        }

        function changeConfirmation2(delta) {
            const strategyId = document.getElementById('sim2_strategy').value;
            if (!strategyId) return;
            if (!strategyConfigs[strategyId]) strategyConfigs[strategyId] = {};

            let currentVal = strategyConfigs[strategyId].confirmation !== undefined ? strategyConfigs[strategyId].confirmation : confirmationLevel2;
            currentVal += delta;
            if (currentVal < 1) currentVal = 1;
            if (currentVal > 6) currentVal = 6;

            strategyConfigs[strategyId].confirmation = currentVal;
            document.getElementById('sim2_confirmation_display').innerText = currentVal;
            runSimulation2();
            checkUnsavedChanges();
        }

        function changePauseWin2(delta) {
            const strategyId = document.getElementById('sim2_strategy').value;
            if (!strategyId) return;
            if (!strategyConfigs[strategyId]) strategyConfigs[strategyId] = {};

            let currentVal = strategyConfigs[strategyId].pauseWin !== undefined ? strategyConfigs[strategyId].pauseWin : pauseWinCount2;
            currentVal += delta;
            if (currentVal < 0) currentVal = 0;
            if (currentVal > 6) currentVal = 6;

            strategyConfigs[strategyId].pauseWin = currentVal;
            document.getElementById('sim2_pause_win_display').innerText = currentVal;
            runSimulation2();
            checkUnsavedChanges();
        }

        function changePauseLoss2(delta) {
            const strategyId = document.getElementById('sim2_strategy').value;
            if (!strategyId) return;
            if (!strategyConfigs[strategyId]) strategyConfigs[strategyId] = {};

            let currentVal = strategyConfigs[strategyId].pauseLoss !== undefined ? strategyConfigs[strategyId].pauseLoss : pauseLossCount2;
            currentVal += delta;
            if (currentVal < 0) currentVal = 0;
            if (currentVal > 6) currentVal = 6;

            strategyConfigs[strategyId].pauseLoss = currentVal;
            document.getElementById('sim2_pause_loss_display').innerText = currentVal;
            runSimulation2();
            checkUnsavedChanges();
        }

        function changePersistence2(delta) {
            // Persist√™ncia continua global para a simula√ß√£o
            persistenceCount2 += delta; 
            if (persistenceCount2 < 0) persistenceCount2 = 0; 
            if (persistenceCount2 > 20) persistenceCount2 = 20; 
            document.getElementById('sim2_persistence_display').innerText = persistenceCount2; 
            checkUnsavedChanges();
        }

        function changePredictionThreshold(delta) {
            predictionThreshold += delta;
            if (predictionThreshold < 50) predictionThreshold = 50;
            if (predictionThreshold > 100) predictionThreshold = 100;
            document.getElementById('prediction_threshold_display').innerText = predictionThreshold + '%';
            if (fullBlazeData.length > 0) updatePrediction(fullBlazeData);
            checkUnsavedChanges();
        }

        function toggleAutoUpdate() {
            const toggle = document.getElementById('autoUpdateToggle');
            if (toggle && toggle.checked) {
                if (updateInterval) clearInterval(updateInterval);
                updateInterval = setInterval(fetchBlazeData, 10000);
            } else {
                if (updateInterval) clearInterval(updateInterval);
            }
        }

        async function fetchBlazeData() {
            try {
                const agora = new Date();
                const ontem = new Date();
                ontem.setHours(ontem.getHours() - 24);
                
                const endDate = agora.toISOString();
                const startDate = ontem.toISOString();
                
                let allGames = [];
                // Busca p√°ginas 1 a 5 para garantir dados suficientes (aprox 500 jogos)
                for (let page = 1; page <= 5; page++) {
                    const baseUrl = `https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/history/${page}`;
                    const params = `?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}&page=${page}&_nc=${Date.now()}`;
                    const targetUrl = `${baseUrl}${params}`;
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                    
                    try {
                        const response = await fetch(proxyUrl);
                        if (response.ok) {
                            const data = await response.json();
                            const records = Array.isArray(data) ? data : (data.records || []);
                            if (records.length === 0) break;
                            allGames = allGames.concat(records);
                        }
                    } catch (e) { console.warn(`Erro na p√°gina ${page}`, e); }
                }

                // Remove duplicatas e ordena
                const seenIds = new Set();
                fullBlazeData = allGames.filter(game => {
                    if (game.id && !seenIds.has(game.id)) { seenIds.add(game.id); return true; }
                    return false;
                }).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                if (fullBlazeData.length === 0) throw new Error("Nenhum dado encontrado.");

                analyzeData(fullBlazeData, true);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
            } catch (error) {
                console.error("Erro:", error);
                document.getElementById('loading').innerHTML = '<span style="color: #ff0055;">Erro ao carregar dados. Verifique sua conex√£o ou tente mais tarde.</span>';
            }
        }

        function analyzeData(fullData, isAutoUpdate = false) {
            // Corta os dados com base no limite selecionado
            const data = analysisLimit ? fullData.slice(0, analysisLimit) : fullData;

            if (!data || data.length === 0) {
                return; // N√£o faz nada se n√£o houver dados
            }
            
            const total = data.length;
            const counts = Array(15).fill(0);
            let red = 0, black = 0, white = 0;
            let even = 0, odd = 0;

            data.forEach(game => {
                const r = game.roll;
                counts[r]++;
                
                if (r === 0) white++;
                else if (r >= 1 && r <= 7) red++;
                else if (r >= 8 && r <= 14) black++;

                if (r !== 0) {
                    if (r % 2 === 0) even++; else odd++;
                }
            });

            // Atualiza Cores
            const pRed = ((red/total)*100).toFixed(1);
            const pWhite = ((white/total)*100).toFixed(1);
            const pBlack = ((black/total)*100).toFixed(1);

            document.getElementById('total_spins').innerText = total;
            
            document.getElementById('bar_red').style.width = `${pRed}%`;
            document.getElementById('bar_red').innerText = pRed > 5 ? `${pRed}%` : '';
            document.getElementById('count_red').innerText = `Vermelho: ${red}`;

            document.getElementById('bar_white').style.width = `${pWhite}%`;
            document.getElementById('bar_white').innerText = pWhite > 3 ? `${pWhite}%` : '';
            document.getElementById('count_white').innerText = `Branco: ${white}`;

            document.getElementById('bar_black').style.width = `${pBlack}%`;
            document.getElementById('bar_black').innerText = pBlack > 5 ? `${pBlack}%` : '';
            document.getElementById('count_black').innerText = `Preto: ${black}`;

            // Atualiza Par/√çmpar
            const totalNonZero = even + odd;
            document.getElementById('even_pct').innerText = totalNonZero ? Math.round((even/totalNonZero)*100) + '%' : '0%';
            document.getElementById('odd_pct').innerText = totalNonZero ? Math.round((odd/totalNonZero)*100) + '%' : '0%';

            // Prepara Grid e Hot/Cold
            const maxCount = Math.max(...counts);
            const numberObjects = counts.map((count, num) => ({ num, count })).sort((a, b) => b.count - a.count);
            
            const hot = numberObjects.slice(0, 3);
            const cold = numberObjects.slice(-3).reverse();

            const renderBadge = (item, type) => `
                <div style="text-align: center;">
                    <div class="badge ${type === 'hot' ? 'badge-hot' : 'badge-cold'}">${item.num}</div>
                    <div style="font-size: 0.7rem; color: #888; margin-top: 2px;">${item.count}x</div>
                </div>`;

            document.getElementById('hot_numbers').innerHTML = hot.map(i => renderBadge(i, 'hot')).join('');
            document.getElementById('cold_numbers').innerHTML = cold.map(i => renderBadge(i, 'cold')).join('');

            // Renderiza Grid
            let gridHtml = '';
            for(let i=0; i<=14; i++) {
                const count = counts[i];
                const pct = ((count/total)*100).toFixed(0);
                const barPct = (count/maxCount)*100;
                
                let colorClass = 'n-white';
                if (i >= 1 && i <= 7) colorClass = 'n-red';
                if (i >= 8 && i <= 14) colorClass = 'n-black';

                let borderClass = '';
                if (hot.some(h => h.num === i)) borderClass = 'hot';
                if (cold.some(c => c.num === i)) borderClass = 'cold';

                gridHtml += `
                    <div class="number-box ${borderClass}">
                        <div class="n-val ${colorClass}">${i}</div>
                        <div class="n-count">${count}x (${pct}%)</div>
                        <div class="n-bar"><div class="n-fill" style="width: ${barPct}%; background: ${i===0 ? '#fff' : (i<=7 ? '#ff0055' : '#888')}"></div></div>
                    </div>
                `;
            }
            document.getElementById('numbers_grid').innerHTML = gridHtml;
            
            renderHotHoursChart(fullData);
            runSimulation(false, isAutoUpdate);
            runSimulation2(false, isAutoUpdate);
            analyzeSequences(fullData);
            renderPieChart(data);
            renderPeriodComparison(data);
            checkPattern(); // Verifica padr√£o ao atualizar dados
            renderScatterChart(data);
            renderHistory100(fullData);
        }

        function renderTrendChart(points, title, containerId = 'trend_chart_container') {
            const container = document.getElementById(containerId);
            if (!container) return;

            if (title) {
                const titleEl = document.getElementById('trend_chart_title');
                if (titleEl) titleEl.innerText = title;
            }

            if (!points || points.length === 0) return;

            const width = container.clientWidth || 500;
            const height = 120 * chartScale;
            container.style.height = height + 'px';
            const padding = 25; // Aumentado para caber labels laterais

            const minVal = Math.min(0, ...points);
            const maxVal = Math.max(0, ...points);
            const range = (maxVal - minVal) || 1;

            const getX = (i) => padding + (i / (points.length - 1)) * (width - 2 * padding);
            const getY = (val) => height - padding - ((val - minVal) / range) * (height - 2 * padding);

            let pathD = `M ${getX(0)} ${getY(points[0])}`;
            for (let i = 1; i < points.length; i++) {
                pathD += ` L ${getX(i)} ${getY(points[i])}`;
            }

            const zeroY = getY(0);
            
            // Cria o caminho para o preenchimento da √°rea (fechando no eixo zero)
            let areaPath = `M ${getX(0)} ${zeroY}`;
            for (let i = 0; i < points.length; i++) {
                areaPath += ` L ${getX(i)} ${getY(points[i])}`;
            }
            areaPath += ` L ${getX(points.length - 1)} ${zeroY} Z`;

            const zeroOffset = Math.max(0, Math.min(1, zeroY / height));
            const lastVal = points[points.length - 1];
            const svgId = 'trend_' + Math.random().toString(36).substr(2, 9);

            // Gera linhas de grade
            let gridSvg = '';
            const gridSteps = 4;
            for(let i=0; i<=gridSteps; i++) {
                const val = minVal + (range * (i/gridSteps));
                const y = getY(val);
                if (Math.abs(y - zeroY) > 5) { // Evita sobrepor linha zero
                    gridSvg += `<line x1="${padding}" y1="${y}" x2="${width - padding}" y2="${y}" stroke="#222" stroke-width="1" />`;
                }
            }

            const svg = `
                <svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 100%; overflow: visible;">
                    <defs>
                        <linearGradient id="grad_${svgId}" x1="0" y1="0" x2="0" y2="${height}" gradientUnits="userSpaceOnUse">
                            <stop offset="0" stop-color="#00ff88" />
                            <stop offset="${zeroOffset}" stop-color="#00ff88" />
                            <stop offset="${zeroOffset}" stop-color="#ff0055" />
                            <stop offset="1" stop-color="#ff0055" />
                        </linearGradient>
                        <linearGradient id="fill_grad_${svgId}" x1="0" y1="0" x2="0" y2="${height}" gradientUnits="userSpaceOnUse">
                            <stop offset="0" stop-color="#00ff88" stop-opacity="0.2" />
                            <stop offset="${zeroOffset}" stop-color="#00ff88" stop-opacity="0.05" />
                            <stop offset="${zeroOffset}" stop-color="#ff0055" stop-opacity="0.05" />
                            <stop offset="1" stop-color="#ff0055" stop-opacity="0.2" />
                        </linearGradient>
                        <filter id="glow_${svgId}" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    
                    <!-- Grid -->
                    ${gridSvg}
                    
                    <!-- Zero Line -->
                    <line x1="${padding}" y1="${zeroY}" x2="${width - padding}" y2="${zeroY}" stroke="#666" stroke-dasharray="4" stroke-width="1" opacity="0.5" />
                    
                    <!-- Area Fill -->
                    <path d="${areaPath}" fill="url(#fill_grad_${svgId})" stroke="none" />

                    <!-- Main Line -->
                    <path d="${pathD}" fill="none" stroke="url(#grad_${svgId})" stroke-width="2.5" filter="url(#glow_${svgId})" stroke-linecap="round" stroke-linejoin="round">
                        <animate attributeName="stroke-dasharray" from="0, 5000" to="5000, 0" dur="2.5s" fill="freeze" calcMode="spline" keySplines="0.4 0 0.2 1" keyTimes="0;1" />
                    </path>
                    
                    <!-- End Point -->
                    <circle cx="${getX(points.length - 1)}" cy="${getY(lastVal)}" r="4" fill="#fff" filter="url(#glow_${svgId})">
                        <animate attributeName="r" values="3;6;3" dur="1.5s" repeatCount="indefinite" />
                        <animate attributeName="opacity" values="1;0.6;1" dur="1.5s" repeatCount="indefinite" />
                    </circle>
                    
                    <!-- Labels -->
                    <text x="${width - padding}" y="${getY(lastVal) - 10}" fill="${lastVal >= 0 ? '#00ff88' : '#ff0055'}" font-size="12" text-anchor="end" font-weight="bold" style="text-shadow: 0 0 5px rgba(0,0,0,0.8);">
                        ${lastVal > 0 ? '+' : ''}${lastVal}
                    </text>
                    <text x="${padding - 5}" y="${getY(maxVal) + 4}" fill="#00ff88" font-size="10" text-anchor="end" opacity="0.6">${maxVal}</text>
                    <text x="${padding - 5}" y="${getY(minVal) - 2}" fill="#ff0055" font-size="10" text-anchor="end" opacity="0.6">${minVal}</text>
                </svg>
            `;
            container.innerHTML = svg;
            updateTrendIndicator(points);
        }

        function isPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;
            for (let i = 5; i * i <= num; i = i + 6) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
            }
            return true;
        }

        function getStrategyPrediction(hist, strat, confirmLvlToUse, analyzeWhite) {
            if (!hist || hist.length === 0) return null;
            
            // Fun√ß√µes auxiliares de cor
            const getColorRaw = (r) => (r === 0) ? 'white' : ((r >= 1 && r <= 7) ? 'red' : 'black');

            const getColor = (idx) => {
                if (!hist || idx >= hist.length) return 'white';
                const r = hist[idx].roll;
                const c = getColorRaw(r);
                if (c === 'white' && analyzeWhite) {
                    let rC = 0, bC = 0;
                    for(let k=1; k<=5; k++) {
                        if (idx + k < hist.length) {
                            const val = hist[idx + k].roll;
                            if (val >= 1 && val <= 7) rC++;
                            else if (val >= 8 && val <= 14) bC++;
                        }
                    }
                    return rC >= bC ? 'red' : 'black';
                }
                return c;
            };
            
            // Helper para verificar sequ√™ncia
            const checkPattern = (type, len) => {
                if (hist.length < len) return false;
                const first = getColor(0);
                if (first === 'white') return false;
                for (let k = 1; k < len; k++) {
                    const curr = getColor(k);
                    if (type === 'follow' && curr !== first) return false;
                    if (type === 'alternating') {
                        const expected = (k % 2 === 0) ? first : (first === 'red' ? 'black' : 'red');
                        if (curr !== expected) return false;
                    }
                }
                return true;
            };

            if (strat === 'alternating') {
                if (checkPattern('alternating', confirmLvlToUse)) {
                    const lastColor = getColor(0);
                    return (lastColor === 'red' ? 'black' : 'red');
                }
            } 
            else if (strat === 'follow') {
                if (checkPattern('follow', confirmLvlToUse)) {
                    return getColor(0);
                }
            }
            else if (strat === 'majority') {
                if (hist.length < 5) return null;
                let r=0, b=0;
                for(let i=0; i<5; i++) {
                    const c = getColor(i);
                    if(c === 'red') r++; else if(c === 'black') b++;
                }
                // Assertividade: Exige margem de pelo menos 2 (Ex: 4v1 ou 5v0)
                if (r >= b + 2) return 'red';
                if (b >= r + 2) return 'black';
            }
            else if (strat === 'ia_cores') {
                if (hist.length < 5) return null;
                let rScore=0, bScore=0;
                const hColors = [];
                for(let i=0; i<5; i++) hColors.push(getColor(i));
                
                if(hColors[0]===hColors[1] && hColors[1]===hColors[2]) {
                    if(hColors[0]==='red') rScore+=2; else if(hColors[0]==='black') bScore+=2;
                }
                if(hColors[0]!==hColors[1] && hColors[1]!==hColors[2]) {
                    if(hColors[0]==='red') bScore+=2; else if(hColors[0]==='black') rScore+=2;
                }
                const rCount = hColors.filter(c=>c==='red').length;
                const bCount = hColors.filter(c=>c==='black').length;
                if(rCount > bCount) rScore++; else bScore++;
                
                if(rScore > bScore) return 'red';
                if(bScore > rScore) return 'black';
            }
            else if (strat === 'analise_cores') {
                if (checkPattern('follow', confirmLvlToUse)) return getColor(0);
                else if (checkPattern('alternating', confirmLvlToUse)) {
                    const last = getColor(0);
                    return (last === 'red' ? 'black' : 'red');
                }
            }
            else if (strat === 'alignment') {
                if (hist.length < 20) return null;
                let r=0, b=0;
                for(let i=0; i<20; i++) {
                    const c = getColor(i);
                    if(c==='red') r++; else if(c==='black') b++;
                }
                // Assertividade: Exige maioria simples mas consistente
                if(r > b + 2) return 'red';
                if(b > r + 2) return 'black';
            }
            else if (strat === 'euler') {
                if (checkPattern('alternating', confirmLvlToUse)) {
                    const last = getColor(0);
                    return (last === 'red' ? 'black' : 'red');
                } else if (checkPattern('follow', confirmLvlToUse)) {
                    return getColor(0);
                }
            }
            else if (strat === 'gauss') {
                if (hist.length < 7) return null;
                let r=0, b=0;
                for(let i=0; i<7; i++) {
                    const c = getColor(i);
                    if(c==='red') r++; else if(c==='black') b++;
                }
                // Assertividade: Margem de seguran√ßa
                if(r >= b + 2) return 'red';
                if(b >= r + 2) return 'black';
            }
            else if (strat === 'fibonacci') {
                const fibs = [1, 2, 3, 5, 8, 13];
                let r=0, b=0;
                fibs.forEach(fib => {
                    if(hist.length > fib) {
                        const c = getColor(fib-1); // -1 pois array come√ßa em 0
                        if(c==='red') r++; else if(c==='black') b++;
                    }
                });
                // Assertividade: Margem de seguran√ßa
                if(r >= b + 1) return 'red';
                if(b >= r + 1) return 'black';
            }
            else if (strat === 'sniper') {
                // Sniper agora usa confirmationLevel para definir o tamanho da sequ√™ncia a reverter
                if (checkPattern('follow', confirmLvlToUse)) {
                    const last = getColor(0);
                    return (last === 'red' ? 'black' : 'red');
                }
            }
            else if (strat === 'olho_de_deus') {
                if (hist.length < 100) return null;
                let rCount = 0, bCount = 0;
                for (let j = 0; j < 100; j++) {
                    const c = getColor(j);
                    if (c === 'red') rCount++;
                    else if (c === 'black') bCount++;
                }
                const diff = rCount - bCount;
                if (diff >= 8) return 'black'; // Revers√£o de longo prazo (Vermelho dominante -> Aposta Preto)
                else if (diff <= -8) return 'red'; // Revers√£o de longo prazo (Preto dominante -> Aposta Vermelho)
                else {
                    // Se equilibrado no longo prazo, segue o fluxo de curto prazo (10 pedras)
                    let rShort = 0, bShort = 0;
                    for (let j = 0; j < 10; j++) {
                        const c = getColor(j);
                        if (c === 'red') rShort++; else if (c === 'black') bShort++;
                    }
                    if (rShort > bShort + 2) return 'red';
                    if (bShort > rShort + 2) return 'black';
                }
            }
            else if (strat === 'ciclo_lunar') {
                if (hist.length >= 15) {
                    const target = getColor(14); // Verifica a cor de 15 pedras atr√°s (√≠ndice 14)
                    if (target === 'red' || target === 'black') return target;
                }
            }
            else if (strat === 'espelho_magico') {
                if (hist.length >= 10) {
                    const pastColor = getColor(9); // Pega a cor de 10 rodadas atr√°s (√≠ndice 9)
                    if (pastColor === 'red') return 'black';
                    if (pastColor === 'black') return 'red';
                }
            }
            else if (strat === 'fibonacci_sequence') {
                if (hist.length > 1) {
                    const fibs = [1, 2, 3, 5, 8, 13, 21];
                    let currentStreak = 1;
                    const lastColor = getColor(0); // Cor mais recente

                    // Conta a sequ√™ncia da cor atual
                    for (let k = 1; k < hist.length; k++) {
                        if (getColor(k) === lastColor) {
                            currentStreak++;
                        } else {
                            break;
                        }
                    }
                    if (fibs.includes(currentStreak)) return (lastColor === 'red' ? 'black' : 'red');
                }
            }
            else if (strat === 'mare_vermelha') {
                if (hist.length >= 3) {
                    if (getColor(0) !== 'red' && getColor(1) !== 'red' && getColor(2) !== 'red') {
                        return 'red';
                    }
                }
            }
            else if (strat === 'vortex_numerico') {
                if (hist.length >= 4) {
                    const sum = hist[0].roll + hist[1].roll + hist[2].roll + hist[3].roll;
                    const vortexResult = sum % 15;
                    if (vortexResult >= 1 && vortexResult <= 7) return 'black'; // Resultado do vortex √© vermelho, aposta preto
                    if (vortexResult >= 8 && vortexResult <= 14) return 'red'; // Resultado do vortex √© preto, aposta vermelho
                }
            }
            else if (strat === 'reversao_quantica') {
                if (hist.length >= 25) {
                    const historySlice = hist.slice(0, 25);
                    const lastSeenIndex = new Map(); // Map<number, index>
                    historySlice.forEach((game, index) => {
                        if (!lastSeenIndex.has(game.roll)) {
                            lastSeenIndex.set(game.roll, index);
                        }
                    });

                    let coldestRoll = -1;
                    let maxIndex = -1;

                    for (let num = 0; num <= 14; num++) {
                        if (lastSeenIndex.has(num)) {
                            if (lastSeenIndex.get(num) > maxIndex) {
                                maxIndex = lastSeenIndex.get(num);
                                coldestRoll = num;
                            }
                        } else {
                            coldestRoll = num;
                            break;
                        }
                    }

                    if (coldestRoll !== -1) {
                        const color = getColorRaw(coldestRoll);
                        if (color !== 'white') return color;
                    }
                }
            }
            else if (strat === 'pulso_eletromagnetico') {
                if (hist.length >= 3 && hist[0].created_at) {
                    const minute = new Date(hist[0].created_at).getMinutes();
                    const c1 = getColor(0), c2 = getColor(1), c3 = getColor(2);
                    if (c1 === 'white' || c2 === 'white' || c3 === 'white') return null;
                    const isTrending = (c1 === c2 && c2 === c3);
                    if (minute % 2 === 0) { // Par: Segue tend√™ncia
                        if (isTrending) return c1;
                    } else { // √çmpar: Reverte tend√™ncia
                        if (isTrending) return c1 === 'red' ? 'black' : 'red';
                    }
                }
            }
            else if (strat === 'cacador_de_zeros') {
                if (hist.length >= 20) {
                    let hasRed = false, hasBlack = false;
                    if (getColor(0) === 'red' || getColor(1) === 'red') hasRed = true;
                    if (getColor(0) === 'black' || getColor(1) === 'black') hasBlack = true;
                    
                    let whiteInLast20 = false;
                    for(let k=0; k<20; k++) {
                        if (getColor(k) === 'white') {
                            whiteInLast20 = true;
                            break;
                        }
                    }
                    if (hasRed && hasBlack && !whiteInLast20) {
                        return 'white';
                    }
                }
            }
            else if (strat === 'sombra_do_branco') {
                if (hist.length >= 25) {
                    let whiteFound = false;
                    for (let k = 14; k < 25; k++) { // index 14 to 24 (15th to 25th item)
                        if (k < hist.length && getColor(k) === 'white') {
                            whiteFound = true;
                            break;
                        }
                    }
                    if (whiteFound) {
                        return 'white';
                    }
                }
            }
            else if (strat === 'convergencia_numerica') {
                if (hist.length >= 3) {
                    const rolls = [hist[0].roll, hist[1].roll, hist[2].roll];
                    rolls.sort((a, b) => a - b);
                    const isSequential = rolls[0] + 1 === rolls[1] && rolls[1] + 1 === rolls[2];
                    if (isSequential) {
                        return 'white';
                    }
                }
            }
            else if (strat === 'horario_do_branco') {
                if (hist.length > 0 && hist[0].created_at) {
                    const minute = new Date(hist[0].created_at).getMinutes();
                    if (minute > 0 && minute % 7 === 0) {
                        return 'white';
                    }
                }
            }
            else if (strat === 'olho_de_deus_90') {
                if (hist.length >= 90) {
                    let rCount = 0, bCount = 0;
                    for (let j = 0; j < 90; j++) {
                        const c = getColor(j);
                        if (c === 'red') rCount++;
                        else if (c === 'black') bCount++;
                    }
                    const diff = rCount - bCount;
                    if (diff >= 10) return 'black';
                    else if (diff <= -10) return 'red';
                }
            }
            else if (strat === 'mhi_minoria') {
                if (hist.length >= 3) {
                    let rCount = 0, bCount = 0;
                    for (let j = 0; j < 3; j++) {
                        const c = getColor(j);
                        if (c === 'red') rCount++; else if (c === 'black') bCount++;
                    }
                    if (rCount > bCount) return 'black';
                    else if (bCount > rCount) return 'red';
                }
            }
            else if (strat === 'quebra_2x2') {
                if (hist.length >= 4) {
                    const c1 = getColor(0); // Mais recente
                    const c2 = getColor(1);
                    const c3 = getColor(2);
                    const c4 = getColor(3); // Mais antigo
                    if (c1 === 'red' && c2 === 'red' && c3 === 'black' && c4 === 'black') { return 'red'; }
                    else if (c1 === 'black' && c2 === 'black' && c3 === 'red' && c4 === 'red') { return 'black'; }
                }
            }
            else if (strat === 'eco_passado') {
                if (hist.length > 1) {
                    const triggerNumber = hist[0].roll;
                    let redFollowers = 0;
                    let blackFollowers = 0;
                    let occurrences = 0;

                    for (let j = 1; j < hist.length - 1; j++) {
                        if (hist[j].roll === triggerNumber) {
                            occurrences++;
                            const followerRoll = hist[j - 1].roll;
                            const followerColor = getColorRaw(followerRoll);
                            if (followerColor === 'red') redFollowers++;
                            else if (followerColor === 'black') blackFollowers++;
                        }
                    }
                    if (occurrences >= 3) {
                        if (redFollowers >= blackFollowers + 2) return 'red';
                        else if (blackFollowers >= redFollowers + 2) return 'black';
                    }
                }
            }
            else if (strat === 'padrao_espelhado') {
                if (hist.length >= 3) {
                    const c1 = getColor(0); // Mais recente
                    const c2 = getColor(1);
                    const c3 = getColor(2); // Mais antigo
                    if (c1 === c3 && c1 !== c2) {
                        return c1;
                    }
                }
            }
            else if (strat === 'inercia_newton') {
                if (hist.length >= 6) {
                    const last = getColor(0);
                    let streak = 1;
                    for(let k=1; k<6; k++) {
                        if(getColor(k) === last) streak++; else break;
                    }
                    if(streak >= 6) return last;
                }
            }
            else if (strat === 'reacao_newton') {
                if (hist.length >= 20) {
                    let r=0, b=0;
                    for(let k=0; k<20; k++) {
                        const c = getColor(k);
                        if(c==='red') r++; else if(c==='black') b++;
                    }
                    if (r >= 15) return 'black';
                    if (b >= 15) return 'red';
                }
            }
            else if (strat === 'entropia_caos') {
                if (checkPattern('alternating', 6)) {
                    return getColor(0);
                }
            }
            else if (strat === 'soma_dragao') {
                if (hist.length >= 7) {
                    let consistent = true;
                    for (let k = 0; k < 4; k++) {
                        let sum = 0;
                        for (let m = 1; m <= 3; m++) sum += hist[k + m].roll;
                        let predicted = (sum % 2 !== 0) ? 'red' : 'black';
                        if (getColor(k) !== predicted) { consistent = false; break; }
                    }
                    if (consistent) {
                        let currentSum = 0;
                        for (let m = 0; m < 3; m++) currentSum += hist[m].roll;
                        return (currentSum % 2 !== 0) ? 'red' : 'black';
                    }
                }
            }
            else if (strat === 'codigo_muralha') {
                if (hist.length >= 6) {
                    let consistent = true;
                    for (let k = 0; k < 4; k++) {
                        let sum = hist[k + 1].roll + hist[k + 2].roll;
                        let predicted = (sum > 14) ? 'black' : 'red';
                        if (getColor(k) !== predicted) { consistent = false; break; }
                    }
                    if (consistent) {
                        let currentSum = hist[0].roll + hist[1].roll;
                        return (currentSum > 14) ? 'black' : 'red';
                    }
                }
            }
            else if (strat === 'lotus_dourada') {
                if (hist.length >= 9) {
                    let consistent = true;
                    for (let k = 0; k < 4; k++) {
                        let sum = 0;
                        for (let m = 1; m <= 5; m++) sum += hist[k + m].roll;
                        let predicted = (sum % 10 <= 4) ? 'red' : 'black';
                        if (getColor(k) !== predicted) { consistent = false; break; }
                    }
                    if (consistent) {
                        let currentSum = 0;
                        for (let m = 0; m < 5; m++) currentSum += hist[m].roll;
                        return (currentSum % 10 <= 4) ? 'red' : 'black';
                    }
                }
            }
            
            else if (strat === 'yin_yang') {
                if (hist.length >= 1) {
                    let sum = 0;
                    const limit = Math.min(hist.length, 100);
                    for (let k = 0; k < limit; k++) sum += hist[k].roll;
                    if (isPrime(sum)) {
                        const lastColor = getColor(0);
                        if (lastColor === 'red') return 'black';
                        if (lastColor === 'black') return 'red';
                    }
                }
            }
            else if (strat === 'caos_ordem') {
                // Alterna a cada 10 rodadas. Baseado no tamanho do hist√≥rico (ex: 100).
                const phase = Math.floor(hist.length / 10) % 2;
                const lastColor = getColor(0);
                if (lastColor === 'white') return null;
                if (phase === 0) { // Ordem (Par): Segue
                    return lastColor;
                } else { // Caos (√çmpar): Inverte
                    return (lastColor === 'red' ? 'black' : 'red');
                }
            }
            else if (strat === 'guardiao_real') {
                if (checkPattern('follow', 8)) {
                    const last = getColor(0);
                    return (last === 'red' ? 'black' : 'red');
                }
            }
            else if (strat === 'estrela_cadente') {
                if (checkPattern('alternating', 6)) {
                    return getColor(0);
                }
            }
            else if (strat === 'horizonte_eventos') {
                if (hist.length >= 3) {
                    const sum = hist[0].roll + hist[1].roll + hist[2].roll;
                    if (sum > 30) return 'red';
                    if (sum < 10) return 'black';
                }
            }
            else if (strat === 'anomalia_temporal_b') {
                if (hist.length >= 50 && getColor(49) === 'white') {
                    return 'white';
                }
            }
            else if (strat === 'eco_numerico_b') {
                if (hist.length >= 3) {
                    const r1 = hist[0].roll;
                    const r2 = hist[1].roll;
                    const r3 = hist[2].roll;
                    if (r1 !== 0 && r1 === r2 && r2 === r3) {
                        return 'white';
                    }
                }
            }
            else if (strat === 'vacuo_de_cor_b') {
                if (hist.length >= 50) {
                    let whiteInLast50 = false;
                    for (let k = 0; k < 50; k++) {
                        if (getColor(k) === 'white') {
                            whiteInLast50 = true;
                            break;
                        }
                    }
                    if (!whiteInLast50) {
                        return 'white';
                    }
                }
            }
            else if (strat === 'sincronicidade_primos_b') {
                if (hist.length > 1) {
                    const lastRoll = hist[0].roll;
                    if (isPrime(lastRoll)) {
                        let roundsSinceWhite = 0;
                        let whiteFound = false;
                        for (let k = 1; k < hist.length; k++) {
                            roundsSinceWhite++;
                            if (getColor(k) === 'white') {
                                whiteFound = true;
                                break;
                            }
                        }
                        if (whiteFound && isPrime(roundsSinceWhite)) return 'white';
                    }
                }
            }
            
            return null;
        }

        function updatePrediction(data) {
            if (!data || data.length < 1) return;
            
            // Determine best sim
            const useSim2 = sim2RateVal > sim1RateVal;
            const activeStats = useSim2 ? sim2Stats : sim1Stats;
            const activeRate = useSim2 ? sim2RateVal : sim1RateVal;
            
            // Update Source Label
            const sourceLabel = document.getElementById('pred_active_source');
            const strategySelectId = useSim2 ? 'sim2_strategy' : 'sim_strategy';
            const select = document.getElementById(strategySelectId);
            let strategyName = 'Desconhecida';
            if (select && select.selectedIndex >= 0 && select.options.length > 0) {
                strategyName = select.options[select.selectedIndex].text.split('(')[0].trim();
            }
            if (sourceLabel) {
                sourceLabel.innerText = `Melhor: ${strategyName} (${activeRate.toFixed(0)}%)`;
                sourceLabel.style.color = useSim2 ? '#ff9800' : '#00d2ff';
            }

            // Update Scoreboard & Signal Strength
            if (activeStats) {
                document.getElementById('pred_wins').innerText = activeStats.wins;
                document.getElementById('pred_losses').innerText = activeStats.losses;
                document.getElementById('pred_rate').innerText = Math.round(activeRate) + '%';
                
                const strengthBar = document.getElementById('signal_strength_bar');
                const strengthText = document.getElementById('signal_strength_text');
                if (strengthBar && strengthText) {
                    strengthBar.style.width = `${activeRate}%`;
                    let label = 'BAIXA';
                    let color = '#ff0055';
                    if (activeRate >= 60) { label = 'EXCELENTE üöÄ'; color = '#00ff88'; }
                    else if (activeRate >= 50) { label = 'ALTA üî•'; color = '#ccff00'; }
                    else if (activeRate >= 40) { label = 'MODERADA ‚öñÔ∏è'; color = '#ff9800'; }
                    else { label = 'FRACA ‚ö†Ô∏è'; color = '#ff0055'; }
                    strengthBar.style.background = color;
                    strengthBar.style.boxShadow = `0 0 10px ${color}`;
                    strengthText.innerText = label;
                    strengthText.style.color = color;
                }

                // Update Trend Summary
                const finalBalance = activeStats.balanceHistory[activeStats.balanceHistory.length - 1] || 0;
                const peak = Math.max(0, ...activeStats.balanceHistory);
                const trough = Math.min(0, ...activeStats.balanceHistory);
                const totalEntries = activeStats.wins + activeStats.losses;

                const peakEl = document.getElementById('trend_peak');
                if (peakEl) {
                    // Check for new peak and apply animation
                    const lastPeak = useSim2 ? lastPeakSim2 : lastPeakSim1;
                    if (peak > lastPeak) {
                        peakEl.classList.add('pulse-green');
                        setTimeout(() => peakEl.classList.remove('pulse-green'), 800);
                    }
                    // Update last peak value
                    if (useSim2) { lastPeakSim2 = peak; } 
                    else { lastPeakSim1 = peak; }

                    peakEl.innerText = `R$ ${peak}`;
                    peakEl.style.color = peak > 0 ? '#00ff88' : '#aaa';
                }

                const troughEl = document.getElementById('trend_trough');
                if (troughEl) {
                    troughEl.innerText = `R$ ${trough}`;
                    troughEl.style.color = trough < 0 ? '#ff0055' : '#aaa';
                }

                const entriesEl = document.getElementById('trend_entries');
                if (entriesEl) entriesEl.innerText = totalEntries;

                const finalBalEl = document.getElementById('trend_final_balance');
                if (finalBalEl) {
                    finalBalEl.innerText = `R$ ${finalBalance}`;
                    finalBalEl.style.color = finalBalance >= 0 ? '#00ff88' : '#ff0055';
                }

                // Atualiza o Gr√°fico de Tend√™ncia Principal com a melhor simula√ß√£o
                const selectForChart = document.getElementById(strategySelectId);
                const strategyNameForChart = selectForChart && selectForChart.options.length > 0 ? selectForChart.options[selectForChart.selectedIndex].text : 'Desconhecida';
                const simLabel = useSim2 ? "Sim 2" : "Sim 1";
                renderTrendChart(activeStats.balanceHistory, `üìà Tend√™ncia de Saldo (${simLabel}: ${strategyNameForChart})`, 'trend_chart_container');

                // Atualiza o Hist√≥rico Visual de Entradas com a melhor simula√ß√£o
                renderEntryHistory(activeStats.entryHistory);
            }

            const confirmationLvl = useSim2 ? confirmationLevel2 : confirmationLevel;
            const strategy = document.getElementById(strategySelectId).value;
            const analyzeWhite = useSim2 ? (document.getElementById('sim2_analyze_white')?.checked || false) : (document.getElementById('analyze_white_toggle')?.checked || false);

            const last5 = data.slice(0, 5);
            const container = document.getElementById('last_5_sequence');
            const predictionEl = document.getElementById('prediction_result');
            
            if (!container || !predictionEl) return;

            // 1. Renderiza a sequ√™ncia visual (√öltimos 5)
            let html = '';
            for(let i = last5.length - 1; i >= 0; i--) {
                const r = last5[i].roll;
                let colorClass = 'seq-white';
                if (r >= 1 && r <= 7) colorClass = 'seq-red';
                else if (r >= 8 && r <= 14) colorClass = 'seq-black';
                html += `<div class="seq-badge ${colorClass}">${r}</div>`;
            }
            container.innerHTML = html;

            // Gera Previs√£o Atual (Alerta de Entrada)
            const currentPred = getStrategyPrediction(data, strategy, confirmationLvl, analyzeWhite);
            let suggestion = 'Aguardando Padr√£o...';
            let suggestionColor = '#aaa';

            if (activeRate > predictionThreshold) {
                if (currentPred === 'red') {
                    suggestion = 'üî¥ ENTRAR NO VERMELHO';
                    suggestionColor = '#ff0055';
                } else if (currentPred === 'black') {
                    suggestion = '‚ö´ ENTRAR NO PRETO';
                    suggestionColor = '#fff';
                }
                 else if (currentPred === 'white') {
                    suggestion = '‚ö™Ô∏è ENTRAR NO BRANCO';
                    suggestionColor = '#fff';
                }
            } 
            else if (currentPred) {
                suggestion = `Aguardando Assertividade > ${predictionThreshold}% (${Math.round(activeRate)}%)`;
                suggestionColor = '#aaa';
            }

            predictionEl.innerHTML = suggestion;
            predictionEl.style.color = suggestionColor;
        }

        function setHotHoursColor(color) {
            hotHoursColor = color;
            // Atualiza bot√µes
            ['red', 'white', 'black'].forEach(c => {
                const btn = document.getElementById(`btn_hh_${c}`);
                if (btn) {
                    if (c === color) {
                        btn.classList.add('active');
                        btn.style.background = c === 'red' ? 'rgba(255, 0, 85, 0.2)' : (c === 'white' ? 'rgba(255, 255, 255, 0.2)' : 'rgba(136, 136, 136, 0.2)');
                    } else {
                        btn.classList.remove('active');
                        btn.style.background = 'transparent';
                    }
                }
            });
            if (fullBlazeData.length > 0) renderHotHoursChart(fullBlazeData);
            checkUnsavedChanges();
        }

        function renderHotHoursChart(data) {
            const container = document.getElementById('hot_hours_chart_container');
            if (!container || !data || data.length === 0) return;

            const hourlyCounts = new Array(24).fill(0);
            
            data.forEach(game => {
                if (!game.created_at) return;
                const date = new Date(game.created_at);
                const hour = date.getHours();
                const r = game.roll;
                
                let isMatch = false;
                if (hotHoursColor === 'red' && r >= 1 && r <= 7) isMatch = true;
                else if (hotHoursColor === 'black' && r >= 8 && r <= 14) isMatch = true;
                else if (hotHoursColor === 'white' && r === 0) isMatch = true;

                if (isMatch) hourlyCounts[hour]++;
            });

            const maxCount = Math.max(...hourlyCounts, 1);
            const width = container.clientWidth || 500;
            const height = 150 * chartScale;
            container.style.height = height + 'px';
            const barWidth = (width / 24) - 2;
            
            let svgContent = '';
            let fillColor = hotHoursColor === 'red' ? '#ff0055' : (hotHoursColor === 'white' ? '#fff' : '#888');

            hourlyCounts.forEach((count, hour) => {
                const barHeight = (count / maxCount) * (height - 20);
                const x = hour * (width / 24);
                const y = height - barHeight - 15;
                const opacity = 0.3 + (count / maxCount) * 0.7;

                svgContent += `
                    <rect x="${x + 1}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${fillColor}" fill-opacity="${opacity}" rx="2">
                        <title>${hour}h: ${count}x</title>
                    </rect>
                    <text x="${x + barWidth/2}" y="${height - 2}" font-size="9" fill="#888" text-anchor="middle">${hour}</text>
                    ${count > 0 ? `<text x="${x + barWidth/2}" y="${y - 2}" font-size="9" fill="#fff" text-anchor="middle">${count}</text>` : ''}
                `;
            });

            container.innerHTML = `<svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 100%; overflow: visible;">${svgContent}</svg>`;
        }

        function handleStrategyChange() {
            const toggle = document.getElementById('best_strategy_toggle');
            if (toggle && toggle.checked) toggle.checked = false;
            updateSimControls(1);
            runSimulation();
        }

        function toggleBestStrategy() {
            const toggle = document.getElementById('best_strategy_toggle');
            if (toggle && toggle.checked) {
                autoStrategyCounter = 0;
                findBestStrategy();
            }
        }

        function findBestStrategy(isAutoUpdate = false) {
            if (!fullBlazeData || fullBlazeData.length === 0) return;
            
            const limit = analysisLimit || fullBlazeData.length;
            const dataSlice = fullBlazeData.slice(0, limit);
            const simData = [...dataSlice].reverse();
            const galeLevel = document.getElementById('gale_active_toggle')?.checked ? 1 : 0;
            const analyzeWhite = document.getElementById('analyze_white_toggle')?.checked || false;
            const invertGale = document.getElementById('gale_invert_toggle')?.checked || false;            
            
            const select = document.getElementById('sim_strategy');
            const previousStrategy = select.value;
            let bestStrategy = previousStrategy;
            let bestRate = -1;
            let bestBalance = -Infinity;
            
            // Vari√°veis para melhor estrat√©gia COM padr√£o ativo
            let bestPatternStrategy = null;
            let bestPatternRate = -1;
            let bestPatternBalance = -Infinity;

            for (let i = 0; i < select.options.length; i++) {
                const strategy = select.options[i].value;
                const config = strategyConfigs[strategy] || {};
                const confirmationToUse = config.confirmation !== undefined ? config.confirmation : confirmationLevel;
                const pauseWinToUse = config.pauseWin !== undefined ? config.pauseWin : pauseWinCount;
                const pauseLossToUse = config.pauseLoss !== undefined ? config.pauseLoss : pauseLossCount;

                const result = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationToUse, pauseWinToUse, pauseLossToUse, timePauseLoss);
                
                const total = result.wins + result.losses;
                const rate = total > 0 ? (result.wins / total) : 0;
                
                // Verifica se existe padr√£o ATUALMENTE
                const hasPattern = getStrategyPrediction(fullBlazeData, strategy, confirmationLevel, analyzeWhite) !== null;

                if (rate > bestRate) {
                    bestRate = rate;
                    bestBalance = result.balance;
                    bestStrategy = strategy;
                } else if (rate === bestRate) {
                    if (result.balance > bestBalance) {
                        bestBalance = result.balance;
                        bestStrategy = strategy;
                    }
                }
                
                // Se tem padr√£o, verifica se √© a melhor COM padr√£o
                if (hasPattern) {
                    if (rate > bestPatternRate) {
                        bestPatternRate = rate;
                        bestPatternBalance = result.balance;
                        bestPatternStrategy = strategy;
                    } else if (rate === bestPatternRate) {
                        if (result.balance > bestPatternBalance) {
                            bestPatternBalance = result.balance;
                            bestPatternStrategy = strategy;
                        }
                    }
                }
            }

            // Prioriza estrat√©gia com padr√£o ativo, se houver
            if (bestPatternStrategy) {
                select.value = bestPatternStrategy;
            } else {
                select.value = bestStrategy;
            }
            
            updateSimControls(1);

            if (persistenceCount > 0) {
                autoStrategyCounter = persistenceCount;
            }
            runSimulation(true);

            if (bestStrategy !== previousStrategy) {
                triggerStrategyChangeAlert();
            }
        }

        function updateStrategyLabels(simData, galeLevel, analyzeWhite, invertGale, pauseWin, pauseLoss, confirmLvl) {
            const select = document.getElementById('sim_strategy');
            if (!select) return;

            for (let i = 0; i < select.options.length; i++) {
                const option = select.options[i];
                if (!option.hasAttribute('data-original-text')) {
                    option.setAttribute('data-original-text', option.text);
                }
                
                const strategy = option.value;
                const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmLvl, pauseWin, pauseLoss, timePauseLoss);
                const total = stats.wins + stats.losses;
                const rate = total > 0 ? (stats.wins / total) * 100 : 0;
                
                const originalText = option.getAttribute('data-original-text');
                option.text = `${originalText} (${rate.toFixed(0)}%)`;
            }
        }

        function runSimulation(skipBestCheck = false, isAutoUpdate = false) {
            if (!fullBlazeData || fullBlazeData.length === 0) return;
            
            if (!skipBestCheck) {
                const toggle = document.getElementById('best_strategy_toggle');
                if (toggle && toggle.checked) {
                    findBestStrategy(isAutoUpdate);
                    return;
                }
            }
            
            const limit = analysisLimit || fullBlazeData.length;
            const dataSlice = fullBlazeData.slice(0, limit);
            const simData = [...dataSlice].reverse();
            
            const strategy = document.getElementById('sim_strategy').value;
            const galeLevel = document.getElementById('gale_active_toggle')?.checked ? 1 : 0;
            const analyzeWhite = document.getElementById('analyze_white_toggle')?.checked || false;
            const invertGale = document.getElementById('gale_invert_toggle')?.checked || false;
            
            const config = strategyConfigs[strategy] || {};
            const confirmationToUse = config.confirmation !== undefined ? config.confirmation : confirmationLevel;
            const pauseWinToUse = config.pauseWin !== undefined ? config.pauseWin : pauseWinCount;
            const pauseLossToUse = config.pauseLoss !== undefined ? config.pauseLoss : pauseLossCount;

            updateStrategyLabels(simData, galeLevel, analyzeWhite, invertGale, pauseWinToUse, pauseLossToUse, confirmationToUse);

            const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationToUse, pauseWinToUse, pauseLossToUse, timePauseLoss);
            
            sim1Stats = stats;
            const total = stats.wins + stats.losses;
            sim1RateVal = total > 0 ? (stats.wins / total) * 100 : 0;

            document.getElementById('sim_wins').innerText = stats.wins;
            document.getElementById('sim_losses').innerText = stats.losses;
            document.getElementById('sim_rate').innerText = total > 0 ? ((stats.wins/total)*100).toFixed(1) + '%' : '0%';
            const balEl = document.getElementById('sim_balance');
            balEl.innerText = `R$ ${stats.balance}`;
            balEl.style.color = stats.balance >= 0 ? '#00ff88' : '#ff0055';
            document.getElementById('sim_max_win').innerText = stats.maxWinStreak;
            document.getElementById('sim_max_loss').innerText = stats.maxLossStreak;

            updatePrediction(fullBlazeData);

            renderGaleDistributionChart(stats.winsDistribution, 'gale_distribution_chart_container');
            showGoldenHourStrategies();
            checkUnsavedChanges();
        }

        function calculateSimulation(strategy, galeLevel, simData, analyzeWhite = false, invertGale = false, confirmLvl = 2, pauseWin = 0, pauseLoss = 0, timePauseLossVal = 3) {
            if (!simData || simData.length === 0) return { wins: 0, losses: 0, balance: 0, balanceHistory: [0], winsDistribution: [0,0,0,0], maxWinStreak: 0, maxLossStreak: 0, entryHistory: [] };

            let wins = 0, losses = 0, balance = 0;
            const bet = 10; // Aposta fixa
            const balanceHistory = [0]; // Hist√≥rico para o gr√°fico
            let winsDistribution = [0, 0, 0, 0]; // G0, G1, G2, G3
            let currentWinStreak = 0, maxWinStreak = 0;
            let currentLossStreak = 0, maxLossStreak = 0;
            const entryHistory = [];
            let cooldownUntil = 0;

            // Helper interno para cores
            const getC = (r) => (r === 0) ? 'white' : ((r >= 1 && r <= 7) ? 'red' : 'black');

            // Helper para resolver cor (considerando toggle de branco)
            const getStratColor = (idx) => {
                if (idx < 0) return 'white';
                const r = simData[idx].roll;
                const c = getC(r);
                if (c === 'white' && analyzeWhite) {
                    let rC = 0, bC = 0;
                    for(let k=1; k<=5; k++) {
                        if(idx-k >= 0) {
                            const val = simData[idx-k].roll;
                            if(val >= 1 && val <= 7) rC++;
                            else if(val >= 8 && val <= 14) bC++;
                        }
                    }
                    return rC >= bC ? 'red' : 'black';
                }
                return c;
            };

            // Helper para verificar sequ√™ncia no hist√≥rico de simula√ß√£o
            const checkSimPattern = (idx, type, len) => {
                if (idx < len) return false; // Precisa de hist√≥rico anterior
                const first = getStratColor(idx - 1);
                if (first === 'white') return false;
                
                for (let k = 1; k < len; k++) {
                    const curr = getStratColor(idx - 1 - k);
                    if (type === 'follow' && curr !== first) return false;
                    if (type === 'alternating') {
                        const expected = (k % 2 === 0) ? first : (first === 'red' ? 'black' : 'red');
                        if (curr !== expected) return false;
                    }
                }
                return true;
            };

            for(let i=0; i<simData.length; i++) {
                const result = simData[i];

                let targetColor = null;
                let isCooldown = false;
                if (result.created_at) {
                    const currentTime = new Date(result.created_at).getTime();
                    if (currentTime < cooldownUntil) isCooldown = true;
                }

                if (!isCooldown) {
                    if (strategy === 'alternating') {
                        if (checkSimPattern(i, 'alternating', confirmLvl)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                        }
                    } else if (strategy === 'follow') {
                        if (checkSimPattern(i, 'follow', confirmLvl)) {
                            targetColor = getStratColor(i-1);
                        }
                    } else if (strategy === 'majority') {
                        if (i >= 5) {
                            let rCount = 0, bCount = 0;
                            for(let j=1; j<=5; j++) {
                                const c = getStratColor(i-j);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                            if (rCount >= bCount + 2) targetColor = 'red';
                            else if (bCount >= rCount + 2) targetColor = 'black';
                        }
                    } else if (strategy === 'ia_cores') {
                        // L√≥gica baseada na Previs√£o I.A. (Pontua√ß√£o Simplificada)
                        if (i >= 5) {
                            let redScore = 0, blackScore = 0;
                            const history = [];
                            for(let j=1; j<=5; j++) {
                                history.push(getStratColor(i-j));
                            }
                            // 1. Surf (3+)
                            if (history[0] === history[1] && history[1] === history[2]) {
                                if (history[0] === 'red') redScore += 2; else if (history[0] === 'black') blackScore += 2;
                            }
                            // 2. Xadrez (Altern√¢ncia)
                            if (history[0] !== history[1] && history[1] !== history[2]) {
                                if (history[0] === 'red') blackScore += 2; else if (history[0] === 'black') redScore += 2;
                            }
                            // 3. Maioria Recente
                            const rCount = history.filter(c => c === 'red').length;
                            const bCount = history.filter(c => c === 'black').length;
                            if (rCount > bCount) redScore += 1; else blackScore += 1;

                            if (redScore > blackScore) targetColor = 'red';
                            else if (blackScore > redScore) targetColor = 'black';
                        }
                    } else if (strategy === 'analise_cores') {
                        // L√≥gica H√≠brida (Surf se tend√™ncia, Xadrez se lateral)
                        if (checkSimPattern(i, 'follow', confirmLvl)) {
                            targetColor = getStratColor(i-1);
                        } else if (checkSimPattern(i, 'alternating', confirmLvl)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                            } else {
                                // Se houve branco recente, aposta na maioria dos √∫ltimos 5
                                if (i >= 5) {
                                    let rCount = 0, bCount = 0;
                                    for(let j=1; j<=5; j++) {
                                        const c = getStratColor(i-j);
                                        if (c === 'red') rCount++; else if (c === 'black') bCount++;
                                    }
                                    targetColor = rCount > bCount ? 'red' : 'black';
                                }
                            }
                    } else if (strategy === 'alignment') {
                        // Padr√£o Alinhamento: Segue a maioria dos √∫ltimos 20 (Tend√™ncia de M√©dio Prazo)
                        if (i >= 20) {
                            let rCount = 0, bCount = 0;
                            for(let j=1; j<=20; j++) {
                                const c = getStratColor(i-j);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                            if (rCount > bCount + 2) targetColor = 'red';
                            else if (bCount > rCount + 2) targetColor = 'black';
                        }
                    } else if (strategy === 'euler') {
                        // Onda de Euler: Tenta surfar na onda (Altern√¢ncia) ou na crista (Repeti√ß√£o)
                        if (checkSimPattern(i, 'alternating', confirmLvl)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                        } else if (checkSimPattern(i, 'follow', confirmLvl)) {
                            targetColor = getStratColor(i-1);
                        }
                    } else if (strategy === 'gauss') {
                        // Curva de Gauss: Maioria dos √∫ltimos 7 (Distribui√ß√£o Local)
                        if (i >= 7) {
                            let rCount = 0, bCount = 0;
                            for(let j=1; j<=7; j++) {
                                const c = getStratColor(i-j);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                            if (rCount >= bCount + 2) targetColor = 'red';
                            else if (bCount >= rCount + 2) targetColor = 'black';
                        }
                    } else if (strategy === 'fibonacci') {
                        // Fibonacci: Verifica posi√ß√µes 1, 2, 3, 5, 8, 13 atr√°s
                        const fibs = [1, 2, 3, 5, 8, 13];
                        let rCount = 0, bCount = 0;
                        fibs.forEach(fib => {
                            if (i >= fib) {
                                const c = getStratColor(i-fib);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                        });
                        if (rCount >= bCount + 1) targetColor = 'red';
                        else if (bCount >= rCount + 1) targetColor = 'black';
                    } else if (strategy === 'sniper') {
                        // Sniper: Revers√£o ap√≥s sequ√™ncia definida por confirmLvl
                        if (checkSimPattern(i, 'follow', confirmLvl)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                        }
                    } else if (strategy === 'olho_de_deus') {
                        if (i >= 100) {
                            let rCount = 0, bCount = 0;
                            for (let j = 1; j <= 100; j++) {
                                const c = getStratColor(i - j);
                                if (c === 'red') rCount++; else if (c === 'black') bCount++;
                            }
                            const diff = rCount - bCount;
                            if (diff >= 8) targetColor = 'black';
                            else if (diff <= -8) targetColor = 'red';
                            else {
                                let rShort = 0, bShort = 0;
                                for (let j = 1; j <= 10; j++) {
                                    const c = getStratColor(i - j);
                                    if (c === 'red') rShort++; else if (c === 'black') bShort++;
                                }
                                if (rShort > bShort + 2) targetColor = 'red';
                                else if (bShort > rShort + 2) targetColor = 'black';
                            }
                        }
                    } else if (strategy === 'ciclo_lunar') {
                        if (i >= 15) {
                            const pastColor = getStratColor(i - 15);
                            if (pastColor === 'red' || pastColor === 'black') targetColor = pastColor;
                        }
                    } else if (strategy === 'espelho_magico') {
                        if (i >= 10) {
                            const pastColor = getStratColor(i - 10);
                            if (pastColor === 'red') targetColor = 'black';
                            else if (pastColor === 'black') targetColor = 'red';
                        }
                    }
                    else if (strategy === 'fibonacci_sequence') {
                        if (i > 0) {
                            const fibs = [1, 2, 3, 5, 8, 13, 21];
                            let currentStreak = 1;
                            const lastColor = getStratColor(i - 1);

                            // Conta a sequ√™ncia da cor atual
                            for (let k = 2; k <= i; k++) {
                                if (getStratColor(i - k) === lastColor) {
                                    currentStreak++;
                                } else {
                                    break;
                                }
                            }
                            // Se o tamanho da sequ√™ncia for um n√∫mero de Fibonacci, aposta na cor oposta
                            if (fibs.includes(currentStreak)) targetColor = (lastColor === 'red' ? 'black' : 'red');
                        }
                    }
                    else if (strategy === 'mare_vermelha') {
                        if (i >= 3) {
                            if (getStratColor(i - 1) !== 'red' && getStratColor(i - 2) !== 'red' && getStratColor(i - 3) !== 'red') {
                                targetColor = 'red';
                            }
                        }
                    }
                    else if (strategy === 'vortex_numerico') {
                        if (i >= 4) {
                            const sum = simData[i-1].roll + simData[i-2].roll + simData[i-3].roll + simData[i-4].roll;
                            const vortexResult = sum % 15;
                            if (vortexResult >= 1 && vortexResult <= 7) targetColor = 'black';
                            else if (vortexResult >= 8 && vortexResult <= 14) targetColor = 'red';
                        }
                    }
                    else if (strategy === 'reversao_quantica') {
                        if (i >= 25) {
                            const historySlice = simData.slice(i - 25, i);
                            const lastSeenIndex = new Map();
                            historySlice.forEach((game, index) => {
                                lastSeenIndex.set(game.roll, index);
                            });

                            let coldestRoll = -1;
                            let minIndex = 25;

                            for (let num = 0; num <= 14; num++) {
                                if (lastSeenIndex.has(num)) {
                                    if (lastSeenIndex.get(num) < minIndex) {
                                        minIndex = lastSeenIndex.get(num);
                                        coldestRoll = num;
                                    }
                                } else {
                                    coldestRoll = num;
                                    break;
                                }
                            }

                            if (coldestRoll !== -1) {
                                const color = getC(coldestRoll);
                                if (color !== 'white') {
                                    targetColor = color;
                                }
                            }
                        }
                    }
                    else if (strategy === 'pulso_eletromagnetico') {
                        if (i >= 3 && simData[i-1].created_at) {
                            const minute = new Date(simData[i-1].created_at).getMinutes();
                            const c1 = getStratColor(i-1), c2 = getStratColor(i-2), c3 = getStratColor(i-3);
                            if (c1 !== 'white' && c2 !== 'white' && c3 !== 'white') {
                                const isTrending = (c1 === c2 && c2 === c3);
                                if (minute % 2 === 0) { // Par: Segue tend√™ncia
                                    if (isTrending) targetColor = c1;
                                } else { // √çmpar: Reverte tend√™ncia
                                    if (isTrending) targetColor = c1 === 'red' ? 'black' : 'red';
                                }
                            }
                        }
                    }
                    else if (strategy === 'cacador_de_zeros') {
                        if (i >= 20) {
                            let hasRed = false, hasBlack = false;
                            if (getStratColor(i-1) === 'red' || getStratColor(i-2) === 'red') hasRed = true;
                            if (getStratColor(i-1) === 'black' || getStratColor(i-2) === 'black') hasBlack = true;
                            
                            let whiteInLast20 = false;
                            for(let k=1; k<=20; k++) {
                                if (getStratColor(i-k) === 'white') {
                                    whiteInLast20 = true;
                                    break;
                                }
                            }
                            if (hasRed && hasBlack && !whiteInLast20) {
                                targetColor = 'white';
                            }
                        }
                    }
                    else if (strategy === 'sombra_do_branco') {
                        if (i >= 25) {
                            let whiteFound = false;
                            for (let k = 15; k <= 25; k++) {
                                if (i - k >= 0 && getC(simData[i - k].roll) === 'white') {
                                    whiteFound = true;
                                    break;
                                }
                            }
                            if (whiteFound) {
                                targetColor = 'white';
                            }
                        }
                    }
                    else if (strategy === 'convergencia_numerica') {
                        if (i >= 3) {
                            const rolls = [simData[i-1].roll, simData[i-2].roll, simData[i-3].roll];
                            rolls.sort((a, b) => a - b);
                            // Verifica se s√£o sequenciais
                            const isSequential = rolls[0] + 1 === rolls[1] && rolls[1] + 1 === rolls[2];
                            if (isSequential) {
                                targetColor = 'white';
                            }
                        }
                    }
                    else if (strategy === 'horario_do_branco') {
                        if (simData[i-1] && simData[i-1].created_at) {
                            const minute = new Date(simData[i-1].created_at).getMinutes();
                            if (minute > 0 && minute % 7 === 0) {
                                targetColor = 'white';
                            }
                        }
                    }
                     else if (strategy === 'olho_de_deus_90') {
                        // An√°lise de revers√£o √† m√©dia nas √∫ltimas 90 pedras
                        if (i >= 90) {
                            let rCount = 0, bCount = 0;
                            for (let j = 1; j <= 90; j++) {
                                const c = getStratColor(i - j);
                                if (c === 'red') rCount++;
                                else if (c === 'black') bCount++;
                            }
                    
                            const diff = rCount - bCount;
                            // Aposta na revers√£o se a diferen√ßa for significativa (ex: 10 ou mais)
                            if (diff >= 10) targetColor = 'black'; // Muitos vermelhos, aposta no preto
                            else if (diff <= -10) targetColor = 'red'; // Muitos pretos, aposta no vermelho
                        }
                    } else if (strategy === 'mhi_minoria') {
                        // MHI: Analisa as √∫ltimas 3 pedras e aposta na minoria
                        if (i >= 3) {
                            let rCount = 0, bCount = 0;
                            for (let j = 1; j <= 3; j++) {
                                const c = getStratColor(i - j);
                                if (c === 'red') rCount++;
                                else if (c === 'black') bCount++;
                            }
                            // Aposta na cor que saiu menos (Minoria)
                            if (rCount > bCount) targetColor = 'black';
                            else if (bCount > rCount) targetColor = 'red';
                        }
                    } else if (strategy === 'quebra_2x2') {
                        // Quebra de Padr√£o 2x2: Aposta na quebra do padr√£o V V P P ou P P V V
                        if (i >= 4) {
                            const c1 = getStratColor(i - 1); // Mais recente
                            const c2 = getStratColor(i - 2);
                            const c3 = getStratColor(i - 3);
                            const c4 = getStratColor(i - 4); // Mais antigo

                            // Padr√£o P P V V -> Aposta no V (red)
                            if (c1 === 'red' && c2 === 'red' && c3 === 'black' && c4 === 'black') {
                                targetColor = 'red';
                            }
                            // Padr√£o V V P P -> Aposta no P (black)
                            else if (c1 === 'black' && c2 === 'black' && c3 === 'red' && c4 === 'red') {
                                targetColor = 'black';
                            }
                        }
                    } else if (strategy === 'eco_passado') {
                        // Eco do Passado: Aposta na cor mais frequente que se seguiu ao √∫ltimo n√∫mero.
                        if (i > 0) { // Precisa de pelo menos um n√∫mero anterior para ser o gatilho.
                            const triggerNumber = simData[i-1].roll;

                            let redFollowers = 0;
                            let blackFollowers = 0;
                            let occurrences = 0;

                            // Analisa o hist√≥rico at√© o ponto atual (i-1)
                            for (let j = 0; j < i - 1; j++) {
                                if (simData[j].roll === triggerNumber) {
                                    occurrences++;
                                    // O roll que veio depois do gatilho no passado
                                    const followerRoll = simData[j + 1].roll;
                                    const followerColor = getC(followerRoll);
                                    
                                    if (followerColor === 'red') redFollowers++;
                                    else if (followerColor === 'black') blackFollowers++;
                                }
                            }

                            // Aposta apenas se houver um hist√≥rico m√≠nimo (3) e um vencedor claro (diferen√ßa de 2)
                            if (occurrences >= 3) {
                                if (redFollowers >= blackFollowers + 2) targetColor = 'red';
                                else if (blackFollowers >= redFollowers + 2) targetColor = 'black';
                            }
                        }
                    } else if (strategy === 'padrao_espelhado') {
                        // Padr√£o Espelhado: V P V -> aposta V, P V P -> aposta P
                        if (i >= 3) {
                            const c1 = getStratColor(i - 1); // Mais recente
                            const c2 = getStratColor(i - 2);
                            const c3 = getStratColor(i - 3); // Mais antigo

                            // Verifica se o padr√£o √© X Y X (e n√£o X X X)
                            if (c1 === c3 && c1 !== c2) {
                                targetColor = c1; // Aposta na cor das pontas
                            }
                        }
                    } else if (strategy === 'mare_minutos') {
                        // Analisa os minutos dos √∫ltimos 15 rolls
                        if (i >= 15) {
                            let firstHalf = 0, secondHalf = 0;
                            let redCount = 0, blackCount = 0;

                            for (let j = 1; j <= 15; j++) {
                                const game = simData[i - j];
                                if (game && game.created_at) {
                                    const minute = new Date(game.created_at).getMinutes();
                                    if (minute < 30) firstHalf++;
                                    else secondHalf++;
                                }
                                const c = getStratColor(i - j);
                                if (c === 'red') redCount++;
                                else if (c === 'black') blackCount++;
                            }

                            if (firstHalf > secondHalf + 3) { // Maioria na primeira metade da hora -> segue tend√™ncia
                                if (redCount > blackCount) targetColor = 'red';
                                else if (blackCount > redCount) targetColor = 'black';
                            } 
                            else if (secondHalf > firstHalf + 3) { // Maioria na segunda metade -> aposta na revers√£o
                                if (redCount < blackCount) targetColor = 'red';
                                else if (blackCount < redCount) targetColor = 'black';
                            }
                        }
                    } else if (strategy === 'sincronia_horaria') {
                        // Aposta na cor que mais saiu historicamente no minuto atual
                        if (i > 0 && simData[i].created_at) {
                            const currentMinute = new Date(simData[i].created_at).getMinutes();
                            let redCount = 0, blackCount = 0, occurrences = 0;

                            for (let j = 0; j < i; j++) {
                                if (simData[j].created_at && new Date(simData[j].created_at).getMinutes() === currentMinute) {
                                    occurrences++;
                                    const c = getStratColor(j);
                                    if (c === 'red') redCount++; else if (c === 'black') blackCount++;
                                }
                            }
                            // Aposta se houver hist√≥rico (3+) e uma tend√™ncia clara (diferen√ßa de 2)
                            if (occurrences >= 3) {
                                if (redCount >= blackCount + 2) targetColor = 'red';
                                else if (blackCount >= redCount + 2) targetColor = 'black';
                            }
                        }
                    } else if (strategy === 'inercia_newton') {
                        // In√©rcia: Se 6 cores iguais seguidas, aposta na continua√ß√£o.
                        if (i >= 6) {
                            const last = getStratColor(i-1);
                            let streak = 1;
                            for(let k=2; k<=6; k++) {
                                if(getStratColor(i-k) === last) streak++; else break;
                            }
                            if(streak >= 6) targetColor = last;
                        }
                    } else if (strategy === 'reacao_newton') {
                        // Rea√ß√£o: Desequil√≠brio extremo nos √∫ltimos 20 (>=15 de uma cor).
                        if (i >= 20) {
                            let r=0, b=0;
                            for(let k=1; k<=20; k++) {
                                const c = getStratColor(i-k);
                                if(c==='red') r++; else if(c==='black') b++;
                            }
                            if (r >= 15) targetColor = 'black';
                            else if (b >= 15) targetColor = 'red';
                        }
                    } else if (strategy === 'entropia_caos') {
                        // Entropia: Quebra de padr√£o perfeito (Xadrez de 6).
                        if (checkSimPattern(i, 'alternating', 6)) {
                            targetColor = getStratColor(i-1); // Aposta na repeti√ß√£o da √∫ltima
                        }
                    }
                    else if (strategy === 'soma_dragao') {
                        // Soma do Drag√£o: Soma 3 √∫ltimos. √çmpar=Red, Par=Black. Valida√ß√£o: 4 hits.
                        if (i >= 7) {
                            let consistent = true;
                            for (let k = 1; k <= 4; k++) {
                                let sum = 0;
                                for (let m = 1; m <= 3; m++) sum += simData[i - k - m].roll;
                                let predicted = (sum % 2 !== 0) ? 'red' : 'black';
                                if (getStratColor(i - k) !== predicted) { consistent = false; break; }
                            }
                            if (consistent) {
                                let currentSum = 0;
                                for (let m = 1; m <= 3; m++) currentSum += simData[i - m].roll;
                                targetColor = (currentSum % 2 !== 0) ? 'red' : 'black';
                            }
                        }
                    } else if (strategy === 'codigo_muralha') {
                        // C√≥digo da Muralha: Soma 2 √∫ltimos. >14 Black, <=14 Red. Valida√ß√£o: 4 hits.
                        if (i >= 6) {
                            let consistent = true;
                            for (let k = 1; k <= 4; k++) {
                                let sum = simData[i - k - 1].roll + simData[i - k - 2].roll;
                                let predicted = (sum > 14) ? 'black' : 'red';
                                if (getStratColor(i - k) !== predicted) { consistent = false; break; }
                            }
                            if (consistent) {
                                let currentSum = simData[i - 1].roll + simData[i - 2].roll;
                                targetColor = (currentSum > 14) ? 'black' : 'red';
                            }
                        }
                    } else if (strategy === 'lotus_dourada') {
                        // L√≥tus Dourada: Soma 5 √∫ltimos. Final 0-4 Red, 5-9 Black. Valida√ß√£o: 4 hits.
                        if (i >= 9) {
                            let consistent = true;
                            for (let k = 1; k <= 4; k++) {
                                let sum = 0;
                                for (let m = 1; m <= 5; m++) sum += simData[i - k - m].roll;
                                let predicted = (sum % 10 <= 4) ? 'red' : 'black';
                                if (getStratColor(i - k) !== predicted) { consistent = false; break; }
                            }
                            if (consistent) {
                                let currentSum = 0;
                                for (let m = 1; m <= 5; m++) currentSum += simData[i - m].roll;
                                targetColor = (currentSum % 10 <= 4) ? 'red' : 'black';
                            }
                        }
                    } else if (strategy === 'yin_yang') {
                        // Yin Yang: Soma todo o hist√≥rico dispon√≠vel (at√© 100). Se primo, inverte.
                        if (i >= 1) {
                            let sum = 0;
                            const limit = Math.min(i, 100);
                            for (let k = 1; k <= limit; k++) {
                                sum += simData[i - k].roll;
                            }
                            if (isPrime(sum)) {
                                const lastColor = getStratColor(i - 1);
                                if (lastColor === 'red') targetColor = 'black';
                                else if (lastColor === 'black') targetColor = 'red';
                            }
                        }
                    } else if (strategy === 'caos_ordem') {
                        // Caos e Ordem: Alterna comportamento a cada 10 rodadas (0-9, 10-19...)
                        if (i > 0) {
                            const phase = Math.floor(i / 10) % 2;
                            const lastColor = getStratColor(i - 1);
                            if (phase === 0) {
                                targetColor = lastColor;
                            } else {
                                if (lastColor === 'red') targetColor = 'black';
                                else if (lastColor === 'black') targetColor = 'red';
                            }
                        }
                    } else if (strategy === 'guardiao_real') {
                        if (checkSimPattern(i, 'follow', 8)) {
                            const last = getStratColor(i-1);
                            targetColor = (last === 'red' ? 'black' : 'red');
                        }
                    } else if (strategy === 'estrela_cadente') {
                        if (checkSimPattern(i, 'alternating', 6)) {
                            targetColor = getStratColor(i-1);
                        }
                    } else if (strategy === 'horizonte_eventos') {
                        if (i >= 3) {
                            const sum = simData[i-1].roll + simData[i-2].roll + simData[i-3].roll;
                            if (sum > 30) targetColor = 'red';
                            else if (sum < 10) targetColor = 'black';
                        }
                    }
                    else if (strategy === 'anomalia_temporal_b') {
                        if (i >= 50 && getC(simData[i - 50].roll) === 'white') {
                            targetColor = 'white';
                        }
                    }
                    else if (strategy === 'eco_numerico_b') {
                        if (i >= 3) {
                            const r1 = simData[i-1].roll;
                            const r2 = simData[i-2].roll;
                            const r3 = simData[i-3].roll;
                            if (r1 !== 0 && r1 === r2 && r2 === r3) {
                                targetColor = 'white';
                            }
                        }
                    }
                    else if (strategy === 'vacuo_de_cor_b') {
                        if (i >= 50) {
                            let whiteInLast50 = false;
                            for (let k = 1; k <= 50; k++) {
                                if (getC(simData[i - k].roll) === 'white') {
                                    whiteInLast50 = true;
                                    break;
                                }
                            }
                            if (!whiteInLast50) {
                                targetColor = 'white';
                            }
                        }
                    }
                    else if (strategy === 'sincronicidade_primos_b') {
                        if (i > 1) {
                            const lastRoll = simData[i-1].roll;
                            if (isPrime(lastRoll)) {
                                let roundsSinceWhite = 0;
                                let whiteFound = false;
                                for (let k = 2; k <= i; k++) {
                                    roundsSinceWhite++;
                                    if (getC(simData[i - k].roll) === 'white') {
                                        whiteFound = true;
                                        break;
                                    }
                                }
                                if (whiteFound && isPrime(roundsSinceWhite)) {
                                    targetColor = 'white';
                                }
                            }
                        }
                    }
                }

                if (targetColor) {
                    if (targetColor === 'white') {
                        // Aposta no branco n√£o usa gale.
                        const resultColor = getC(result.roll);
                        if (resultColor === 'white') {
                            wins++;
                            balance += bet * 13; // Payout de 14x, lucro de 13x a aposta
                            winsDistribution[0]++; // Contabiliza como Win Direto
                            currentWinStreak++;
                            currentLossStreak = 0;
                            if(currentWinStreak > maxWinStreak) maxWinStreak = currentWinStreak;
                            entryHistory.push('win');
                            if (pauseWin > 0) i += pauseWin;
                        } else {
                            losses++;
                            balance -= bet; // Perde apenas a aposta inicial
                            currentLossStreak++;
                            currentWinStreak = 0;
                            if(currentLossStreak > maxLossStreak) maxLossStreak = currentLossStreak;
                            entryHistory.push('loss');
                            if (pauseLoss > 0) i += pauseLoss;
                            if (timePauseLossVal > 0 && result.created_at) {
                                const currentTime = new Date(result.created_at).getTime();
                                cooldownUntil = currentTime + timePauseLossVal * 60 * 1000;
                            }
                        }
                        balanceHistory.push(balance);
                        continue; // Pula para a pr√≥xima rodada da simula√ß√£o principal
                    }

                    let currentBet = bet;
                    let totalLoss = 0;
                    let wonSequence = false;
                    let stepsTaken = 0;

                    // Loop para tentar ganhar na rodada atual ou nos gales subsequentes
                    for (let g = 0; g <= galeLevel; g++) {
                        // Verifica se temos dados futuros suficientes
                        if (i + g >= simData.length) {
                            // Sem dados para completar o gale, encerra como perda do acumulado
                            break;
                        }

                        const stepResult = simData[i + g];
                        const stepR = stepResult.roll;
                        let stepColor = 'white';
                        if (stepR >= 1 && stepR <= 7) stepColor = 'red';
                        else if (stepR >= 8 && stepR <= 14) stepColor = 'black';

                        // L√ìGICA DE GALE:
                        // Mant√©m a mesma cor da estrat√©gia original (targetColor) ap√≥s um Loss,
                        // garantindo a persist√™ncia da estrat√©gia durante o Gale.
                        let effectiveTarget = targetColor;
                        if (g > 0 && invertGale) {
                            effectiveTarget = (targetColor === 'red' ? 'black' : 'red');
                        }

                        // Verifica Vit√≥ria (Cor Alvo ou Branco Prote√ß√£o)
                        if (stepColor === effectiveTarget || stepColor === 'white') {
                            wonSequence = true;
                            stepsTaken = g;
                            break;
                        }

                        // Se perdeu essa etapa
                        totalLoss += currentBet;
                        currentBet *= 2; // Martingale: dobra a aposta
                        stepsTaken = g;
                    }

                    if (wonSequence) {
                        wins++;
                        balance += bet; // Recupera perdas e lucra a aposta base
                        if (stepsTaken < 4) winsDistribution[stepsTaken]++;
                        
                        currentWinStreak++;
                        currentLossStreak = 0;
                        if(currentWinStreak > maxWinStreak) maxWinStreak = currentWinStreak;
                        entryHistory.push('win');
                    } else {
                        losses++;
                        balance -= totalLoss;
                        
                        currentLossStreak++;
                        currentWinStreak = 0;
                        if(currentLossStreak > maxLossStreak) maxLossStreak = currentLossStreak;
                        entryHistory.push('loss');
                    }

                    let appliedPause = false;
                    if (wonSequence && pauseWin > 0) { i += pauseWin; appliedPause = true; }
                    else if (!wonSequence && pauseLoss > 0) { i += pauseLoss; appliedPause = true; }

                    if (!appliedPause) {
                        // Cooldown: 2 min para Win, 3 min para Loss (Padr√£o)
                        const lastGameIndex = i + stepsTaken;
                        if (lastGameIndex < simData.length && simData[lastGameIndex].created_at) {
                            const lastGameTime = new Date(simData[lastGameIndex].created_at).getTime();
                            cooldownUntil = lastGameTime + (wonSequence ? 2 : timePauseLossVal) * 60 * 1000;
                        }
                    }
                    
                    // Avan√ßa o √≠ndice principal pelos passos de gale utilizados
                    i += stepsTaken;
                }
                balanceHistory.push(balance);
            }
            
            return { wins, losses, balance, balanceHistory, winsDistribution, maxWinStreak, maxLossStreak, entryHistory };
        }

        function analyzeSequences(data) {
            if (!data || data.length < 2) return;

            // 1. An√°lise P√≥s-N√∫mero (O que vem depois do √∫ltimo resultado)
            const lastRoll = data[0].roll;
            const lastColor = (lastRoll === 0) ? 'white' : ((lastRoll >= 1 && lastRoll <= 7) ? 'red' : 'black');
            const lastColorHex = (lastColor === 'red') ? '#ff0055' : ((lastColor === 'white') ? '#fff' : '#888');
            
            const displayEl = document.getElementById('last_number_display');
            if(displayEl) {
                displayEl.innerText = lastRoll;
                displayEl.style.color = lastColorHex;
                displayEl.style.textShadow = lastColor === 'white' ? '0 0 5px #fff' : 'none';
            }

            const followingCounts = Array(15).fill(0);
            let totalOccurrences = 0;

            // data[i] √© o gatilho. O resultado seguinte no tempo √© data[i-1] (pois a lista √© Newest->Oldest)
            for (let i = 1; i < data.length; i++) {
                if (data[i].roll === lastRoll) {
                    const nextResult = data[i-1];
                    followingCounts[nextResult.roll]++;
                    totalOccurrences++;
                }
            }

            if (totalOccurrences > 0) {
                const topFollowing = followingCounts
                    .map((count, num) => ({ num, count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3);
                
                let html = '<div style="display:flex; gap:15px; justify-content:center; width:100%;">';
                topFollowing.forEach(item => {
                    if (item.count > 0) {
                        const pct = Math.round((item.count / totalOccurrences) * 100);
                        const c = (item.num === 0) ? 'white' : ((item.num >= 1 && item.num <= 7) ? 'red' : 'black');
                        const bg = (c === 'red') ? '#ff0055' : ((c === 'white') ? '#fff' : '#333');
                        const fg = (c === 'white') ? '#000' : '#fff';
                        html += `
                            <div style="text-align:center;">
                                <div style="background:${bg}; color:${fg}; width:35px; height:35px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; margin:0 auto; border: 1px solid #444;">${item.num}</div>
                                <div style="font-size:0.75rem; color:#888; margin-top:4px;">${pct}%</div>
                            </div>
                        `;
                    }
                });
                html += '</div>';
                
                // Barra de distribui√ß√£o de cores p√≥s-n√∫mero
                let r=0, b=0, w=0;
                followingCounts.forEach((count, num) => {
                    if (num === 0) w += count;
                    else if (num >= 1 && num <= 7) r += count;
                    else b += count;
                });
                const total = r+b+w;
                html += `<div style="margin-top:15px; width:100%;"><div style="display:flex; height:6px; border-radius:3px; overflow:hidden; width:100%;">
                    <div style="width:${(r/total)*100}%; background:#ff0055;"></div>
                    <div style="width:${(w/total)*100}%; background:#fff;"></div>
                    <div style="width:${(b/total)*100}%; background:#333;"></div>
                </div>
                <div style="display:flex; justify-content:space-between; font-size:0.65rem; color:#aaa; margin-top:2px;">
                    <span>üî¥ ${Math.round((r/total)*100)}%</span>
                    <span>‚ö™ ${Math.round((w/total)*100)}%</span>
                    <span>‚ö´ ${Math.round((b/total)*100)}%</span>
                </div></div>`;

                document.getElementById('post_number_stats').innerHTML = html;
                document.getElementById('post_number_stats').style.flexDirection = 'column';
            } else {
                document.getElementById('post_number_stats').innerHTML = '<div style="text-align:center; color:#666;">Sem hist√≥rico suficiente para este n√∫mero.</div>';
            }

            // 2. Gatilhos do Branco (N√∫meros que antecedem o 0)
            const triggerCounts = Array(15).fill(0);
            let totalWhites = 0;

            // data[i] == 0. O n√∫mero anterior no tempo √© data[i+1].
            for (let i = 0; i < data.length - 1; i++) {
                if (data[i].roll === 0) {
                    const prevResult = data[i+1];
                    triggerCounts[prevResult.roll]++;
                    totalWhites++;
                }
            }

            if (totalWhites > 0) {
                const topTriggers = triggerCounts
                    .map((count, num) => ({ num, count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3);

                let html = '<div style="display:flex; gap:15px; justify-content:center;">';
                topTriggers.forEach(item => {
                    if (item.count > 0) {
                        const c = (item.num === 0) ? 'white' : ((item.num >= 1 && item.num <= 7) ? 'red' : 'black');
                        const bg = (c === 'red') ? '#ff0055' : ((c === 'white') ? '#fff' : '#333');
                        const fg = (c === 'white') ? '#000' : '#fff';
                        html += `
                            <div style="text-align:center;">
                                <div style="background:${bg}; color:${fg}; width:35px; height:35px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; margin:0 auto; border: 1px solid #444;">${item.num}</div>
                                <div style="font-size:0.75rem; color:#888; margin-top:4px;">${item.count}x</div>
                            </div>
                        `;
                    }
                });
                html += '</div>';
                document.getElementById('white_triggers_stats').innerHTML = html;
            } else {
                document.getElementById('white_triggers_stats').innerHTML = '<div style="text-align:center; color:#666;">Nenhum branco no hist√≥rico recente.</div>';
            }
        }

        function renderPieChart(data) {
            const container = document.getElementById('pie_chart_container');
            if (!container || !data || data.length === 0) return;

            let red = 0, black = 0, white = 0;
            data.forEach(game => {
                const r = game.roll;
                if (r === 0) white++;
                else if (r >= 1 && r <= 7) red++;
                else if (r >= 8 && r <= 14) black++;
            });
            const total = red + black + white;
            
            if (total === 0) return;

            const pRed = (red / total) * 100;
            const pBlack = (black / total) * 100;
            const pWhite = (white / total) * 100;

            const size = window.innerWidth <= 768 ? 120 : 160;
            const strokeWidth = 12;
            const radius = (size - strokeWidth) / 2;
            const circumference = 2 * Math.PI * radius;
            const cx = size / 2;
            const cy = size / 2;

            const dashRed = (pRed / 100) * circumference;
            const dashBlack = (pBlack / 100) * circumference;
            const dashWhite = (pWhite / 100) * circumference;

            const offsetRed = 0;
            const offsetBlack = -dashRed;
            const offsetWhite = -(dashRed + dashBlack);

            const svg = `
                <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="transform: rotate(-90deg);">
                    <circle cx="${cx}" cy="${cy}" r="${radius}" fill="none" stroke="#ff0055" stroke-width="${strokeWidth}" stroke-dasharray="${dashRed} ${circumference - dashRed}" stroke-dashoffset="${offsetRed}" style="transition: stroke-dasharray 0.5s ease-out; filter: drop-shadow(0 0 5px #ff0055);" />
                    <circle cx="${cx}" cy="${cy}" r="${radius}" fill="none" stroke="#333" stroke-width="${strokeWidth}" stroke-dasharray="${dashBlack} ${circumference - dashBlack}" stroke-dashoffset="${offsetBlack}" style="transition: stroke-dasharray 0.5s ease-out;" />
                    <circle cx="${cx}" cy="${cy}" r="${radius}" fill="none" stroke="#fff" stroke-width="${strokeWidth}" stroke-dasharray="${dashWhite} ${circumference - dashWhite}" stroke-dashoffset="${offsetWhite}" style="transition: stroke-dasharray 0.5s ease-out; filter: drop-shadow(0 0 8px #fff);" />
                </svg>
                <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 8px; font-size: 0.85rem;">
                    <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 10px; height: 10px; background: #ff0055; border-radius: 50%; box-shadow: 0 0 5px #ff0055;"></span> Vermelho: <b style="color: #ff0055;">${pRed.toFixed(1)}%</b></div>
                    <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 10px; height: 10px; background: #333; border: 1px solid #555; border-radius: 50%;"></span> Preto: <b style="color: #aaa;">${pBlack.toFixed(1)}%</b></div>
                    <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 10px; height: 10px; background: #fff; border-radius: 50%; box-shadow: 0 0 5px #fff;"></span> Branco: <b style="color: #fff;">${pWhite.toFixed(1)}%</b></div>
                </div>
            `;
            container.innerHTML = svg;
        }

        function renderPeriodComparison(data) {
            const containerRecent = document.getElementById('comp_recent_stats');
            const containerOld = document.getElementById('comp_old_stats');
            const msg = document.getElementById('comp_message');
            
            if (!containerRecent || !containerOld) return;

            if (!data || data.length < 50) {
                msg.innerText = "Dados insuficientes para compara√ß√£o (M√≠nimo 50 jogos na sele√ß√£o).";
                containerRecent.innerHTML = '';
                containerOld.innerHTML = '';
                return;
            }
            msg.innerText = "";

            // data is sorted Newest -> Oldest
            const recentData = data.slice(0, 50);
            const oldData = data.slice(-50); 

            const calculateStats = (subset) => {
                let r = 0, b = 0, w = 0;
                subset.forEach(g => {
                    if (g.roll === 0) w++;
                    else if (g.roll >= 1 && g.roll <= 7) r++;
                    else b++;
                });
                const total = subset.length;
                return {
                    rPct: ((r/total)*100).toFixed(1),
                    bPct: ((b/total)*100).toFixed(1),
                    wPct: ((w/total)*100).toFixed(1)
                };
            };

            const recentStats = calculateStats(recentData);
            const oldStats = calculateStats(oldData);

            const generateHTML = (stats) => `
                <div style="display: flex; flex-direction: column; gap: 6px; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between;"><span style="color: #ff0055;">Vermelho</span><span>${stats.rPct}%</span></div>
                    <div style="width: 100%; height: 4px; background: #333; border-radius: 2px;"><div style="width: ${stats.rPct}%; background: #ff0055; height: 100%; border-radius: 2px;"></div></div>
                    
                    <div style="display: flex; justify-content: space-between;"><span style="color: #aaa;">Preto</span><span>${stats.bPct}%</span></div>
                    <div style="width: 100%; height: 4px; background: #333; border-radius: 2px;"><div style="width: ${stats.bPct}%; background: #888; height: 100%; border-radius: 2px;"></div></div>

                    <div style="display: flex; justify-content: space-between;"><span style="color: #fff;">Branco</span><span>${stats.wPct}%</span></div>
                    <div style="width: 100%; height: 4px; background: #333; border-radius: 2px;"><div style="width: ${stats.wPct}%; background: #fff; height: 100%; border-radius: 2px;"></div></div>
                </div>
            `;

            containerRecent.innerHTML = generateHTML(recentStats);
            containerOld.innerHTML = generateHTML(oldStats);
        }

        function addToPattern(color) {
            customPattern.push(color);
            updatePatternDisplay();
            checkPattern();
        }

        function clearPattern() {
            customPattern = [];
            updatePatternDisplay();
            document.getElementById('pattern_alert_status').innerHTML = '';
        }

        function updatePatternDisplay() {
            const container = document.getElementById('custom_pattern_display');
            container.innerHTML = customPattern.map(c => {
                let colorClass = c === 'red' ? 'seq-red' : (c === 'black' ? 'seq-black' : 'seq-white');
                let label = c === 'red' ? 'V' : (c === 'black' ? 'P' : 'B');
                return `<div class="seq-badge ${colorClass}" style="width: 25px; height: 25px; font-size: 0.7rem;">${label}</div>`;
            }).join('');
        }

        function checkPattern() {
            if (customPattern.length === 0 || !fullBlazeData || fullBlazeData.length < customPattern.length) return;
            
            let match = true;
            for(let i=0; i<customPattern.length; i++) {
                const patternColor = customPattern[customPattern.length - 1 - i];
                const result = fullBlazeData[i];
                const r = result.roll;
                let resultColor = (r === 0) ? 'white' : ((r >= 1 && r <= 7) ? 'red' : 'black');
                
                if (patternColor !== resultColor) { match = false; break; }
            }
            
            const statusEl = document.getElementById('pattern_alert_status');
            statusEl.innerHTML = match ? '<span style="color: #00ff88; animation: pulse-text 1s infinite;">‚úÖ PADR√ÉO ENCONTRADO AGORA!</span>' : '<span style="color: #666;">Aguardando padr√£o...</span>';
        }

        function renderScatterChart(data) {
            const container = document.getElementById('scatter_chart_container');
            if (!container || !data || data.length === 0) return;

            const width = 800; 
            const height = 200 * chartScale;
            container.style.height = height + 'px';
            const padding = 30;

            let circles = '';
            
            data.forEach(game => {
                if (!game.created_at) return;
                const date = new Date(game.created_at);
                const minute = date.getMinutes();
                const seconds = date.getSeconds();
                const exactMinute = minute + (seconds / 60);
                const roll = game.roll;
                
                const x = padding + (exactMinute / 60) * (width - 2 * padding);
                const y = height - padding - (roll / 14) * (height - 2 * padding);
                
                let color = '#fff'; 
                if (roll >= 1 && roll <= 7) color = '#ff0055'; 
                else if (roll >= 8 && roll <= 14) color = '#888'; 
                
                circles += `<circle cx="${x}" cy="${y}" r="3" fill="${color}" opacity="0.7"><title>${minute}m ${seconds}s: ${roll}</title></circle>`;
            });

            const svg = `
                <svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 100%; overflow: visible; background: rgba(0,0,0,0.2); border-radius: 4px;">
                    <text x="${padding - 5}" y="${height - padding}" fill="#666" font-size="10" text-anchor="end">0</text>
                    <text x="${padding - 5}" y="${height/2}" fill="#666" font-size="10" text-anchor="end">7</text>
                    <text x="${padding - 5}" y="${padding + 5}" fill="#666" font-size="10" text-anchor="end">14</text>
                    ${[0, 10, 20, 30, 40, 50, 60].map(m => {
                        const xPos = padding + (m / 60) * (width - 2 * padding);
                        return `<text x="${xPos}" y="${height - 5}" fill="#666" font-size="10" text-anchor="middle">${m}m</text><line x1="${xPos}" y1="${padding}" x2="${xPos}" y2="${height - padding}" stroke="#333" stroke-dasharray="2" opacity="0.3" />`;
                    }).join('')}
                    ${circles}
                </svg>
            `;
            container.innerHTML = svg;
        }

        function updateTrendIndicator(points) {
            const indicator = document.getElementById('trend_strength_indicator');
            if (!indicator || !points || points.length === 0) return;

            // Analisa os √∫ltimos 20 pontos para determinar a tend√™ncia recente
            const lookback = Math.min(points.length, 20);
            const recentPoints = points.slice(-lookback);
            const startVal = recentPoints[0];
            const endVal = recentPoints[recentPoints.length - 1];
            const diff = endVal - startVal;

            let text = "LATERAL";
            let color = "#aaa";
            let bg = "rgba(255,255,255,0.1)";
            let icon = "‚û°Ô∏è";

            if (diff >= 5) { text = "ALTA FORTE"; color = "#00ff88"; bg = "rgba(0, 255, 136, 0.2)"; icon = "üöÄ"; }
            else if (diff >= 2) { text = "ALTA"; color = "#00ff88"; bg = "rgba(0, 255, 136, 0.1)"; icon = "‚ÜóÔ∏è"; }
            else if (diff <= -5) { text = "BAIXA FORTE"; color = "#ff0055"; bg = "rgba(255, 0, 85, 0.2)"; icon = "üìâ"; }
            else if (diff <= -2) { text = "BAIXA"; color = "#ff0055"; bg = "rgba(255, 0, 85, 0.1)"; icon = "‚ÜòÔ∏è"; }

            indicator.innerHTML = `${icon} ${text}`;
            indicator.style.color = color;
            indicator.style.background = bg;
            indicator.style.border = `1px solid ${color}`;
        }

        function renderGaleDistributionChart(counts, containerId) {
            const container = document.getElementById(containerId);
            if (!container || !counts) return;

            const labels = ['Win Direto', 'Gale 1', 'Gale 2', 'Gale 3'];
            const colors = ['#00ff88', '#ccff00', '#ff9800', '#ff0055'];
            const maxCount = Math.max(...counts, 1);
            const width = container.clientWidth || 500;
            const height = 120;
            const barWidth = (width / 4) - 20;
            const padding = 10;

            let svgContent = '';

            counts.forEach((count, index) => {
                if (index >= 4) return;
                
                const barHeight = (count / maxCount) * (height - 30);
                const x = padding + index * (width / 4) + 10;
                const y = height - barHeight - 20;
                
                // S√≥ desenha se houver contagem ou para manter o label
                const opacity = count > 0 ? 0.8 : 0.2;
                
                svgContent += `
                    <rect x="${x}" y="${y}" width="${barWidth}" height="${Math.max(barHeight, 2)}" fill="${colors[index]}" fill-opacity="${opacity}" rx="4">
                        <title>${labels[index]}: ${count}</title>
                    </rect>
                    <text x="${x + barWidth/2}" y="${height - 5}" font-size="10" fill="#aaa" text-anchor="middle">${labels[index]}</text>
                    ${count > 0 ? `<text x="${x + barWidth/2}" y="${y - 5}" font-size="11" fill="#fff" font-weight="bold" text-anchor="middle">${count}</text>` : ''}
                `;
            });

            container.innerHTML = `<svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 100%; overflow: visible;">${svgContent}</svg>`;
        }

        function renderEntryHistory(history) {
            const container = document.getElementById('entry_history_container');
            if (!container) return;
            
            const last20 = history ? history.slice(-20) : [];
            
            let html = '';
            if (last20.length === 0) {
                html = '<span style="color: #444; font-size: 0.8rem;">--</span>';
            } else {
                last20.forEach(result => {
                    const color = result === 'win' ? '#00ff88' : '#ff0055';
                    const shadow = result === 'win' ? '0 0 8px rgba(0, 255, 136, 0.6)' : '0 0 8px rgba(255, 0, 85, 0.6)';
                    html += `<div style="width: 10px; height: 10px; border-radius: 50%; background: ${color}; box-shadow: ${shadow}; margin: 2px;" title="${result.toUpperCase()}"></div>`;
                });
            }
            container.innerHTML = html;
        }

        function triggerStrategyChangeAlert() {
            const select = document.getElementById('sim_strategy');
            select.classList.remove('blink-alert');
            void select.offsetWidth; // Trigger reflow
            select.classList.add('blink-alert');
        }

        function showGoldenHourStrategies() {
            const container = document.getElementById('golden_hour_results');
            if (!container) return;
            
            if (!fullBlazeData || fullBlazeData.length === 0) return;

            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            
            const lastHourData = [];
            for (const game of fullBlazeData) {
                if (new Date(game.created_at) >= oneHourAgo) {
                    lastHourData.push(game);
                } else {
                    break; 
                }
            }

            if (lastHourData.length < 10) {
                container.innerHTML = '<div style="text-align: center; color: #aaa; padding: 10px;">Dados insuficientes na √∫ltima hora.</div>';
                return;
            }

            const simData = [...lastHourData].reverse();
            const galeLevel = document.getElementById('gale_active_toggle')?.checked ? 1 : 0;
            const select = document.getElementById('sim_strategy');
            const analyzeWhite = document.getElementById('analyze_white_toggle')?.checked || false;
            const invertGale = document.getElementById('gale_invert_toggle')?.checked || false;
            
            let html = '<div style="background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 6px; padding: 10px;">';
            html += '<div style="color: #ffd700; font-weight: bold; margin-bottom: 8px; text-align: center;">üèÜ Estrat√©gias > 80% (√öltima Hora)</div>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">';

            let found = false;
            for (let i = 0; i < select.options.length; i++) {
                const strategy = select.options[i].value;
                const name = select.options[i].text;
                const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationLevel, pauseWinCount, pauseLossCount, timePauseLoss);
                const total = stats.wins + stats.losses;
                
                if (total > 0) {
                    const rate = (stats.wins / total) * 100;
                    if (rate >= 80) {
                        found = true;
                        html += `<div onclick="selectStrategy('${strategy}')" style="cursor: pointer; background: rgba(0,0,0,0.4); padding: 5px 10px; border-radius: 4px; border: 1px solid #ffd700; font-size: 0.8rem; color: #fff; transition: all 0.2s;">${name}: <span style="color: #00ff88; font-weight: bold;">${rate.toFixed(0)}%</span></div>`;
                    }
                }
            }

            if (!found) html += '<div style="color: #aaa; font-size: 0.8rem;">Nenhuma estrat√©gia atingiu 80% na √∫ltima hora.</div>';
            html += '</div></div>';
            container.innerHTML = html;
        }

        function selectStrategy(val) {
            const select = document.getElementById('sim_strategy');
            select.value = val;
            handleStrategyChange();
        }

        function runSimulation2(skipBestCheck = false, isAutoUpdate = false) {
            if (!fullBlazeData || fullBlazeData.length === 0) return;

            if (!skipBestCheck) {
                const toggle = document.getElementById('sim2_best_strategy_toggle');
                if (toggle && toggle.checked) {
                    findBestStrategy2(isAutoUpdate);
                    return;
                }
            }

            // Fixa em 100 rodadas para a simula√ß√£o secund√°ria
            const dataSlice = fullBlazeData.slice(0, 100);
            const simData = [...dataSlice].reverse();

            const strategy = document.getElementById('sim2_strategy').value;
            const galeLevel = document.getElementById('sim2_gale_active')?.checked ? 1 : 0;
            const analyzeWhite = document.getElementById('sim2_analyze_white')?.checked || false;
            const invertGale = document.getElementById('sim2_gale_invert_toggle')?.checked || false;

            updateStrategyLabels2(simData, galeLevel, analyzeWhite, invertGale, pauseWinCount2, pauseLossCount2);

            const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationLevel2, pauseWinCount2, pauseLossCount2, timePauseLoss2);
            
            sim2Stats = stats;
            const total = stats.wins + stats.losses;
            sim2RateVal = total > 0 ? (stats.wins / total) * 100 : 0;

            document.getElementById('sim2_wins').innerText = stats.wins;
            document.getElementById('sim2_losses').innerText = stats.losses;
            document.getElementById('sim2_rate').innerText = total > 0 ? ((stats.wins/total)*100).toFixed(1) + '%' : '0%';
            const balEl = document.getElementById('sim2_balance');
            balEl.innerText = `R$ ${stats.balance}`;
            balEl.style.color = stats.balance >= 0 ? '#00ff88' : '#ff0055';
            document.getElementById('sim2_max_win').innerText = stats.maxWinStreak;
            document.getElementById('sim2_max_loss').innerText = stats.maxLossStreak;

            renderGaleDistributionChart(stats.winsDistribution, 'sim2_gale_distribution_chart_container');
            showGoldenHourStrategies2();
            updatePrediction(fullBlazeData);
            checkUnsavedChanges();
        }

        function handleStrategyChange2() {
            const toggle = document.getElementById('sim2_best_strategy_toggle');
            if (toggle && toggle.checked) toggle.checked = false;
            updateSimControls(2);
            runSimulation2();
        }

        function toggleBestStrategy2() {
            const toggle = document.getElementById('sim2_best_strategy_toggle');
            if (toggle && toggle.checked) {
                autoStrategyCounter2 = 0;
                findBestStrategy2();
            }
        }

        function findBestStrategy2(isAutoUpdate = false) {
            if (!fullBlazeData || fullBlazeData.length === 0) return;
            
            const dataSlice = fullBlazeData.slice(0, 100);
            const simData = [...dataSlice].reverse();
            const galeLevel = document.getElementById('sim2_gale_active')?.checked ? 1 : 0;
            const analyzeWhite = document.getElementById('sim2_analyze_white')?.checked || false;
            const invertGale = document.getElementById('sim2_gale_invert_toggle')?.checked || false;
            
            const select = document.getElementById('sim2_strategy');
            const previousStrategy = select.value;
            let bestStrategy = previousStrategy;
            let bestRate = -1;
            let bestBalance = -Infinity;
            
            // Vari√°veis para melhor estrat√©gia COM padr√£o ativo
            let bestPatternStrategy = null;
            let bestPatternRate = -1;
            let bestPatternBalance = -Infinity;

            for (let i = 0; i < select.options.length; i++) {
                const strategy = select.options[i].value;
                if (!strategy) continue; // Pula se vazio
                const config = strategyConfigs[strategy] || {};
                const confirmationToUse = config.confirmation !== undefined ? config.confirmation : confirmationLevel2;
                const pauseWinToUse = config.pauseWin !== undefined ? config.pauseWin : pauseWinCount2;
                const pauseLossToUse = config.pauseLoss !== undefined ? config.pauseLoss : pauseLossCount2;

                const result = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationToUse, pauseWinToUse, pauseLossToUse, timePauseLoss2);
                
                const total = result.wins + result.losses;
                const rate = total > 0 ? (result.wins / total) : 0;
                
                // Verifica se existe padr√£o ATUALMENTE
                const hasPattern = getStrategyPrediction(fullBlazeData, strategy, confirmationLevel2, analyzeWhite) !== null;

                if (rate > bestRate) {
                    bestRate = rate;
                    bestBalance = result.balance;
                    bestStrategy = strategy;
                } else if (rate === bestRate) {
                    if (result.balance > bestBalance) {
                        bestBalance = result.balance;
                        bestStrategy = strategy;
                    }
                }
                
                // Se tem padr√£o, verifica se √© a melhor COM padr√£o
                if (hasPattern) {
                    if (rate > bestPatternRate) {
                        bestPatternRate = rate;
                        bestPatternBalance = result.balance;
                        bestPatternStrategy = strategy;
                    } else if (rate === bestPatternRate) {
                        if (result.balance > bestPatternBalance) {
                            bestPatternBalance = result.balance;
                            bestPatternStrategy = strategy;
                        }
                    }
                }
            }
            
            // Se ainda estiver vazio (caso inicial), for√ßa a primeira estrat√©gia v√°lida
            if (!bestStrategy && select.options.length > 1) {
                for(let i=0; i<select.options.length; i++) {
                    if(select.options[i].value) { bestStrategy = select.options[i].value; break; }
                }
            }

            // Prioriza estrat√©gia com padr√£o ativo, se houver
            if (bestPatternStrategy) {
                select.value = bestPatternStrategy;
            } else {
                select.value = bestStrategy;
            }
            
            updateSimControls(2);

            if (persistenceCount2 > 0) {
                autoStrategyCounter2 = persistenceCount2;
            }
            runSimulation2(true);

            if (bestStrategy !== previousStrategy) {
                const selectEl = document.getElementById('sim2_strategy');
                selectEl.classList.remove('blink-alert');
                void selectEl.offsetWidth;
                selectEl.classList.add('blink-alert');
            }
        }

        function updateStrategyLabels2(simData, galeLevel, analyzeWhite, invertGale, pauseWin, pauseLoss, confirmLvl) {
            const select = document.getElementById('sim2_strategy');
            if (!select) return;

            for (let i = 0; i < select.options.length; i++) {
                const option = select.options[i];
                const strategy = option.value;
                if (!strategy) continue;

                if (!option.hasAttribute('data-original-text')) {
                    option.setAttribute('data-original-text', option.text);
                }
                
                const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmLvl, pauseWin, pauseLoss, timePauseLoss2);
                const total = stats.wins + stats.losses;
                const rate = total > 0 ? (stats.wins / total) * 100 : 0;
                
                const originalText = option.getAttribute('data-original-text');
                option.text = `${originalText} (${rate.toFixed(0)}%)`;
            }
        }

        function selectStrategy2(val) {
            const select = document.getElementById('sim2_strategy');
            select.value = val;
            handleStrategyChange2();
        }

        function showGoldenHourStrategies2() {
            const container = document.getElementById('sim2_golden_hour_results');
            if (!container) return;
            
            if (!fullBlazeData || fullBlazeData.length === 0) return;

            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            
            const lastHourData = [];
            for (const game of fullBlazeData) {
                if (new Date(game.created_at) >= oneHourAgo) {
                    lastHourData.push(game);
                } else {
                    break; 
                }
            }

            if (lastHourData.length < 10) {
                container.innerHTML = '<div style="text-align: center; color: #aaa; padding: 10px;">Dados insuficientes na √∫ltima hora.</div>';
                return;
            }

            const simData = [...lastHourData].reverse();
            const galeLevel = document.getElementById('sim2_gale_active')?.checked ? 1 : 0;
            const select = document.getElementById('sim2_strategy');
            const analyzeWhite = document.getElementById('sim2_analyze_white')?.checked || false;
            const invertGale = document.getElementById('sim2_gale_invert_toggle')?.checked || false;

            const config = strategyConfigs[select.value] || {};
            const confirmationToUse = config.confirmation !== undefined ? config.confirmation : confirmationLevel2;
            const pauseWinToUse = config.pauseWin !== undefined ? config.pauseWin : pauseWinCount2;
            const pauseLossToUse = config.pauseLoss !== undefined ? config.pauseLoss : pauseLossCount2;

            let html = '<div style="background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 6px; padding: 10px;">';
            html += '<div style="color: #ffd700; font-weight: bold; margin-bottom: 8px; text-align: center;">üèÜ Estrat√©gias > 80% (√öltima Hora)</div>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">';

            let found = false;
            for (let i = 0; i < select.options.length; i++) {
                const strategy = select.options[i].value;
                if (!strategy) continue;

                const name = select.options[i].getAttribute('data-original-text') || select.options[i].text.split('(')[0].trim();
                const stats = calculateSimulation(strategy, galeLevel, simData, analyzeWhite, invertGale, confirmationToUse, pauseWinToUse, pauseLossToUse, timePauseLoss2);
                const total = stats.wins + stats.losses;
                
                if (total > 0) {
                    const rate = (stats.wins / total) * 100;
                    if (rate >= 80) {
                        found = true;
                        html += `<div onclick="selectStrategy2('${strategy}')" style="cursor: pointer; background: rgba(0,0,0,0.4); padding: 5px 10px; border-radius: 4px; border: 1px solid #ffd700; font-size: 0.8rem; color: #fff; transition: all 0.2s;">${name}: <span style="color: #00ff88; font-weight: bold;">${rate.toFixed(0)}%</span></div>`;
                    }
                }
            }

            if (!found) html += '<div style="color: #aaa; font-size: 0.8rem;">Nenhuma estrat√©gia atingiu 80% na √∫ltima hora.</div>';
            html += '</div></div>';
            container.innerHTML = html;
        }

        function renderHistory100(data) {
            const container = document.getElementById('history_100_container');
            if (!container || !data) return;

            const history = data.slice(0, 100); // Newest to Oldest
            
            let html = '';
            history.forEach(game => {
                const r = game.roll;
                let colorClass = 'seq-white';
                if (r >= 1 && r <= 7) colorClass = 'seq-red';
                else if (r >= 8 && r <= 14) colorClass = 'seq-black';
                
                html += `<div class="seq-badge ${colorClass}" style="width: 25px; height: 25px; font-size: 0.75rem; margin: 0;">${r}</div>`;
            });
            container.innerHTML = html;
        }

        function updateSimControls(simId) {
            const prefix = simId === 2 ? 'sim2_' : '';
            const strategySelectId = simId === 1 ? 'sim_strategy' : 'sim2_strategy';
            const strategyId = document.getElementById(strategySelectId)?.value;

            if (!strategyId) return;

            const config = strategyConfigs[strategyId] || {};

            const defaultPauseWin = simId === 2 ? pauseWinCount2 : pauseWinCount;
            const defaultPauseLoss = simId === 2 ? pauseLossCount2 : pauseLossCount;
            const defaultConfirmation = simId === 2 ? confirmationLevel2 : confirmationLevel;

            const pauseWin = config.pauseWin !== undefined ? config.pauseWin : defaultPauseWin;
            const pauseLoss = config.pauseLoss !== undefined ? config.pauseLoss : defaultPauseLoss;
            const confirmation = config.confirmation !== undefined ? config.confirmation : defaultConfirmation;

            const setElText = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.innerText = val;
            };

            setElText(`${prefix}pause_win_display`, pauseWin);
            setElText(`${prefix}pause_loss_display`, pauseLoss);
            setElText(`${prefix}confirmation_display`, confirmation);
        }

        function updateAllSimControls() {
            updateSimControls(1);
            updateSimControls(2);
        }

        function getCurrentSettings() {
            return {
                analysisLimit,
                predictionThreshold,
                chartScale,
                hotHoursColor,
                strategyConfigs,
                
                // Sim 1
                sim_strategy: document.getElementById('sim_strategy').value,
                best_strategy_toggle: document.getElementById('best_strategy_toggle').checked,
                gale_active_toggle: document.getElementById('gale_active_toggle').checked,
                analyze_white_toggle: document.getElementById('analyze_white_toggle').checked,
                persistenceCount,
                gale_invert_toggle: document.getElementById('gale_invert_toggle').checked,
                pauseWinCount,
                pauseLossCount,
                timePauseLoss,
                confirmationLevel,

                // Sim 2
                sim2_strategy: document.getElementById('sim2_strategy').value,
                sim2_best_strategy_toggle: document.getElementById('sim2_best_strategy_toggle').checked,
                sim2_gale_active: document.getElementById('sim2_gale_active').checked,
                sim2_analyze_white: document.getElementById('sim2_analyze_white').checked,
                persistenceCount2,
                sim2_gale_invert_toggle: document.getElementById('sim2_gale_invert_toggle').checked,
                pauseWinCount2,
                pauseLossCount2,
                timePauseLoss2,
                confirmationLevel2
            };
        }

        function checkUnsavedChanges() {
            const btn = document.getElementById('btn_save_moment');
            const fab = document.getElementById('fab_save_moment');
            if (!lastSavedSettings) return;

            const currentSettings = JSON.stringify(getCurrentSettings());
            const hasChanges = currentSettings !== lastSavedSettings;

            if (btn) {
                if (hasChanges) {
                    btn.classList.add('blink-save');
                    btn.innerText = 'Salvar *';
                } else {
                    btn.classList.remove('blink-save');
                    btn.innerText = 'Salvar Momento';
                }
            }

            if (fab) {
                if (hasChanges) fab.classList.add('blink-save');
                else fab.classList.remove('blink-save');
            }
        }

        function saveMoment() {
            const settings = getCurrentSettings();
            
            localStorage.setItem('cortex_saved_moment', JSON.stringify(settings));
            lastSavedSettings = JSON.stringify(settings);
            checkUnsavedChanges();
            const status = document.getElementById('save_status');
            if(status) {
                status.innerText = 'Configura√ß√µes salvas com sucesso!';
                status.style.color = '#00ff88';
                setTimeout(() => { status.innerText = ''; }, 3000);
            }
        }

        function loadMoment() {
            const saved = localStorage.getItem('cortex_saved_moment');
            if (!saved) return;
            
            try {
                const settings = JSON.parse(saved);
                
                if (settings.strategyConfigs) strategyConfigs = settings.strategyConfigs;

                if (settings.analysisLimit !== undefined) setAnalysisLimit(settings.analysisLimit);
                if (settings.predictionThreshold !== undefined) {
                    predictionThreshold = settings.predictionThreshold;
                    const ptDisplay = document.getElementById('prediction_threshold_display');
                    if(ptDisplay) ptDisplay.innerText = predictionThreshold + '%';
                }
                if (settings.chartScale !== undefined) chartScale = settings.chartScale;
                if (settings.hotHoursColor !== undefined) setHotHoursColor(settings.hotHoursColor);

                const setEl = (id, val, type='value') => {
                    const el = document.getElementById(id);
                    if(el) { if(type==='checked') el.checked = val; else if(type==='text') el.innerText = val; else el.value = val; }
                };

                if (settings.sim_strategy) setEl('sim_strategy', settings.sim_strategy);
                if (settings.best_strategy_toggle !== undefined) setEl('best_strategy_toggle', settings.best_strategy_toggle, 'checked');
                if (settings.gale_active_toggle !== undefined) setEl('gale_active_toggle', settings.gale_active_toggle, 'checked');
                if (settings.analyze_white_toggle !== undefined) setEl('analyze_white_toggle', settings.analyze_white_toggle, 'checked');
                if (settings.persistenceCount !== undefined) { persistenceCount = settings.persistenceCount; setEl('persistence_display', persistenceCount, 'text'); }
                if (settings.gale_invert_toggle !== undefined) setEl('gale_invert_toggle', settings.gale_invert_toggle, 'checked');
                if (settings.pauseWinCount !== undefined) { pauseWinCount = settings.pauseWinCount; setEl('pause_win_display', pauseWinCount, 'text'); }
                if (settings.pauseLossCount !== undefined) { pauseLossCount = settings.pauseLossCount; setEl('pause_loss_display', pauseLossCount, 'text'); }
                if (settings.timePauseLoss !== undefined) { timePauseLoss = settings.timePauseLoss; setEl('time_pause_loss_display', timePauseLoss + 'm', 'text'); }
                if (settings.confirmationLevel !== undefined) { confirmationLevel = settings.confirmationLevel; setEl('confirmation_display', confirmationLevel, 'text'); }

                if (settings.sim2_strategy) setEl('sim2_strategy', settings.sim2_strategy);
                if (settings.sim2_best_strategy_toggle !== undefined) setEl('sim2_best_strategy_toggle', settings.sim2_best_strategy_toggle, 'checked');
                if (settings.sim2_gale_active !== undefined) setEl('sim2_gale_active', settings.sim2_gale_active, 'checked');
                if (settings.sim2_analyze_white !== undefined) setEl('sim2_analyze_white', settings.sim2_analyze_white, 'checked');
                if (settings.persistenceCount2 !== undefined) { persistenceCount2 = settings.persistenceCount2; setEl('sim2_persistence_display', persistenceCount2, 'text'); }
                if (settings.sim2_gale_invert_toggle !== undefined) setEl('sim2_gale_invert_toggle', settings.sim2_gale_invert_toggle, 'checked');
                if (settings.pauseWinCount2 !== undefined) { pauseWinCount2 = settings.pauseWinCount2; setEl('sim2_pause_win_display', pauseWinCount2, 'text'); }
                if (settings.pauseLossCount2 !== undefined) { pauseLossCount2 = settings.pauseLossCount2; setEl('sim2_pause_loss_display', pauseLossCount2, 'text'); }
                if (settings.timePauseLoss2 !== undefined) { timePauseLoss2 = settings.timePauseLoss2; setEl('sim2_time_pause_loss_display', timePauseLoss2 + 'm', 'text'); }
                if (settings.confirmationLevel2 !== undefined) { confirmationLevel2 = settings.confirmationLevel2; setEl('sim2_confirmation_display', confirmationLevel2, 'text'); }
                
                lastSavedSettings = JSON.stringify(getCurrentSettings());
                
                updateAllSimControls();
                checkUnsavedChanges();
            } catch (e) { console.error("Erro ao carregar configura√ß√µes", e); }
        }
    </script>
</body>
</html>