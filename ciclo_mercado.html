<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ciclo de Mercado</title>
    <style>
        /* Basic styles from other pages */
        :root {
            --bg-color: #0f0f13; --panel-bg: #1a1a1a; --text-color: #fff; --border-color: #333; --input-bg: #0f0f13;
            --accent: #00d2ff; --accent-blaze: #ff0055; --accent-jonbet: #00ff88; --text-muted: #888;
        }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; }
        .main-container { max-width: 98%; margin: 0 auto; }
        .layout-panel { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
        h1 { margin: 0; }
        .cortex-text-anim { background: linear-gradient(90deg, #00d2ff, #ff0055, #ff9800, #00d2ff); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: cortex-gradient 3s linear infinite; font-weight: bold; }
        @keyframes cortex-gradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        .btn-back { display: inline-flex; align-items: center; gap: 5px; padding: 8px 15px; background: rgba(255,255,255,0.05); color: #aaa; text-decoration: none; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; border: 1px solid #333; transition: all 0.3s; }
        .btn-back:hover { background: rgba(0, 210, 255, 0.1); border-color: #00d2ff; color: #00d2ff; box-shadow: 0 0 10px rgba(0, 210, 255, 0.2); }
        
        /* Styles for the market cycle tool will go here */
        .chart-dot { animation: pulse-chart 1s infinite; } 
        @keyframes pulse-chart { 0% { r: 3; opacity: 0.6; } 50% { r: 5; opacity: 1; box-shadow: 0 0 5px #fff; } 100% { r: 3; opacity: 0.6; } }
        /* Futuristic Scoreboard */
        .futuristic-scoreboard {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(10, 10, 15, 0.6);
            border: 1px solid #333;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .futuristic-scoreboard::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 2px;
            background: linear-gradient(90deg, transparent, #ffeb3b, transparent);
            animation: scan-line 3s linear infinite;
        }
        .score-card {
            flex: 1; display: flex; flex-direction: column; align-items: center; padding: 10px;
            background: rgba(255, 255, 255, 0.03); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s;
        }
        .score-card:hover { transform: translateY(-3px); background: rgba(255, 255, 255, 0.05); }
        .score-card.avg { border-bottom: 2px solid #00d2ff; }
        .score-card.min { border-bottom: 2px solid #00ff88; }
        .score-card.max { border-bottom: 2px solid #ff0055; }
        .score-card.last { border-bottom: 2px solid #a100ff; }
        .score-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; color: #888; margin-bottom: 2px; }
        .score-value { font-size: 1.7rem; font-weight: 800; font-family: monospace; } /* Reduced from 1.8rem */
        .avg-text { color: #00d2ff; text-shadow: 0 0 8px rgba(0, 210, 255, 0.4); }
        .min-text { color: #00ff88; text-shadow: 0 0 8px rgba(0, 255, 136, 0.4); }
        .max-text { color: #ff0055; text-shadow: 0 0 8px rgba(255, 0, 85, 0.4); }
        .last-text { color: #a100ff; text-shadow: 0 0 8px rgba(161, 0, 255, 0.4); }
        @keyframes scan-line { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        .progress-ring-circle { transition: stroke-dashoffset 0.35s; transform-origin: 50% 50%; transform: rotate(-90deg); }
        
        /* Daily Stats Panel */
        .daily-stats-panel .daily-stat-label { color: #ccc; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; }
        .daily-stats-panel .daily-stat-value { font-weight: bold; font-size: 1.1rem; } /* Reduced from 1.2rem */
        .daily-stats-panel .win { color: #00ff88; text-shadow: 0 0 10px rgba(0, 255, 136, 0.4); }
        .daily-stats-panel .loss { color: #ff0055; text-shadow: 0 0 10px rgba(255, 0, 85, 0.4); }
        .daily-stats-panel .assertiveness { color: #00d2ff; border-left: 1px solid rgba(255,255,255,0.2); padding-left: 20px; text-shadow: 0 0 10px rgba(0, 210, 255, 0.4); }

        .target-time { font-size: 1.1rem; font-weight: bold; color: #fff; }

        /* Estilos do Bot√£o Switch */
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #00d2ff; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* --- MOBILE RESPONSIVE (Added for precision) --- */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .layout-panel {
                padding: 15px;
            }

            /* Header controls */
            .main-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            /* Scoreboard */
            .futuristic-scoreboard {
                flex-direction: column;
                gap: 10px;
            }
            .score-value {
                font-size: 1.5rem; /* Reduced from 1.6rem */
            }

            /* Daily Stats (Placar do Dia) */
            .daily-stats-panel {
                flex-wrap: wrap;
                gap: 10px !important;
                padding: 10px !important;
                justify-content: space-around !important;
            }
            .daily-stats-panel .daily-stat-value { font-size: 1rem !important; }

            /* Target Monitor (Alvos) */
            .targets-grid { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)) !important; gap: 8px !important; }
            .target-time {
                font-size: 1rem; /* Reduced from 1.1rem */
            }
        }

        /* --- Scrollbar Futurista Aprimorada --- */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(10, 10, 15, 0.5);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, rgba(0, 210, 255, 0.5), rgba(255, 235, 59, 0.5)); /* Amarelo do ciclo */
            border-radius: 10px;
            border: 1px solid rgba(0, 210, 255, 0.2);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, var(--accent), #ffeb3b);
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
        }

        /* --- Anima√ß√£o Zona de Calor Futurista --- */
        .heat-zone-item {
            position: relative; overflow: hidden; transition: all 0.3s;
        }
        .heat-zone-item::after {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            animation: heat-scan 2.5s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }
        @keyframes heat-scan { 0% { transform: translateY(-150%) rotate(45deg); } 100% { transform: translateY(150%) rotate(45deg); } }

        /* --- Efeito Matrix Rain Sutil --- */
        .matrix-rain-bg {
            position: relative;
            background: radial-gradient(circle, rgba(0, 20, 0, 0.3) 0%, transparent 70%);
        }
        .matrix-rain-bg::before {
            content: "10 01 11 00 10 01 11 00"; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            font-family: monospace; color: rgba(0, 255, 136, 0.03); font-size: 10px; line-height: 10px; word-break: break-all; overflow: hidden; pointer-events: none; z-index: 0;
        }

        /* --- Trigger Status Box Styles --- */
        .trigger-status-box {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }
        .trigger-active {
            background: rgba(255, 0, 85, 0.15);
            border: 1px solid #ff0055;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.3);
            animation: pulse-border-red 1s infinite alternate;
        }
        @keyframes pulse-border-red {
            0% { border-color: #ff0055; box-shadow: 0 0 10px rgba(255,0,85,0.2); }
            100% { border-color: #ffeb3b; box-shadow: 0 0 20px rgba(255,235,59,0.4); }
        }
        .trigger-waiting {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        .trigger-waiting::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.2), transparent);
            animation: scan-waiting 3s infinite linear;
        }
        @keyframes scan-waiting { 0% { left: -100%; } 100% { left: 200%; } }
        .waiting-text {
            font-weight: bold; letter-spacing: 2px; text-transform: uppercase;
            animation: text-flicker 3s infinite;
        }
        @keyframes text-flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% { opacity: 1; text-shadow: 0 0 8px #00ff88; }
            20%, 24%, 55% { opacity: 0.6; text-shadow: none; }
        }
        .buscar-branco-anim {
            animation: blink-text-yellow 1.2s infinite ease-in-out;
        }
        @keyframes blink-text-yellow {
            0%, 100% { color: #ffeb3b; text-shadow: 0 0 8px #ffeb3b; transform: scale(1); }
            50% { color: #fff; text-shadow: none; transform: scale(1.05); }
        }
        @keyframes blink-green-text {
            0%, 100% { color: #00ff88; text-shadow: 0 0 8px #00ff88; }
            50% { color: #fff; text-shadow: none; }
        }
        .high-accuracy-anim {
            animation: blink-green-text 1s infinite;
            font-weight: bold;
        }
        @keyframes futuristic-search-pulse {
            0% { box-shadow: 0 0 5px rgba(255, 235, 59, 0.1); border-color: rgba(255, 235, 59, 0.3); transform: scale(0.99); }
            50% { box-shadow: 0 0 25px rgba(255, 235, 59, 0.5), inset 0 0 15px rgba(255, 235, 59, 0.1); border-color: #ffeb3b; transform: scale(1); }
            100% { box-shadow: 0 0 5px rgba(255, 235, 59, 0.1); border-color: rgba(255, 235, 59, 0.3); transform: scale(0.99); }
        }
        @keyframes blink-red-text {
            0%, 100% { color: #ff0055; text-shadow: 0 0 8px #ff0055; }
            50% { color: #fff; text-shadow: none; }
        }
        @keyframes new-roll-pulse {
            0% { transform: scale(1); box-shadow: 0 0 5px rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3); }
            50% { transform: scale(1.05); box-shadow: 0 0 15px rgba(255,255,255,0.3); border-color: #fff; }
            100% { transform: scale(1); box-shadow: 0 0 5px rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3); }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="layout-panel">
            <div class="main-header">
                <h1 class="cortex-text-anim">CICLO DE MERCADO</h1>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="font-size: 0.8rem; color: #aaa;">Filtro Assert.:</span>
                        <label class="switch" style="transform: scale(0.8);">
                            <input type="checkbox" id="assertivenessFilterToggle" onchange="analyzeAndDisplayCycles()">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <span style="font-size: 0.8rem; color: #aaa;">Auto-Atualizar (15s):</span>
                    <label class="switch" style="transform: scale(0.8);">
                        <input type="checkbox" id="autoUpdateToggle" checked onchange="toggleAutoUpdate()">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div id="cycles_content" style="color: #fff;">Aguardando dados para an√°lise...</div>

        </div>
    </div>
    <script>
        let cycleMonitorHistory = []; // Hist√≥rico para o monitor de ciclo
        let currentCycleStartTime = 0; // Para controlar a limpeza do hist√≥rico no novo ciclo
        let frequencyViewMode = 'minute'; // Controle de visualiza√ß√£o do gr√°fico de frequ√™ncia
        let frequencyDisplayMode = 'count'; // 'count' ou 'percent'
        let frequencyZoomLevel = 1; // N√≠vel de zoom do gr√°fico
        let hotMinuteCountdownInterval; // Intervalo para o contador regressivo
        let variationViewMode = 'last100'; // 'last100' ou 'all'
        let isSimulatingTrigger = false; // Controle de simula√ß√£o do alerta
        let smartTriggerMode = false; // Modo de troca de gatilho inteligente
        let lastWinningTrigger = null; // Armazena o √∫ltimo gatilho vencedor

        let cycleWorker = null;

        function initializeCycleWorker() {
            if (cycleWorker) return;

            const workerCode = `
                let intervalId = null;
                self.onmessage = function(e) {
                    if (e.data.command === 'start') {
                        if (intervalId) clearInterval(intervalId);
                        intervalId = setInterval(() => {
                            self.postMessage('tick');
                        }, e.data.interval || 15000);
                    } else if (e.data.command === 'stop') {
                        if (intervalId) clearInterval(intervalId);
                        intervalId = null;
                    }
                };
            `;
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            cycleWorker = new Worker(URL.createObjectURL(blob));

            cycleWorker.onmessage = function(e) {
                if (e.data === 'tick') {
                    const toggle = document.getElementById('autoUpdateToggle');
                    if (toggle && toggle.checked) {
                        fetchBlazeData();
                    }
                }
            };
        }

        // --- NOVO: Estado do Gatilho ---
        let triggerState = {
            isActive: false,
            startEntryTime: null,
            result: null, // 'WIN', 'LOSS', ou 'PENDING'
            showResultUntilIndex: -1,
            triggerNumber: null // Armazena o n√∫mero do gatilho atual
        };
        let triggerWins = 0;
        let triggerLosses = 0;
        let triggerHistory = [];
        const ENTRIES_TO_WAIT = 6; // MODIFICADO: Agora espera 6 pedras individuais.


        document.addEventListener('DOMContentLoaded', () => {
            console.log("P√°gina Ciclo de Mercado carregada.");
            analyzeAndDisplayCycles();
            if(document.getElementById('autoUpdateToggle').checked) toggleAutoUpdate();
        });

        function toggleAutoUpdate() {
            const toggle = document.getElementById('autoUpdateToggle');
            initializeCycleWorker(); // Garante que o worker seja inicializado

            if (toggle && toggle.checked) {
                fetchBlazeData(); // Busca imediatamente ao ativar
                cycleWorker.postMessage({ command: 'start', interval: 15000 });
                console.log("Ciclo de Mercado: Web Worker iniciado para auto-atualiza√ß√£o.");
                
            } else {
                if (cycleWorker) {
                    cycleWorker.postMessage({ command: 'stop' });
                    console.log("Ciclo de Mercado: Web Worker parado.");
                }
            }
        }

        function toggleFrequencyView() {
            frequencyViewMode = frequencyViewMode === 'hour' ? 'minute' : 'hour';
            analyzeAndDisplayCycles();
        }

        function toggleFrequencyDisplayMode() {
            frequencyDisplayMode = frequencyDisplayMode === 'count' ? 'percent' : 'count';
            analyzeAndDisplayCycles();
        }

        function changeFrequencyZoom(delta) {
            frequencyZoomLevel += delta;
            if (frequencyZoomLevel < 0.5) frequencyZoomLevel = 0.5;
            if (frequencyZoomLevel > 4) frequencyZoomLevel = 4;
            analyzeAndDisplayCycles();
        }

        function toggleVariationViewMode() {
            variationViewMode = variationViewMode === 'last100' ? 'all' : 'last100';
            analyzeAndDisplayCycles();
        }

        function toggleSmartTrigger() {
            smartTriggerMode = !smartTriggerMode;
            analyzeAndDisplayCycles();
        }

        function simulateTrigger() {
            isSimulatingTrigger = true;
            analyzeAndDisplayCycles();
            setTimeout(() => {
                isSimulatingTrigger = false;
                analyzeAndDisplayCycles();
            }, 5000);
        }

        function identificarCorCiclo(numero) {
            numero = parseInt(numero);
            if (numero === 0) return 'branco';
            if (numero >= 1 && numero <= 7) return 'vermelho';
            if (numero >= 8 && numero <= 14) return 'preto';
            return 'desconhecido';
        }

        async function fetchBlazeData() {
            try {
                const agora = new Date();
                const ontem = new Date();
                ontem.setHours(ontem.getHours() - 24);
                
                const endDate = agora.toISOString();
                const startDate = ontem.toISOString();
                
                let allGames = [];
                // Busca p√°ginas 1 a 3 para garantir dados suficientes para an√°lise de ciclos
                for (let page = 1; page <= 3; page++) {
                    const baseUrl = `https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/history/${page}`;
                    const params = `?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}&page=${page}&_nc=${Date.now()}`;
                    const targetUrl = `${baseUrl}${params}`;
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                    
                    // Delay entre requisi√ß√µes para evitar erro 429 (Too Many Requests)
                    if (page > 1) await new Promise(r => setTimeout(r, 2000));

                    try {
                        const response = await fetch(proxyUrl);
                        if (response.ok) {
                            const data = await response.json();
                            const records = Array.isArray(data) ? data : (data.records || []);
                            if (records.length === 0) break;
                            allGames = allGames.concat(records);
                        }
                    } catch (e) { console.warn(`Erro na p√°gina ${page}`, e); }
                }

                // Remove duplicatas e ordena (Mais recente primeiro)
                const seenIds = new Set();
                const uniqueGames = allGames.filter(game => {
                    if (game.id && !seenIds.has(game.id)) { seenIds.add(game.id); return true; }
                    return false;
                }).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                // Formata os dados para o padr√£o esperado pelo script (DD/MM/YYYY ROLL HH:MM)
                const formattedData = uniqueGames.map(game => {
                    const date = new Date(game.created_at);
                    const d = String(date.getDate()).padStart(2, '0');
                    const m = String(date.getMonth() + 1).padStart(2, '0');
                    const y = date.getFullYear();
                    const h = String(date.getHours()).padStart(2, '0');
                    const min = String(date.getMinutes()).padStart(2, '0');
                    return `${d}/${m}/${y} ${game.roll} ${h}:${min}`;
                }).join(' ');

                sessionStorage.setItem('raw_blaze_data', formattedData);
                analyzeAndDisplayCycles(); // Atualiza a tela ap√≥s salvar
            } catch (error) {
                console.error("Erro no Auto-Busca:", error);
                const content = document.getElementById('cycles_content');
                if(content) content.innerHTML = `<p style="text-align: center; color: #ff0055;">‚ö†Ô∏è Erro ao buscar dados: ${error.message}</p>`;
            }
        }

        function analyzeAndDisplayCycles() {
            const content = document.getElementById('cycles_content');
            const rawData = sessionStorage.getItem('raw_blaze_data');
            if (!rawData) {
                content.innerHTML = '<p style="text-align: center; color: #ff9800;">‚ö†Ô∏è Nenhum dado de hist√≥rico encontrado. Por favor, v√° ao painel principal e clique em "BUSCAR DADOS" primeiro.</p>';
                return;
            }
            
            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            
            // --- An√°lise de Assertividade por Minuto (0-59) ---
            const minuteTotals = new Array(60).fill(0);
            const minuteWhites = new Array(60).fill(0);
            
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    const roll = parseInt(tokens[i + 1]);
                    const time = tokens[i + 2];
                    const minute = parseInt(time.split(':')[1]);
                    if (!isNaN(minute)) {
                        minuteTotals[minute]++;
                        if (roll === 0) minuteWhites[minute]++;
                    }
                    i += 2;
                }
            }
            // --- Filtro Din√¢mico de Assertividade ---
            const totalW = minuteWhites.reduce((a,b)=>a+b,0);
            const totalM = minuteTotals.reduce((a,b)=>a+b,0);
            const globalRate = totalM > 0 ? totalW / totalM : 0.07;
            const dynamicThreshold = Math.max(0.10, globalRate * 1.25); // Exige 25% acima da m√©dia global ou min 10%
            const bestMinutes = [];
            for(let m=0; m<60; m++) { if(minuteTotals[m] > 0 && (minuteWhites[m]/minuteTotals[m]) >= dynamicThreshold) bestMinutes.push(m); }

            // --- L√≥gica de Rastreio (An√°lise completa do hist√≥rico) ---
            const fullResults = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    fullResults.push({
                        date: tokens[i],
                        roll: parseInt(tokens[i + 1]),
                        time: tokens[i + 2]
                    });
                    i += 2;
                }
            }
            // Inverte para ordem cronol√≥gica (mais antigo para mais novo)
            fullResults.reverse();
            // --- Fim da an√°lise de hist√≥rico ---


            let latestGameTime = null;
            if (tokens.length >= 3 && tokens[0].includes('/') && tokens[2].includes(':')) {
                 const [d, m, y] = tokens[0].split('/').map(Number);
                 const timeParts = tokens[2].split(':').map(Number);
                 latestGameTime = new Date(y, m - 1, d, timeParts[0], timeParts[1], timeParts[2] || 0);
            }

            const whiteTimes = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    if (parseInt(tokens[i + 1]) === 0) {
                        const [day, month, year] = tokens[i].split('/').map(Number);
                        const timeParts = tokens[i + 2].split(':').map(Number);
                        whiteTimes.push(new Date(year, month - 1, day, timeParts[0], timeParts[1], timeParts[2] || 0));
                    }
                    i += 2;
                }
            }
            if (whiteTimes.length < 2) { content.innerHTML = '<p style="text-align: center; color: #ff9800;">‚ö†Ô∏è M√≠nimo 2 brancos no hist√≥rico para calcular ciclos.</p>'; return; }
            
            whiteTimes.sort((a, b) => a - b);
            const intervals = [];
            const intervalDates = [];
            for (let i = 1; i < whiteTimes.length; i++) {
                const diffMins = Math.floor((whiteTimes[i] - whiteTimes[i - 1]) / 60000);
                if (diffMins > 0) {
                    intervals.push(diffMins);
                    intervalDates.push(whiteTimes[i]);
                }
            }
            if (intervals.length === 0) { content.innerHTML = '<p style="text-align: center; color: #ff9800;">‚ö†Ô∏è N√£o foi poss√≠vel calcular intervalos v√°lidos.</p>'; return; }
            
            // --- An√°lise Avan√ßada de Precis√£o (Smart Analysis) ---
            const recentIntervals = intervals.slice(-20);
            const lastIntervalVal = intervals[intervals.length - 1];
            let smartAvg = 0;
            let analysisLabel = "M√âDIA (20)";

            // 1. Tenta encontrar Padr√£o de Repeti√ß√£o (O que acontece ap√≥s um intervalo X?)
            const similarPatterns = [];
            const patternIndices = []; // √çndices dos resultados do padr√£o
            const tolerance = Math.max(2, Math.round(lastIntervalVal * 0.15)); // Toler√¢ncia de 15% ou min 2m
            
            for (let i = 0; i < intervals.length - 1; i++) {
                if (Math.abs(intervals[i] - lastIntervalVal) <= tolerance) {
                    similarPatterns.push(intervals[i + 1]); // Pega o pr√≥ximo intervalo da sequ√™ncia
                    patternIndices.push(i + 1);
                }
            }

            if (similarPatterns.length >= 3) {
                smartAvg = Math.round(similarPatterns.reduce((a, b) => a + b, 0) / similarPatterns.length);
                
                // Calcula a for√ßa do padr√£o baseada na consist√™ncia (Desvio Padr√£o)
                const variance = similarPatterns.reduce((sum, val) => sum + Math.pow(val - smartAvg, 2), 0) / similarPatterns.length;
                const stdDev = Math.sqrt(variance);
                const cv = stdDev / (smartAvg || 1); // Coeficiente de Varia√ß√£o

                let strength = "BAIXA", sColor = "#ff0055";
                if (cv <= 0.25) { strength = "ALTA"; sColor = "#00ff88"; }
                else if (cv <= 0.50) { strength = "M√âDIA"; sColor = "#ff9800"; }
                
                const pList = similarPatterns.join(', ');
                const pPreview = similarPatterns.length > 4 ? similarPatterns.slice(0, 4).join(',') + '...' : pList;
                analysisLabel = `PADR√ÉO <span style="color:${sColor}">${strength}</span><br><span style="font-size:0.5rem; color:#888; cursor:help;" title="Hist√≥rico: ${pList}">[${pPreview}]</span>`;
            } else {
                // 2. M√©dia Ponderada (Peso maior para os mais recentes)
                const weightedSlice = intervals.slice(-15);
                let weightedSum = 0, weightTotal = 0;
                weightedSlice.forEach((val, idx) => {
                    weightedSum += val * (idx + 1);
                    weightTotal += (idx + 1);
                });
                smartAvg = Math.round(weightedSum / weightTotal);
                analysisLabel = "M√âDIA PONDERADA";
            }

            const avg = smartAvg > 0 ? smartAvg : Math.round(recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length);
            const min = Math.min(...recentIntervals);
            const max = Math.max(...recentIntervals);
            const lastInterval = intervals[intervals.length - 1];
            
            // --- C√°lculo de WIN/LOSS do Dia (Simula√ß√£o baseada na M√©dia Atual) ---
            let dailyWins = 0;
            let dailyLosses = 0;
            const dailyHistory = []; // Armazena o hist√≥rico calculado do dia
            const todayDate = new Date().getDate();
            
            // Itera sobre os intervalos para calcular assertividade do dia
            for (let i = 1; i < whiteTimes.length; i++) {
                // Considera apenas se o branco ocorreu hoje
                if (whiteTimes[i].getDate() === todayDate) {
                    const diff = Math.floor((whiteTimes[i] - whiteTimes[i - 1]) / 60000);
                    let mult = 1;
                    // Verifica ciclos at√© encontrar o acerto ou desistir (limite arbitr√°rio de 50x)
                    while (mult <= 50) {
                        const targetMin = mult * avg;
                        const tTime = new Date(whiteTimes[i-1].getTime() + targetMin * 60000);
                        const tTimeStr = `${tTime.getHours().toString().padStart(2, '0')}:${tTime.getMinutes().toString().padStart(2, '0')}`;

                        // Janela de acerto: do tempo alvo at√© +3 minutos (6 pedras / 2 por min)
                        if (diff >= targetMin && diff <= targetMin + 3) {
                            dailyWins++;
                            dailyHistory.push({ time: tTimeStr, result: 'WIN' });
                            break; // Acertou neste ciclo, para de contar loss para este intervalo
                        } else if (diff > targetMin + 3) {
                            dailyLosses++; // Passou do tempo alvo + margem, conta como LOSS
                            dailyHistory.push({ time: tTimeStr, result: 'LOSS' });
                        }
                        mult++;
                        // Se o multiplicador passar muito do diff, paramos (evita loop infinito se l√≥gica falhar)
                        if (targetMin > diff + 20) break;
                    }
                }
            }
            const dailyTotal = dailyWins + dailyLosses;
            const dailyAssertiveness = dailyTotal > 0 ? Math.round((dailyWins / dailyTotal) * 100) : 0;
            
            const dailyStatsHtml = `<div class="daily-stats-panel" style="display: flex; justify-content: center; align-items: center; gap: 20px; background: linear-gradient(90deg, rgba(0, 40, 60, 0.6), rgba(0, 0, 0, 0.8), rgba(60, 0, 20, 0.6)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 0 20px rgba(0, 210, 255, 0.1); margin-bottom: 25px; position: relative; overflow: hidden;"><div style="position: absolute; top: 0; left: 0; width: 100%; height: 2px; background: linear-gradient(90deg, transparent, #00d2ff, transparent);"></div><span class="daily-stat-label">Placar do Dia</span><span class="daily-stat-value win">WIN: ${dailyWins}</span><span class="daily-stat-value loss">LOSS: ${dailyLosses}</span><span class="daily-stat-value assertiveness">${dailyAssertiveness}%</span></div>`;

            // --- Gr√°fico de Frequ√™ncia (Hora ou Minuto) ---
            const isHourView = frequencyViewMode === 'hour';
            const isPercentMode = frequencyDisplayMode === 'percent';
            const buckets = isHourView ? 24 : 60;
            const freqCounts = Array(buckets).fill(0);
            const lastSeenMap = Array(buckets).fill(0); // Rastreia a √∫ltima ocorr√™ncia
            whiteTimes.forEach(date => {
                const idx = isHourView ? date.getHours() : date.getMinutes();
                freqCounts[idx]++;
                if (date.getTime() > lastSeenMap[idx]) lastSeenMap[idx] = date.getTime();
            });

            // Calcula totais para porcentagem
            const totalCounts = Array(buckets).fill(0);
            fullResults.forEach(res => {
                const [h, m] = res.time.split(':').map(Number);
                const idx = isHourView ? h : m;
                if (idx >= 0 && idx < buckets) totalCounts[idx]++;
            });

            // Define valores de exibi√ß√£o (Contagem ou %)
            const displayValues = freqCounts.map((count, i) => {
                if (isPercentMode) return totalCounts[i] > 0 ? (count / totalCounts[i]) * 100 : 0;
                return count;
            });

            const maxFreqCount = Math.max(...displayValues, isPercentMode ? 1 : 1);
            
            // Largura fixa para o ViewBox (o CSS controlar√° o tamanho real para caber na tela)
            const baseWidth = isHourView ? 600 : 800;
            const chartW_freq = baseWidth * frequencyZoomLevel;
            const chartH_freq = 100;
            const barWidth_freq = chartW_freq / buckets;
            
            let bars_freq = '';
            const currentMinute = new Date().getMinutes();
            
            displayValues.forEach((val, idx) => {
                const count = freqCounts[idx];
                const lastSeenTime = lastSeenMap[idx];
                const nowTime = new Date().getTime();
                // Considera "Novo" se ocorreu nas √∫ltimas 3 horas (10800000 ms)
                const isRecent = (nowTime - lastSeenTime) < 10800000;

                const barHeight = (val / maxFreqCount) * (chartH_freq - 20);
                const x = idx * barWidth_freq;
                const y = chartH_freq - barHeight;
                const isHot = val > 0 && val >= maxFreqCount * 0.8;
                
                // Cores diferenciadas para Velhas vs Novas
                let barColor = isHot ? (isRecent ? '#ff5500' : '#5c2b00') : (isRecent ? '#00d2ff' : '#003344');
                let barOpacity = isRecent ? 0.8 : 0.5; // Mais opacidade para recentes
                let barTitle = `${isHourView ? 'Hora' : 'Minuto'} ${idx}: ${count} branco(s) [${isRecent ? 'Recente' : 'Antigo'}]`;
                if (isPercentMode) barTitle += ` (${val.toFixed(2)}%)`;
                let extraStyles = '';

                if (!isHourView && idx === currentMinute) {
                    barColor = '#ffeb3b'; // Amarelo brilhante para o minuto atual
                    barOpacity = 1;
                    barTitle = `AGORA (${idx}) - ${count} branco(s)${isPercentMode ? ' (' + val.toFixed(2) + '%)' : ''}`;
                    extraStyles = 'filter="url(#freqGlow)"'; // Usa um filtro de brilho espec√≠fico
                }
                
                const rectWidth = barWidth_freq - 4;
                const rectX = 2;
                // Mostra todos os labels (0-59)
                const label = `<text x="${barWidth_freq / 2}" y="${chartH_freq - 5}" font-size="${isHourView ? 12 : 10}" fill="#888" text-anchor="middle">${idx}</text>`;
                // Mostra a contagem no topo da barra se maior que 0
                let topLabel = '';
                if (val > 0) topLabel = isPercentMode ? val.toFixed(1) + '%' : count;
                const countLabel = val > 0 ? `<text x="${barWidth_freq / 2}" y="${y - 3}" font-size="8" fill="#fff" text-anchor="middle">${topLabel}</text>` : '';
                
                bars_freq += `<g transform="translate(${x}, 0)"><rect x="${rectX}" y="${y}" width="${rectWidth}" height="${barHeight}" fill="${barColor}" opacity="${barOpacity}" rx="2" ${extraStyles}><title>${barTitle}</title></rect>${countLabel}${label}</g>`;
            });

            // M√©dia M√≥vel para suaviza√ß√£o (Linha de Tend√™ncia)
            let maPath = "";
            displayValues.forEach((_, idx, arr) => {
                let sum = 0, count = 0;
                // Janela de suaviza√ß√£o (+/- 2 √≠ndices)
                for(let k = -2; k <= 2; k++) {
                    if(arr[idx+k] !== undefined) { sum += arr[idx+k]; count++; }
                }
                const val = sum / count;
                const x = idx * barWidth_freq + barWidth_freq / 2;
                const y = chartH_freq - (val / maxFreqCount) * (chartH_freq - 20);
                maPath += (idx === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
            });

            // Linha de M√©dia Geral
            const totalVal = displayValues.reduce((a, b) => a + b, 0);
            const avgVal = totalVal / buckets;
            const avgY = chartH_freq - (avgVal / maxFreqCount) * (chartH_freq - 20);
            const avgLineSvg = `<line x1="0" y1="${avgY}" x2="${chartW_freq}" y2="${avgY}" stroke="#ff0055" stroke-width="1" stroke-dasharray="4,4" opacity="0.5"><title>M√©dia Geral: ${avgVal.toFixed(2)}${isPercentMode ? '%' : ''}</title></line>`;

            // --- L√≥gica de Previs√£o (Zona de Calor) ---
            let predictionHtml = '';
            if (hotMinuteCountdownInterval) clearInterval(hotMinuteCountdownInterval);
            let targetHotTime = null;

            if (!isHourView) {
                // Calcula m√©dia de contagem absoluta para definir o limiar
                const avgCount = freqCounts.reduce((a,b)=>a+b,0) / 60;
                const maxAbsCount = Math.max(...freqCounts, 0);
                
                // Limiar Din√¢mico: Ajusta a sensibilidade baseada no volume de dados
                let hotThreshold = Math.max(2, avgCount * 1.3);
                if (maxAbsCount <= 4) hotThreshold = 0.9; // Se houver poucos dados, mostra qualquer ocorr√™ncia
                
                const upcomingHot = [];
                // Analisa o minuto ATUAL e os pr√≥ximos 15 minutos
                for(let i = 0; i <= 15; i++) {
                    const nextMin = (currentMinute + i) % 60;
                    const count = freqCounts[nextMin];
                    if (count >= hotThreshold) {
                        upcomingHot.push({ min: nextMin, count: count, wait: i });
                    }
                }

                let contentBody = '';
                let countdownText = '--:--';

                if (upcomingHot.length > 0) {
                    const nextHot = upcomingHot[0];
                    const now = new Date();
                    targetHotTime = new Date(now.getTime() + nextHot.wait * 60000);
                    targetHotTime.setSeconds(0);
                    targetHotTime.setMilliseconds(0);

                    const items = upcomingHot.map(item => 
                        `<div class="heat-zone-item" style="background: rgba(255, 152, 0, 0.15); border: 1px solid rgba(255, 152, 0, 0.6); padding: 5px 10px; border-radius: 6px; text-align: center; min-width: 60px; box-shadow: 0 0 10px rgba(255, 152, 0, 0.1);">
                            <div style="font-weight: bold; color: #ff9800; font-size: 0.9rem;">Min ${item.min}</div>
                            <div style="font-size: 0.7rem; color: #aaa;">${item.wait === 0 ? 'AGORA' : 'em ' + item.wait + 'm'} (${item.count}x)</div>
                        </div>`
                    ).join('');
                    contentBody = `<div style="display: flex; gap: 8px; overflow-x: auto; padding-bottom: 5px;">${items}</div>`;
                } else {
                    // Estado de "Aguardando" com anima√ß√£o futurista
                    countdownText = '...';
                    contentBody = `<div style="width: 100%; padding: 10px; background: rgba(255, 152, 0, 0.05); border: 1px dashed rgba(255, 152, 0, 0.2); border-radius: 6px; text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                        <div style="font-size: 0.75rem; color: #888; letter-spacing: 1px; animation: pulse-text 1.5s infinite alternate;">AGUARDANDO PADR√ÉO...</div>
                        <div style="width: 40px; height: 2px; background: #ff9800; margin-top: 5px; box-shadow: 0 0 5px #ff9800; animation: width-pulse 1.5s infinite;"></div>
                        <style>@keyframes width-pulse { 0% { width: 10px; opacity: 0.3; } 100% { width: 60px; opacity: 1; } }</style>
                    </div>`;
                }

                predictionHtml = `<div class="matrix-rain-bg" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); border-radius: 0 0 8px 8px;">
                        <div style="font-size: 0.75rem; color: #ccc; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between;">
                            <div style="display: flex; align-items: center; gap: 5px;"><span style="font-size:1rem;">üî•</span> <span>ZONA DE CALOR (Pr√≥ximos 15m)</span> <span style="font-size: 0.65rem; color: #666;">- Minutos com alta frequ√™ncia hist√≥rica</span></div>
                            <div style="background: rgba(255, 152, 0, 0.1); border: 1px solid #ff9800; padding: 2px 8px; border-radius: 4px; color: #ff9800; font-weight: bold; font-size: 0.8rem; display: flex; align-items: center; gap: 5px;">
                                <span>‚è≥ Pr√≥ximo:</span>
                                <span id="hot_countdown_display">${countdownText}</span>
                            </div>
                        </div>
                        <div style="position: relative; z-index: 1;">${contentBody}</div></div>`;
            }

            const freqTitle = isHourView ? 'Frequ√™ncia de Brancos por Hora' : 'Frequ√™ncia de Brancos por Minuto';
            const toggleBtn = `<button onclick="toggleFrequencyView()" style="float: right; background: rgba(255,255,255,0.1); border: 1px solid #333; color: #ccc; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem; transition: all 0.3s;">Ver por ${isHourView ? 'Minutos' : 'Horas'}</button>`;
            const toggleModeBtn = `<button onclick="toggleFrequencyDisplayMode()" style="float: right; margin-right: 5px; background: rgba(255,255,255,0.1); border: 1px solid #333; color: #ccc; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem; transition: all 0.3s;">${isPercentMode ? 'Ver Qtd' : 'Ver %'}</button>`;
            const zoomControls = `<div style="float: right; margin-right: 10px; display: flex; gap: 2px;"><button onclick="changeFrequencyZoom(-0.25)" style="background: rgba(255,255,255,0.1); border: 1px solid #333; color: #ccc; width: 20px; height: 20px; border-radius: 4px 0 0 4px; cursor: pointer; font-size: 0.8rem; line-height: 1;">-</button><button onclick="changeFrequencyZoom(0.25)" style="background: rgba(255,255,255,0.1); border: 1px solid #333; border-left: none; color: #ccc; width: 20px; height: 20px; border-radius: 0 4px 4px 0; cursor: pointer; font-size: 0.8rem; line-height: 1;">+</button></div>`;
            const svgDefs = `<defs><filter id="freqGlow"><feGaussianBlur stdDeviation="3" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>`;
            
            const legendHtml = `<div style="display: flex; justify-content: center; gap: 15px; margin-top: 5px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.05); flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 8px; height: 8px; background: #00d2ff; border-radius: 2px; opacity: 0.7;"></span><span style="font-size: 0.65rem; color: #888;">Normal</span></div>
                <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 8px; height: 8px; background: #ff5500; border-radius: 2px; opacity: 0.7;"></span><span style="font-size: 0.65rem; color: #888;">Alta Freq.</span></div>
                <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 8px; height: 8px; background: #5c2b00; border-radius: 2px; opacity: 0.5;"></span><span style="font-size: 0.65rem; color: #888;">Antigo (>3h)</span></div>
                ${!isHourView ? '<div style="display: flex; align-items: center; gap: 6px;"><span style="width: 8px; height: 8px; background: #ffeb3b; border-radius: 2px; box-shadow: 0 0 5px #ffeb3b;"></span><span style="font-size: 0.65rem; color: #888;">Minuto Atual</span></div>' : ''}
                <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 12px; height: 2px; background: #fff; opacity: 0.4;"></span><span style="font-size: 0.65rem; color: #888;">Tend√™ncia</span></div>
                <div style="display: flex; align-items: center; gap: 6px;"><span style="width: 12px; height: 0; border-top: 2px dotted #ff0055; opacity: 0.5;"></span><span style="font-size: 0.65rem; color: #888;">M√©dia</span></div>
            </div>`;
            const hourlyChartHtml = `<div style="margin-top: 20px; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 15px; border: 1px solid #333;"><div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;"><h4 style="margin: 0; color: #ccc; font-size: 0.8rem; text-transform: uppercase;">${freqTitle}</h4><div>${zoomControls}${toggleModeBtn}${toggleBtn}</div></div><div style="overflow-x: auto; padding-bottom: 5px;"><svg viewBox="0 0 ${chartW_freq} ${chartH_freq}" preserveAspectRatio="none" style="width: ${frequencyZoomLevel === 1 ? '100%' : (chartW_freq + 'px')}; height: 100px;">${svgDefs}${bars_freq}${avgLineSvg}<path d="${maPath}" fill="none" stroke="#fff" stroke-width="2" opacity="0.4" stroke-linejoin="round" /></svg></div>${legendHtml}${predictionHtml}</div>`;

            let countdownHtml = '', minutesSinceLast = 0;
            if (latestGameTime && whiteTimes.length > 0) {
                const lastWhiteTime = whiteTimes[whiteTimes.length - 1];
                minutesSinceLast = Math.floor((latestGameTime - lastWhiteTime) / 60000);
                
                // Reseta o hist√≥rico se mudou o ciclo (saiu um novo branco)
                if (lastWhiteTime.getTime() !== currentCycleStartTime) {
                    cycleMonitorHistory = [];
                    currentCycleStartTime = lastWhiteTime.getTime();
                }
                
                // --- L√≥gica para encontrar o pr√≥ximo alvo v√°lido (pulando LOSS e filtros) ---
                let activeMultiplier = 1;
                let lastLossMultiplier = null;
                const useFilter = document.getElementById('assertivenessFilterToggle').checked;
                
                while (activeMultiplier <= 50) {
                    const tTime = new Date(lastWhiteTime.getTime() + (avg * activeMultiplier) * 60000);
                    
                    // Verifica Filtro
                    if (useFilter && !bestMinutes.includes(tTime.getMinutes())) {
                        activeMultiplier++;
                        continue;
                    }

                    // Verifica se j√° √© LOSS (passou do tempo e deu 6 entradas sem branco)
                    let isLoss = false;
                    if (latestGameTime >= tTime) {
                        let eCount = 0;
                        let fWhite = false;
                        for (const res of fullResults) {
                            const [d, m, y] = res.date.split('/').map(Number);
                            const [h, min] = res.time.split(':').map(Number);
                            const rDate = new Date(y, m - 1, d, h, min);
                            if (rDate >= tTime) {
                                eCount++;
                                if (res.roll === 0) { fWhite = true; break; }
                                if (eCount >= 6) break; 
                            }
                        }
                        if (!fWhite && eCount >= 6) isLoss = true;
                    }

                    if (isLoss) {
                        // Registra o LOSS no hist√≥rico antes de pular para o pr√≥ximo
                        const alreadyExists = cycleMonitorHistory.some(item => item.targetTime.getTime() === tTime.getTime());
                        if (!alreadyExists) {
                            cycleMonitorHistory.push({ targetTime: tTime, result: 'LOSS' });
                        }
                        lastLossMultiplier = activeMultiplier;
                        activeMultiplier++;
                    }
                    else break;
                }

                const remaining = (avg * activeMultiplier) - minutesSinceLast;
                
                // Atualiza o t√≠tulo da aba com o tempo restante para facilitar monitoramento em segundo plano
                document.title = remaining > 0 ? `[${remaining}m] Ciclo Mercado` : `[AGORA!] Ciclo Mercado`;

                // Calcula o hor√°rio futuro estimado
                const estimatedTime = new Date(new Date().getTime() + remaining * 60000);
                const estimatedTimeStr = `${estimatedTime.getHours().toString().padStart(2, '0')}:${estimatedTime.getMinutes().toString().padStart(2, '0')}`;

                // --- NOVAS REGRAS DE SEGURAN√áA E ASSERTIVIDADE ---
                // 1. Regra de Matura√ß√£o: Evita entradas muito cedo no ciclo (antes de 75% da m√©dia)
                const maturationThreshold = Math.floor(avg * activeMultiplier * 0.75);
                const isMature = minutesSinceLast >= maturationThreshold;
                
                // 2. Regra de Qualidade do Minuto: Verifica se o minuto alvo tem boa taxa de brancos
                const targetMin = estimatedTime.getMinutes();
                const minStats = minuteTotals[targetMin] > 0 ? (minuteWhites[targetMin] / minuteTotals[targetMin]) : 0;
                const isStrongMinute = minStats >= (globalRate * 1.2); // 20% acima da m√©dia global
                const isWeakMinute = minStats < (globalRate * 0.8); // 20% abaixo da m√©dia global

                // 3. Regra de Tend√™ncia: Verifica se os ciclos recentes est√£o maiores que a m√©dia
                const recentAvg = recentIntervals.slice(-5).reduce((a,b)=>a+b,0) / 5;
                const isTrendHigh = recentAvg > (avg * 1.15);

                // 4. Regra de REC (Recupera√ß√£o ap√≥s sequ√™ncias de Loss)
                let consecutiveLosses = 0;
                for (let i = cycleMonitorHistory.length - 1; i >= 0; i--) {
                    if (cycleMonitorHistory[i].result === 'LOSS') consecutiveLosses++;
                    else break;
                }

                let statusColor = '#00ff88'; 
                let statusText = `~ ${estimatedTimeStr} (em ${remaining} min)`;
                let safetyBadge = '';
                let animationStyle = '';

                if (consecutiveLosses > 2) {
                    statusColor = '#a100ff'; // Roxo para REC
                    statusText = 'MODO RECUPERA√á√ÉO üõë';
                    safetyBadge = '<span style="background:rgba(161,0,255,0.15); color:#a100ff; border:1px solid #a100ff; font-size:0.6rem; padding:2px 6px; border-radius:4px; margin-left:10px;">AGUARDE NOVA AN√ÅLISE</span>';
                    animationStyle = 'opacity: 0.8;';
                } else if (remaining <= 0) {
                    statusColor = '#ff0055'; // Vermelho para atrasado
                    statusText = `ATRASADO H√Å ${Math.abs(remaining)} MIN`;
                    animationStyle = 'animation: pulse-text 1.5s infinite alternate;';
                    safetyBadge = '<span style="background:rgba(255,0,85,0.1); color:#ff0055; border:1px solid #ff0055; font-size:0.6rem; padding:2px 6px; border-radius:4px; margin-left:10px;">CR√çTICO</span>';
                } else if (!isMature) {
                    statusColor = '#888'; // Cinza para aguardando
                    statusText = `Aguardando Matura√ß√£o (${Math.round((minutesSinceLast/maturationThreshold)*100)}%)`;
                    safetyBadge = '<span style="background:rgba(255,255,255,0.05); color:#aaa; border:1px solid #555; font-size:0.6rem; padding:2px 6px; border-radius:4px; margin-left:10px;">‚è≥ CEDO</span>';
                } else {
                    // Ciclo Maduro
                    if (remaining < 5) {
                        statusColor = '#ff9800'; // Amarelo para pr√≥ximo
                        animationStyle = 'animation: pulse-text 1.5s infinite alternate;';
                    }
                    
                    // Badges de Qualidade
                    if (isStrongMinute) {
                        safetyBadge = '<span style="background:rgba(0,255,136,0.15); color:#00ff88; border:1px solid #00ff88; font-size:0.6rem; padding:2px 6px; border-radius:4px; margin-left:10px;">üõ°Ô∏è MINUTO FORTE</span>';
                    } else if (isWeakMinute) {
                        safetyBadge = '<span style="background:rgba(255,152,0,0.15); color:#ff9800; border:1px solid #ff9800; font-size:0.6rem; padding:2px 6px; border-radius:4px; margin-left:10px;">‚ö†Ô∏è MINUTO FRACO</span>';
                    } else {
                        safetyBadge = '<span style="background:rgba(0,210,255,0.15); color:#00d2ff; border:1px solid #00d2ff; font-size:0.6rem; padding:2px 6px; border-radius:4px; margin-left:10px;">‚öñÔ∏è NORMAL</span>';
                    }

                    if (isTrendHigh) {
                         safetyBadge += '<span style="background:rgba(255,152,0,0.15); color:#ff9800; border:1px solid #ff9800; font-size:0.6rem; padding:2px 6px; border-radius:4px; margin-left:5px;">üìà CICLOS LONGOS</span>';
                    }
                }

                let progressPercent = Math.min(100, (minutesSinceLast / (avg * activeMultiplier)) * 100);
                countdownHtml = `<div style="margin-bottom: 20px; background: rgba(0,0,0,0.3); border: 1px solid #333; border-radius: 8px; padding: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px; align-items: center;">
                        <span style="color: #aaa; font-size: 0.9rem;">Pr√≥ximo Branco Estimado:</span>
                        <div style="display:flex; align-items:center;">
                            <span style="color: ${statusColor}; font-weight: bold; font-size: 1.1rem; ${animationStyle}">${statusText}</span>
                            ${safetyBadge}
                        </div>
                    </div>
                    <div style="width: 100%; height: 8px; background: #222; border-radius: 4px; overflow: hidden;"><div style="width: ${progressPercent}%; height: 100%; background: ${statusColor}; transition: width 0.5s;"></div></div>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.75rem; color: #666;"><span>√öltimo: ${minutesSinceLast}m atr√°s</span><span>M√©dia: ${avg}m</span></div>
                </div>
                <style>@keyframes pulse-text { 0% { opacity: 0.8; } 100% { opacity: 1; text-shadow: 0 0 8px; } }</style>`;

                // --- Monitoramento de Entrada (6 Alvos Futuros) ---
                let targetsHtml = '<div class="targets-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">';
                let targetsFound = 0;
                let cycleMultiplier = activeMultiplier; // Come√ßa do alvo ativo
                
                // Se o √∫ltimo alvo foi um LOSS, come√ßa a exibir dele para mostrar o resultado
                if (lastLossMultiplier !== null && lastLossMultiplier === activeMultiplier - 1) {
                    cycleMultiplier = lastLossMultiplier;
                }
                
                // Busca at√© 6 alvos
                while (targetsFound < 6 && cycleMultiplier <= activeMultiplier + 30) {
                    const targetTime = new Date(lastWhiteTime.getTime() + (avg * cycleMultiplier) * 60000);
                    const targetMinute = targetTime.getMinutes();
                    
                    // Se filtro ativo e minuto n√£o √© bom, pula para o pr√≥ximo ciclo
                    if (useFilter && !bestMinutes.includes(targetMinute)) {
                        cycleMultiplier++;
                        continue;
                    }

                    targetsFound++;
                    
                    const targetTimeStr = `${targetTime.getHours().toString().padStart(2, '0')}:${targetTime.getMinutes().toString().padStart(2, '0')}`;

                    let foundWhite = false;
                    let status = 'AGUARDANDO';
                    let resultText = 'PENDENTE';
                    let resultClass = 'pending';
                    let borderColor = '#333';
                    let statusColor = '#aaa';
                    
                    let entriesCount = 0;
                    const maxEntries = 6; // Limite de 6 entradas (pedras)

                    if (latestGameTime >= targetTime) {
                        for (const res of fullResults) {
                            const [d, m, y] = res.date.split('/').map(Number);
                            const [h, min] = res.time.split(':').map(Number);
                            const resDate = new Date(y, m - 1, d, h, min);
                            
                            if (resDate >= targetTime) {
                                entriesCount++;
                                if (res.roll === 0) { foundWhite = true; break; }
                                if (entriesCount >= maxEntries) break;
                            }
                        }

                        if (foundWhite) { 
                            status = 'FINALIZADO'; resultText = 'WIN ü§ë'; resultClass = 'win'; borderColor = 'rgba(0, 255, 136, 0.3)'; statusColor = '#00ff88';
                        } else if (entriesCount >= maxEntries) { 
                            status = 'FINALIZADO'; resultText = 'LOSS ‚ùå'; resultClass = 'loss'; borderColor = 'rgba(255, 0, 85, 0.3)'; statusColor = '#ff0055';
                        } else { 
                            status = 'ANALISANDO'; resultText = `... (${entriesCount}/${maxEntries})`; borderColor = 'rgba(0, 210, 255, 0.3)'; statusColor = '#00d2ff';
                        }
                    }
                    
                    // Adiciona ao hist√≥rico se o ciclo foi finalizado e toca som de WIN
                    if (status === 'FINALIZADO') {
                        const alreadyExists = cycleMonitorHistory.some(item => item.targetTime.getTime() === targetTime.getTime());
                        if (!alreadyExists) {
                            cycleMonitorHistory.push({
                                targetTime: targetTime,
                                result: foundWhite ? 'WIN' : 'LOSS'
                            });
                            if (cycleMonitorHistory.length > 100) cycleMonitorHistory.shift(); // Mant√©m os √∫ltimos 100 para an√°lise prolongada

                            // Toca o som se for um novo WIN
                            if (foundWhite) {
                                playWinAlertSound();
                                sendNotification("WIN - Ciclo de Mercado", `Alvo confirmado √†s ${targetTimeStr}!`);
                            }
                        }
                    }

                    const assertivenessBadge = bestMinutes.includes(targetMinute) 
                        ? '<span style="font-size:0.6rem; color:#00ff88; border:1px solid #00ff88; padding:1px 3px; border-radius:3px; margin-left:5px;">‚òÖ</span>' 
                        : '';

                    // C√°lculo do progresso circular
                    const totalInterval = avg * cycleMultiplier;
                    let percent = Math.min(100, Math.max(0, (minutesSinceLast / totalInterval) * 100));
                    let ringColor = '#00d2ff';
                    if (status === 'FINALIZADO') { percent = 100; ringColor = foundWhite ? '#00ff88' : '#ff0055'; }
                    else if (percent > 90) ringColor = '#ff9800';

                    const radius = 10;
                    const circumference = 2 * Math.PI * radius;
                    const offset = circumference - (percent / 100) * circumference;
                    const progressSvg = `<div style="position: absolute; top: 5px; right: 5px; width: 26px; height: 26px;">
                        <svg width="26" height="26" viewBox="0 0 26 26"><circle cx="13" cy="13" r="${radius}" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2.5" /><circle cx="13" cy="13" r="${radius}" fill="none" stroke="${ringColor}" stroke-width="2.5" stroke-dasharray="${circumference}" stroke-dashoffset="${offset}" class="progress-ring-circle" /></svg>
                        <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 0.45rem; color: #aaa;">${Math.round(percent)}%</div>
                    </div>`;

                    targetsHtml += `
                        <div style="background: rgba(0,0,0,0.4); padding: 10px 5px; border-radius: 8px; border: 1px solid ${borderColor}; text-align: center; display: flex; flex-direction: column; justify-content: center; position: relative;">
                            ${progressSvg}
                            <div style="font-size: 0.65rem; color: #888; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 1px; text-align: left; padding-left: 5px;">ALVO ${targetsFound} (${cycleMultiplier}x)</div>
                            <div style="font-size: 1.2rem; font-weight: bold; color: #fff; margin-bottom: 4px; display:flex; align-items:center; justify-content:center;">${targetTimeStr}${assertivenessBadge}</div>
                            <div style="font-size: 0.65rem; color: ${statusColor}; font-weight: bold; margin-bottom: 2px;">${status}</div>
                            <div class="${resultClass}" style="font-weight: bold; font-size: 0.9rem;">${resultText}</div>
                        </div>
                    `;
                    cycleMultiplier++;
                }
                
                targetsHtml += '</div><style>.win { color: #00ff88; text-shadow: 0 0 8px rgba(0,255,136,0.4); } .loss { color: #ff0055; text-shadow: 0 0 8px rgba(255,0,85,0.4); } .pending { color: #666; }</style>';
                
                countdownHtml += targetsHtml;
            }

            // --- Gr√°fico de Distribui√ß√£o de Probabilidade ---
            const maxIntervalAxis = Math.max(max, minutesSinceLast) + 15;
            const distMap = new Array(maxIntervalAxis).fill(0);
            intervals.forEach(i => { if(i < distMap.length) distMap[i]++; });
            
            // Suaviza√ß√£o (M√©dia M√≥vel)
            const smoothed = distMap.map((v, i, arr) => {
                const prev = arr[i-1] || 0;
                const next = arr[i+1] || 0;
                return (prev + v + next) / 3;
            });
            const distMaxVal = Math.max(...smoothed, 1);

            // C√°lculo de Probabilidade (Pr√≥ximos 5 min)
            let probNext5 = 0, sumRemaining = 0, sumNext5 = 0;
            for (let i = minutesSinceLast; i < smoothed.length; i++) {
                sumRemaining += smoothed[i];
                if (i < minutesSinceLast + 5) sumNext5 += smoothed[i];
            }
            if (sumRemaining > 0) probNext5 = (sumNext5 / sumRemaining) * 100;
            
            const distW = 800, distH = 100;
            const distXScale = distW / (distMap.length - 1 || 1);
            
            let distPath = `M 0 ${distH}`;
            smoothed.forEach((val, i) => {
                const x = i * distXScale;
                const y = distH - ((val / distMaxVal) * (distH - 10)); 
                distPath += ` L ${x} ${y}`;
            });
            distPath += ` L ${distW} ${distH} Z`;
            
            const markerX = Math.min(minutesSinceLast * distXScale, distW);
            const avgX = Math.min(avg * distXScale, distW);
            
            const probChartHtml = `
                <div style="margin-bottom: 20px; background: rgba(0,0,0,0.3); border: 1px solid #333; border-radius: 8px; padding: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px; align-items: flex-end;">
                        <div>
                            <h4 title="Este gr√°fico mostra a probabilidade estat√≠stica de sair um branco em cada minuto futuro, baseando-se no hist√≥rico de intervalos passados. Picos mais altos indicam momentos de maior chance." style="margin: 0 0 5px 0; color: #ccc; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; cursor: help; border-bottom: 1px dotted #666; width: fit-content;">Distribui√ß√£o de Probabilidade</h4>
                            <div style="font-size: 0.75rem; color: #ff9800; font-weight: bold; display: flex; align-items: center; gap: 5px;"><span>üìç VOC√ä EST√Å AQUI:</span> <span style="font-size: 1rem; color: #fff;">${minutesSinceLast}m</span></div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 0.65rem; color: #aaa; text-transform: uppercase; margin-bottom: 3px;">Chance (Pr√≥x. 5 min)</div>
                            <div style="font-size: 1.4rem; font-weight: bold; color: ${probNext5 > 40 ? '#00ff88' : '#fff'}; line-height: 1; text-shadow: 0 0 10px ${probNext5 > 40 ? 'rgba(0,255,136,0.3)' : 'rgba(255,255,255,0.1)'};">${probNext5.toFixed(1)}%</div>
                            <div style="width: 80px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; margin-top: 4px; margin-left: auto; overflow: hidden;">
                                <div style="width: ${Math.min(100, probNext5)}%; height: 100%; background: ${probNext5 > 40 ? '#00ff88' : '#fff'}; box-shadow: 0 0 5px ${probNext5 > 40 ? '#00ff88' : 'transparent'}; transition: width 0.5s;"></div>
                            </div>
                        </div>
                    </div>
                    <svg viewBox="0 0 ${distW} ${distH}" preserveAspectRatio="none" style="width: 100%; height: 100px; overflow: visible;"><defs><linearGradient id="gradDist" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#00d2ff;stop-opacity:0.4" /><stop offset="100%" style="stop-color:#00d2ff;stop-opacity:0" /></linearGradient><filter id="glowDist"><feGaussianBlur stdDeviation="2.5" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><path d="${distPath}" fill="url(#gradDist)" stroke="#00d2ff" stroke-width="2" filter="url(#glowDist)" /><line x1="${avgX}" y1="0" x2="${avgX}" y2="${distH}" stroke="#a100ff" stroke-width="2" stroke-dasharray="3,3" opacity="0.8" /><text x="${avgX}" y="-5" fill="#a100ff" font-size="10" text-anchor="middle" font-weight="bold">M√âDIA</text><line x1="${markerX}" y1="0" x2="${markerX}" y2="${distH}" stroke="#ff9800" stroke-width="2" stroke-dasharray="5,5" /><text x="${markerX}" y="-5" fill="#ff9800" font-size="10" text-anchor="middle" font-weight="bold">AGORA</text><circle cx="${markerX}" cy="${distH}" r="4" fill="#ff9800" class="chart-dot" /></svg>
                    <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: #666; margin-top: 5px;"><span>0m</span><span>${Math.round(maxIntervalAxis/2)}m</span><span>${maxIntervalAxis}m</span></div>
                </div>`;

            // --- L√≥gica e HTML do Rastreio de Branco ---
            const rastreioSums = [];
            for (let i = 0; i < fullResults.length; i++) {
                if (fullResults[i].roll === 0) {
                    if (i > 0 && i < fullResults.length - 1) {
                        const prevRoll = fullResults[i - 1].roll;
                        const nextRoll = fullResults[i + 1].roll;
                        const whiteMinute = parseInt(fullResults[i].time.split(':')[1]);
                        const minuteLastDigit = whiteMinute % 10;
                        const sum = prevRoll + nextRoll + minuteLastDigit;
                        rastreioSums.push({ sum: sum, time: fullResults[i].time });
                    }
                }
            }

            let rastreioHtml = '';
            if (rastreioSums.length > 0) {
                const lastSum = rastreioSums[rastreioSums.length - 1];
                const allSums = rastreioSums.map(s => s.sum);
                const avgSum = Math.round(allSums.reduce((a, b) => a + b, 0) / allSums.length);
                const sumCounts = {};
                allSums.forEach(s => { sumCounts[s] = (sumCounts[s] || 0) + 1; });
                const hotSums = Object.entries(sumCounts).sort(([, a], [, b]) => b - a).slice(0, 5).map(([sum, count]) => ({ sum, count }));
                
                // --- C√°lculo de "Branco 100%" (Padr√£o Mais Forte) ---
                // 1. Identifica a pedra gatilho (que antecede o branco) mais frequente
                const preRollCounts = {};
                for (let i = 1; i < fullResults.length; i++) {
                    if (fullResults[i].roll === 0) {
                        const preRoll = fullResults[i-1].roll;
                        if (preRoll !== 0) {
                            preRollCounts[preRoll] = (preRollCounts[preRoll] || 0) + 1;
                        }
                    }
                }
                const sortedPreRolls = Object.entries(preRollCounts).sort(([, a], [, b]) => b - a);
                
                let bestPreRollObj = sortedPreRolls.length > 0 ? sortedPreRolls[0] : null;
                let smartSkipActive = false;
                
                // L√≥gica Smart Trigger: Se ativo e o melhor gatilho for igual ao √∫ltimo vencedor, tenta pegar o pr√≥ximo
                if (smartTriggerMode && lastWinningTrigger !== null && bestPreRollObj && parseInt(bestPreRollObj[0]) === lastWinningTrigger) {
                    if (sortedPreRolls.length > 1) {
                        bestPreRollObj = sortedPreRolls[1];
                        smartSkipActive = true;
                    }
                }

                const bestPreRoll = bestPreRollObj ? bestPreRollObj[0] : '--';
                const bestPreRollCount = bestPreRollObj ? bestPreRollObj[1] : 0;
                const bestSum = hotSums.length > 0 ? hotSums[0].sum : '--';

                // --- Novas Fun√ß√µes: An√°lise de Cor Antecedente e Par/√çmpar ---
                let preWhiteRed = 0, preWhiteBlack = 0, preWhiteNeighbor = 0;
                const zeroNeighbors = [4, 11, 12, 5]; // N√∫meros vizinhos do 0 na fita (Double)
                for (let i = 1; i < fullResults.length; i++) {
                    if (fullResults[i].roll === 0) {
                        const prevRoll = fullResults[i-1].roll;
                        if (prevRoll >= 1 && prevRoll <= 7) preWhiteRed++;
                        else if (prevRoll >= 8 && prevRoll <= 14) preWhiteBlack++;
                        if (zeroNeighbors.includes(prevRoll)) preWhiteNeighbor++;
                    }
                }
                const totalPreColor = preWhiteRed + preWhiteBlack;
                const redPct = totalPreColor > 0 ? Math.round((preWhiteRed / totalPreColor) * 100) : 0;
                const blackPct = totalPreColor > 0 ? 100 - redPct : 0;

                let oddSums = 0, evenSums = 0;
                rastreioSums.forEach(s => { if (s.sum % 2 === 0) evenSums++; else oddSums++; });
                const totalSumsCount = oddSums + evenSums;
                const evenPct = totalSumsCount > 0 ? Math.round((evenSums / totalSumsCount) * 100) : 0;
                const oddPct = totalSumsCount > 0 ? 100 - evenPct : 0;
                const neighborPct = totalPreColor > 0 ? Math.round((preWhiteNeighbor / totalPreColor) * 100) : 0;

                // --- Tend√™ncia de Repeti√ß√£o ---
                let isRepetition = false;
                let repeatedNumber = null;
                if (fullResults.length >= 2) {
                    const last = fullResults[fullResults.length - 1];
                    const prev = fullResults[fullResults.length - 2];
                    if (last.roll === prev.roll) {
                        isRepetition = true;
                        repeatedNumber = last.roll;
                    }
                }

                // --- Padr√£o de Espelhos (Invers√£o) ---
                // Identifica sequ√™ncias inversas (ex: 1-2 e 2-1) que puxam branco
                let mirrorCount = 0;
                let topMirrorPair = null;
                let maxMirrorFreq = 0;
                const pairCounts = {};
                
                for (let i = 2; i < fullResults.length; i++) {
                    if (fullResults[i].roll === 0) {
                        const r1 = fullResults[i-2].roll;
                        const r2 = fullResults[i-1].roll;
                        if (r1 !== r2) { // Ignora repeti√ß√µes (j√° tratadas em outro indicador)
                            const key = `${r1}-${r2}`;
                            pairCounts[key] = (pairCounts[key] || 0) + 1;
                            const mirrorKey = `${r2}-${r1}`;
                            if (pairCounts[mirrorKey]) {
                                mirrorCount++; // Conta apenas se o inverso j√° existe
                                if (pairCounts[key] + pairCounts[mirrorKey] > maxMirrorFreq) {
                                    maxMirrorFreq = pairCounts[key] + pairCounts[mirrorKey];
                                    topMirrorPair = `${r1} ‚Üî ${r2}`;
                                }
                            }
                        }
                    }
                }
                const totalWhites = fullResults.filter(r => r.roll === 0).length;
                const mirrorPct = totalWhites > 0 ? Math.round((mirrorCount / totalWhites) * 100) : 0;

                // --- Sequ√™ncia Mestra (3 Cores) ---
                const colorPatternCounts = {};
                const colorPatternTotalOccurrences = {};
                for (let i = 3; i < fullResults.length; i++) {
                    const c1 = identificarCorCiclo(fullResults[i-3].roll);
                    const c2 = identificarCorCiclo(fullResults[i-2].roll);
                    const c3 = identificarCorCiclo(fullResults[i-1].roll);
                    const mapC = c => c === 'vermelho' ? 'V' : (c === 'preto' ? 'P' : 'B');
                    const key = `${mapC(c1)}-${mapC(c2)}-${mapC(c3)}`;
                    
                    colorPatternTotalOccurrences[key] = (colorPatternTotalOccurrences[key] || 0) + 1;

                    if (fullResults[i].roll === 0) {
                        colorPatternCounts[key] = (colorPatternCounts[key] || 0) + 1;
                    }
                }
                
                // Filtra padr√µes com mais de 50% de acerto
                const validPatterns = Object.keys(colorPatternCounts)
                    .map(key => ({
                        key: key,
                        count: colorPatternCounts[key],
                        accuracy: Math.round((colorPatternCounts[key] / (colorPatternTotalOccurrences[key] || 1)) * 100)
                    }))
                    .filter(p => p.accuracy > 50);

                // Ordena os padr√µes v√°lidos pela contagem de ocorr√™ncias (o mais frequente entre os de alta assertividade)
                validPatterns.sort((a, b) => b.count - a.count);

                const bestPatternObj = validPatterns.length > 0 ? validPatterns[0] : null;
                const bestPattern = bestPatternObj ? bestPatternObj.key : '---';
                const bestPatternAccuracy = bestPatternObj ? bestPatternObj.accuracy : 0;
                
                const patternAccClass = bestPatternAccuracy > 80 ? 'high-accuracy-anim' : '';
                const patternAccStyle = bestPatternAccuracy > 80 ? 'font-size: 0.8rem;' : 'font-size: 0.8rem; color: #00ff88; font-weight: bold;';

                const formatPattern = (p) => {
                    if (p === '---') return p;
                    return p.split('-').map(c => c === 'V' ? 'üî¥' : (c === 'P' ? '‚ö´' : '‚ö™')).join('');
                };
                let isPatternActive = false;
                if (fullResults.length >= 3) {
                    const l1 = identificarCorCiclo(fullResults[fullResults.length-3].roll);
                    const l2 = identificarCorCiclo(fullResults[fullResults.length-2].roll);
                    const l3 = identificarCorCiclo(fullResults[fullResults.length-1].roll);
                    const mapC = c => c === 'vermelho' ? 'V' : (c === 'preto' ? 'P' : 'B');
                    const currentPattern = `${mapC(l1)}-${mapC(l2)}-${mapC(l3)}`;
                    if (currentPattern === bestPattern && bestPattern !== '---') isPatternActive = true;
                }

                // --- Minuto da Sorte ---
                const minuteDigitCounts = Array(10).fill(0);
                for (let i = 0; i < fullResults.length; i++) { if (fullResults[i].roll === 0) { const min = parseInt(fullResults[i].time.split(':')[1]); if (!isNaN(min)) minuteDigitCounts[min % 10]++; } }
                const maxMinCount = Math.max(...minuteDigitCounts);
                const luckyDigits = minuteDigitCounts.map((c, i) => c === maxMinCount ? i : -1).filter(i => i !== -1);
                const luckyDigitStr = luckyDigits.join(', ');

                // --- Soma M√°gica (Soma dos 2 vizinhos) ---
                const neighborSumCounts = {};
                const neighborSumTotalOccurrences = {};
                for (let i = 2; i < fullResults.length; i++) {
                    const sum = fullResults[i-1].roll + fullResults[i-2].roll;
                    neighborSumTotalOccurrences[sum] = (neighborSumTotalOccurrences[sum] || 0) + 1;

                    if (fullResults[i].roll === 0) {
                        neighborSumCounts[sum] = (neighborSumCounts[sum] || 0) + 1;
                    }
                }
                
                // Filtra somas com mais de 50% de acerto
                const validSums = Object.keys(neighborSumCounts)
                    .map(key => ({
                        key: key,
                        count: neighborSumCounts[key],
                        accuracy: Math.round((neighborSumCounts[key] / (neighborSumTotalOccurrences[key] || 1)) * 100)
                    }))
                    .filter(s => s.accuracy > 50);
                
                // Ordena as somas v√°lidas pela contagem de ocorr√™ncias
                validSums.sort((a, b) => b.count - a.count);

                const magicSumObj = validSums.length > 0 ? validSums[0] : null;
                const magicSum = magicSumObj ? magicSumObj.key : '--';
                const magicSumAccuracy = magicSumObj ? magicSumObj.accuracy : 0;
                
                const magicAccClass = magicSumAccuracy > 80 ? 'high-accuracy-anim' : '';
                const magicAccStyle = magicSumAccuracy > 80 ? 'font-size: 0.8rem;' : 'font-size: 0.8rem; color: #a100ff; font-weight: bold;';

                let isMagicSumActive = false;
                if (fullResults.length >= 2) { const currentSum = fullResults[fullResults.length - 1].roll + fullResults[fullResults.length - 2].roll; if (String(currentSum) === magicSum && magicSum !== '--') { isMagicSumActive = true; } }

                // --- Entropia do Sistema (F√≠sica) ---
                const entropyLookback = 20;
                const recentNonWhite = fullResults.filter(r => r.roll !== 0).slice(0, entropyLookback);
                let colorChanges = 0;
                if (recentNonWhite.length > 1) {
                    for (let i = 1; i < recentNonWhite.length; i++) {
                        const c1 = identificarCorCiclo(recentNonWhite[i-1].roll);
                        const c2 = identificarCorCiclo(recentNonWhite[i].roll);
                        if (c1 !== c2) {
                            colorChanges++;
                        }
                    }
                }
                // A entropia √© a quantidade de mudan√ßas sobre o n√∫mero m√°ximo de mudan√ßas poss√≠veis
                const maxChanges = recentNonWhite.length > 1 ? recentNonWhite.length - 1 : 1;
                const entropyPercentage = Math.round((colorChanges / maxChanges) * 100);
                const isEntropyActive = entropyPercentage >= 75; // Gatilho se 75%+ das √∫ltimas rodadas alternaram

                // --- Resson√¢ncia Harm√¥nica (F√≠sica Te√≥rica) ---
                let harmonicPct = 0;
                let isHarmonicActive = false;
                if (fullResults.length >= 3) {
                    const r1 = fullResults[fullResults.length-1].roll;
                    const r2 = fullResults[fullResults.length-2].roll;
                    const r3 = fullResults[fullResults.length-3].roll;
                    const sum3 = r1 + r2 + r3;
                    
                    // Verifica alinhamento com Fibonacci (Soma dos 3 √∫ltimos)
                    const fibs = [2, 3, 5, 8, 13, 21, 34, 55];
                    const isFib = fibs.includes(sum3);
                    
                    // Calcula "Volatilidade Qu√¢ntica" (Diferen√ßa m√©dia quadr√°tica)
                    const diff1 = Math.pow(r1 - r2, 2);
                    const diff2 = Math.pow(r2 - r3, 2);
                    const volatility = Math.sqrt((diff1 + diff2) / 2);
                    const maxVol = 14; // Max diff possible roughly
                    const volPct = (volatility / maxVol) * 100;
                    
                    harmonicPct = Math.round(volPct);
                    if (isFib) {
                        harmonicPct = Math.min(100, harmonicPct + 30); // Bonus por Fibonacci
                        if (harmonicPct > 70) isHarmonicActive = true;
                    } else if (harmonicPct > 80) {
                        isHarmonicActive = true;
                    }
                }

                // --- Press√£o de Aposta (Simula√ß√£o Contrarian) ---
                let pressureRed = 0;
                let pressureBlack = 0;
                let pressureTotal = 0;
                for (let i = 0; i < fullResults.length && pressureTotal < 15; i++) {
                    const r = fullResults[i].roll;
                    if (r !== 0) {
                        if (r >= 1 && r <= 7) pressureRed++;
                        else pressureBlack++;
                        pressureTotal++;
                    }
                }
                let crowdSide = 'NEUTRO';
                let contrarianSide = '---';
                let pressureVal = 50;
                let pressureColor = '#888';
                if (pressureTotal > 0) {
                    const redRatio = pressureRed / pressureTotal;
                    if (redRatio >= 0.6) { crowdSide = 'PRETO ‚ö´'; contrarianSide = 'VERMELHO üî¥'; pressureVal = Math.round(redRatio * 100); pressureColor = '#ff0055'; }
                    else if (redRatio <= 0.4) { crowdSide = 'VERMELHO üî¥'; contrarianSide = 'PRETO ‚ö´'; pressureVal = Math.round((1 - redRatio) * 100); pressureColor = '#fff'; }
                }

                // --- Alerta de Gatilho ---
                let triggerAlert = '';
                const currentEntryIndex = fullResults.length - 1;
                
                // 0. Recupera o √≠ndice correto baseado no tempo (Corre√ß√£o de deslocamento de array)
                let triggerStartIndex = -1;
                if (triggerState.isActive && triggerState.startEntryTime) {
                    for (let i = fullResults.length - 1; i >= 0; i--) {
                        if (fullResults[i].date + fullResults[i].time === triggerState.startEntryTime) {
                            triggerStartIndex = i;
                            break;
                        }
                    }
                    if (triggerStartIndex === -1) triggerState.isActive = false;
                }

                // A. Se est√°vamos mostrando um resultado, verifica se √© hora de esconder.
                if (triggerState.showResultUntilIndex !== -1 && currentEntryIndex >= triggerState.showResultUntilIndex) {
                    triggerState.showResultUntilIndex = -1;
                    triggerState.result = null;
                }

                // B. Se um gatilho est√° ativo, verifica seu status.
                if (triggerState.isActive && triggerStartIndex !== -1) {
                    const entriesPassed = currentEntryIndex - triggerStartIndex;

                    // Verifica por um WIN dentro da janela de 6 entradas
                    if (triggerState.result !== 'WIN') {
                        for (let i = 1; i <= entriesPassed && i <= ENTRIES_TO_WAIT; i++) {
                            const checkIndex = triggerStartIndex + i;
                            if (fullResults[checkIndex] && fullResults[checkIndex].roll === 0) {
                                triggerState.result = 'WIN';
                                break;
                            }
                        }
                    }

                    // Se ganhou ou se as 6 entradas passaram (loss)
                    if (triggerState.result === 'WIN' || entriesPassed >= ENTRIES_TO_WAIT) {
                        if (triggerState.result === 'WIN') {
                            triggerWins++;
                            triggerHistory.push('WIN');
                            lastWinningTrigger = triggerState.triggerNumber; // Salva o gatilho que venceu
                        } else {
                            triggerState.result = 'LOSS';
                            triggerLosses++;
                            triggerHistory.push('LOSS');
                        }
                        triggerState.isActive = false;
                        if (triggerHistory.length > 5) triggerHistory.shift(); // Mant√©m apenas os √∫ltimos 5
                        triggerState.showResultUntilIndex = -1; // Volta imediatamente a analisar
                    }
                }
                
                // C. Se nenhum gatilho est√° ativo (ou acabou de finalizar), verifica por um novo gatilho IMEDIATAMENTE.
                if (!triggerState.isActive) {
                    const lastResult = fullResults.length > 0 ? fullResults[currentEntryIndex] : null;
                    const isTriggerConditionMet = isSimulatingTrigger || (lastResult && bestPreRoll !== '--' && parseInt(bestPreRoll) === lastResult.roll && lastResult.roll !== 0);
                    
                    if (isTriggerConditionMet) {
                        triggerState.isActive = true;
                        triggerState.startEntryTime = lastResult.date + lastResult.time;
                        triggerState.result = 'PENDING';
                        triggerState.showResultUntilIndex = -1;
                        triggerState.triggerNumber = parseInt(bestPreRoll); // Salva o gatilho atual
                        triggerStartIndex = currentEntryIndex; // Atualiza para exibi√ß√£o imediata
                    }
                }

                const historyItems = triggerHistory.map(result => {
                    const isWin = result === 'WIN';
                    const color = isWin ? '#00ff88' : '#ff0055';
                    const text = isWin ? 'W' : 'L';
                    const bgColor = isWin ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 0, 85, 0.1)';
                    return `<div title="${result}" style="width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; background: ${bgColor}; border: 1px solid ${color}; color: ${color}; border-radius: 50%; font-weight: bold; font-size: 0.8rem; box-shadow: 0 0 5px ${color};">${text}</div>`;
                }).join('');

                // --- NEW: Last 6 Rolls History ---
                const last6Rolls = fullResults.slice(-6);
                const rollsHtml = last6Rolls.map((r, idx) => {
                    const color = identificarCorCiclo(r.roll);
                    let borderColor = '#333';
                    let textColor = '#fff';
                    let shadow = 'none';
                    
                    if (color === 'vermelho') {
                        borderColor = '#ff0055';
                        textColor = '#ff0055';
                        shadow = '0 0 5px rgba(255, 0, 85, 0.2)';
                    } else if (color === 'branco') {
                        borderColor = '#fff';
                        textColor = '#fff';
                        shadow = '0 0 8px rgba(255, 255, 255, 0.4)';
                    } else { // Preto
                        borderColor = '#444';
                        textColor = '#ccc';
                    }
                    
                    const animStyle = idx === last6Rolls.length - 1 ? 'animation: new-roll-pulse 2s infinite;' : '';
                    
                    return `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; width: 40px; height: 45px; background: rgba(0,0,0,0.4); border: 1px solid ${borderColor}; border-radius: 6px; margin: 0 3px; ${animStyle} box-shadow: ${shadow};">
                        <div style="font-size: 1.1rem; font-weight: bold; color: ${textColor}; line-height: 1;">${r.roll}</div>
                        <div style="font-size: 0.6rem; color: #888; margin-top: 2px;">${r.time}</div>
                    </div>`;
                }).join('');

                const placarHtml = `
                    <div style="margin-top: 10px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 15px;">
                        <div style="flex: 1; text-align: center; min-width: 150px;">
                            <div style="font-size: 0.8rem; color: #aaa; margin-bottom: 5px;">PLACAR GATILHO</div>
                            <div style="font-size: 1.5rem; font-weight: bold; margin-bottom: 5px;"><span style="color: #00ff88;">${triggerWins} W</span> - <span style="color: #ff0055;">${triggerLosses} L</span></div>
                            <div style="display: flex; justify-content: center; gap: 8px; align-items: center; min-height: 25px;">${historyItems}</div>
                        </div>
                        <div style="flex: 1.5; text-align: center; min-width: 220px; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 10px;">
                            <div style="font-size: 0.8rem; color: #aaa; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">√öltimos 6 Giros</div>
                            <div style="display: flex; justify-content: center; align-items: center;">${rollsHtml}</div>
                        </div>
                    </div>`;

                if (triggerState.isActive) {
                    const entriesPassed = Math.max(0, currentEntryIndex - triggerStartIndex);

                    const totalMinutes = ENTRIES_TO_WAIT / 2;
                    let statusText = `BUSCANDO BRANCO... (${ENTRIES_TO_WAIT} ENTRADAS)`;
                    let statusColor = "#ffeb3b";
                    let extraInfo = `<div style="font-size: 0.8rem; color: #ccc; margin-top: 2px;">(Total de ${totalMinutes} minutos)</div>`;

                    let animStyle = 'animation: futuristic-search-pulse 2s infinite ease-in-out;';

                    triggerAlert = `<div class="trigger-status-box trigger-active" style="${animStyle} background: radial-gradient(circle, rgba(255,235,59,0.1) 0%, transparent 70%);">
                        <div style="font-weight: bold; color: ${statusColor}; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1px;">${statusText}</div>
                        <div style="font-size: 0.9rem; color: #fff; margin-top: 5px;">Gatilho: <b>${fullResults[triggerStartIndex].roll}</b></div>
                        ${extraInfo}
                    </div>`;
                } else if (triggerState.showResultUntilIndex !== -1) {
                    const isWin = triggerState.result === 'WIN';
                    const resultText = isWin ? '‚úÖ WIN!' : '‚ùå LOSS';
                    const resultColor = isWin ? '#00ff88' : '#ff0055';
                    const resultBg = isWin ? 'rgba(0,255,136,0.1)' : 'rgba(255,0,85,0.1)';
                    triggerAlert = `<div class="trigger-status-box" style="background: ${resultBg}; border: 1px solid ${resultColor};">
                        <div style="font-weight: bold; color: ${resultColor}; font-size: 1.2rem;">${resultText}</div>
                    </div>`;
                } else {
                    let timeSinceLastTriggerText = '';
                    if (bestPreRoll !== '--') {
                        const triggerNum = parseInt(bestPreRoll);
                        let lastTriggerTime = null;
                        for (let i = fullResults.length - 1; i >= 0; i--) {
                            if (fullResults[i].roll === triggerNum) {
                                const [d, m, y] = fullResults[i].date.split('/').map(Number);
                                const [h, min] = fullResults[i].time.split(':').map(Number);
                                lastTriggerTime = new Date(y, m - 1, d, h, min);
                                break;
                            }
                        }
                        if (lastTriggerTime && latestGameTime) {
                            const diffMs = latestGameTime - lastTriggerTime;
                            const diffMins = Math.floor(diffMs / 60000);
                            timeSinceLastTriggerText = `<div style="font-size: 0.65rem; color: #666; margin-top: 2px;">√öltimo visto h√°: <span style="color: #ccc;">${diffMins} min</span></div>`;
                        }
                    }
                    triggerAlert = `<div class="trigger-status-box trigger-waiting">
                        <div class="waiting-text">AGUARDANDO PR√ìXIMO GATILHO...</div>
                        <div style="font-size: 0.7rem; color: #aaa; margin-top: 5px;">Monitorando padr√£o de gatilho (${bestPreRoll})</div>
                        ${timeSinceLastTriggerText}
                    </div>`;
                }

                triggerAlert += placarHtml;

                const historyHtml = rastreioSums.slice(-5).reverse().map(s => 
                    `<div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05);">
                        <span style="font-size: 1.1rem; font-weight: bold; color: #fff;">${s.sum}</span>
                        <span style="font-size: 0.75rem; color: #888;">(${s.time})</span>
                    </div>`
                ).join('');

                const simulateBtn = `<button onclick="simulateTrigger()" style="float: right; background: rgba(255, 0, 85, 0.2); border: 1px solid #ff0055; color: #ff0055; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 0.6rem; transition: all 0.3s;">üîî Testar Alerta</button>`;

                // --- L√≥gica de Consenso (IA) ---
                let consensusScore = 0;
                // Pontua√ß√£o baseada nos indicadores ativos
                if (isPatternActive) consensusScore += 30;      // Sequ√™ncia Mestra (Muito Forte)
                if (isMagicSumActive) consensusScore += 30;     // Soma M√°gica (Muito Forte)
                if (isEntropyActive) consensusScore += 20;      // Entropia (Forte)
                if (isHarmonicActive) consensusScore += 20;     // Resson√¢ncia Harm√¥nica (Forte)
                if (triggerState.isActive) consensusScore += 40;// Gatilho Espec√≠fico Ativo (Fort√≠ssimo)
                
                // Pontua√ß√£o baseada em estat√≠sticas
                if (neighborPct > 35) consensusScore += 10;     // Vizinhos do Zero
                if (mirrorPct > 25) consensusScore += 10;       // Padr√£o Espelho
                
                // Penalidades
                if (isRepetition) consensusScore -= 100;        // Repeti√ß√£o (Perigo/Bloqueio)

                let consensusHtml = '';
                let consensusStatus = 'N√ÉO ENTRAR';
                let consensusColor = '#ff0055';
                let consensusAnim = 'animation: blink-red-text 1s infinite;';
                let consensusIcon = '‚õî';

                // Define o limiar para entrada (30 pontos = pelo menos 1 padr√£o forte ou v√°rios m√©dios)
                if (consensusScore >= 30) {
                    consensusStatus = 'ENTRADA CONFIRMADA';
                    consensusColor = '#00ff88';
                    consensusAnim = 'animation: blink-green-text 0.8s infinite;';
                    consensusIcon = '‚úÖ';
                }

                consensusHtml = `<div style="margin-bottom: 15px; padding: 15px; border: 1px solid ${consensusColor}; background: rgba(0,0,0,0.4); border-radius: 8px; text-align: center; box-shadow: 0 0 20px ${consensusColor}20; position: relative; overflow: hidden;">
                    <div style="font-size: 0.75rem; color: #aaa; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 2px;">An√°lise de Converg√™ncia</div>
                    <div style="font-size: 1.4rem; font-weight: bold; color: ${consensusColor}; ${consensusAnim}">${consensusIcon} ${consensusStatus}</div>
                    <div style="font-size: 0.7rem; color: #666; margin-top: 5px;">For√ßa do Sinal: ${Math.max(0, consensusScore)}%</div>
                </div>`;

                rastreioHtml = `
                    <div style="margin-top: 20px; background: rgba(161, 0, 255, 0.1); border-radius: 8px; padding: 15px; border: 1px solid #a100ff;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;"><h4 style="margin: 0; color: #a100ff; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px;">üîé Rastreio de Branco</h4>${simulateBtn}</div>
                        ${consensusHtml}
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;"><div style="font-size: 0.7rem; color: #aaa;">√öLTIMA SOMA</div><div style="font-size: 2rem; font-weight: bold; color: #fff;">${lastSum.sum}</div><div style="font-size: 0.7rem; color: #666;">(${lastSum.time})</div></div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;"><div style="font-size: 0.7rem; color: #aaa;">M√âDIA DAS SOMAS</div><div style="font-size: 2rem; font-weight: bold; color: #00d2ff;">${avgSum}</div></div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;"><div style="font-size: 0.7rem; color: #aaa; text-align: center; margin-bottom: 5px;">SOMAS QUENTES</div><div style="display: flex; justify-content: center; gap: 8px; flex-wrap: wrap;">${hotSums.map(s => `<span style="background: #a100ff; color: #fff; padding: 3px 8px; border-radius: 4px; font-size: 0.9rem; font-weight: bold;" title="${s.count}x">${s.sum}</span>`).join('')}</div></div>
                            
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 0.7rem; color: #aaa; margin-bottom:5px;">COR ANTECEDENTE</div>
                                <div style="display: flex; height: 6px; border-radius: 3px; overflow: hidden; background: #333;">
                                    <div style="width: ${redPct}%; background: #ff0055;"></div>
                                    <div style="width: ${blackPct}%; background: #fff;"></div>
                                </div>
                                <div style="display: flex; justify-content: space-between; font-size: 0.75rem; margin-top: 5px; font-weight:bold;">
                                    <span style="color: #ff0055;">üî¥ ${redPct}%</span>
                                    <span style="color: #fff;">‚ö´ ${blackPct}%</span>
                                </div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 0.7rem; color: #aaa;">PAR vs √çMPAR (SOMA)</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: #fff; margin: 2px 0;"><span style="color: #00d2ff;">${evenPct}%</span> <span style="font-size:0.8rem; color:#666;">vs</span> <span style="color: #ff9800;">${oddPct}%</span></div>
                                <div style="font-size: 0.6rem; color: #666;">PAR / √çMPAR</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 0.7rem; color: #aaa;">VIZINHOS DO ZERO</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: ${neighborPct > 30 ? '#00ff88' : '#fff'}; margin: 2px 0;">${neighborPct}%</div>
                                <div style="font-size: 0.6rem; color: #666;">(4, 11, 12, 5)</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; ${isRepetition ? 'border: 1px solid #ff0055; background: rgba(255, 0, 85, 0.1);' : ''}">
                                <div style="font-size: 0.7rem; color: #aaa;">TEND√äNCIA DE REPETI√á√ÉO</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: ${isRepetition ? '#ff0055' : '#fff'}; margin: 2px 0; ${isRepetition ? 'animation: pulse-text 0.8s infinite alternate;' : ''}">${isRepetition ? '‚ö†Ô∏è DETECTADO' : 'NORMAL'}</div>
                                <div style="font-size: 0.6rem; color: ${isRepetition ? '#ffcccb' : '#666'};">${isRepetition ? `Sequ√™ncia: ${repeatedNumber}, ${repeatedNumber}` : 'Sem repeti√ß√£o recente'}</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 0.7rem; color: #aaa;">PADR√ÉO ESPELHO</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: ${mirrorPct > 20 ? '#a100ff' : '#fff'}; margin: 2px 0;">${mirrorPct}%</div>
                                <div style="font-size: 0.6rem; color: #666;">${topMirrorPair ? topMirrorPair : 'Sem padr√£o claro'}</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; ${isPatternActive ? 'border: 1px solid #00ff88; box-shadow: 0 0 10px rgba(0,255,136,0.2);' : ''}">
                                <div style="font-size: 0.7rem; color: #aaa;">SEQU√äNCIA MESTRA</div>
                                <div style="display: flex; align-items: baseline; justify-content: center; gap: 8px; margin: 2px 0;">
                                    <div style="font-size: 1.2rem;">${formatPattern(bestPattern)}</div>
                                    <div class="${patternAccClass}" style="${patternAccStyle}">(${bestPatternAccuracy}%)</div>
                                </div>
                                <div style="font-size: 0.6rem; color: ${isPatternActive ? '#00ff88' : '#666'}; font-weight: bold;">${isPatternActive ? 'PADR√ÉO ATIVO!' : 'Top Padr√£o'}</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 0.7rem; color: #aaa;">MINUTO DA SORTE</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: #ffeb3b; margin: 2px 0;">${luckyDigitStr}</div>
                                <div style="font-size: 0.6rem; color: #666;">Final do Minuto (0-9)</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; ${isMagicSumActive ? 'border: 1px solid #a100ff; box-shadow: 0 0 10px rgba(161,0,255,0.2);' : ''}">
                                <div style="font-size: 0.7rem; color: #aaa;">SOMA M√ÅGICA</div>
                                <div style="display: flex; align-items: baseline; justify-content: center; gap: 8px; margin: 2px 0;">
                                    <div style="font-size: 1.5rem; font-weight: bold; color: #a100ff;">${magicSum}</div>
                                    <div class="${magicAccClass}" style="${magicAccStyle}">(${magicSumAccuracy}%)</div>
                                </div>
                                <div style="font-size: 0.6rem; color: ${isMagicSumActive ? '#a100ff' : '#666'}; font-weight: bold;">${isMagicSumActive ? 'PADR√ÉO ATIVO!' : 'Soma dos 2 Vizinhos'}</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; ${isEntropyActive ? 'border: 1px solid #ff9800; box-shadow: 0 0 10px rgba(255,152,0,0.3);' : ''}">
                                <div style="font-size: 0.7rem; color: #aaa;">ENTROPIA DO SISTEMA</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: #ff9800; margin: 2px 0;">${entropyPercentage}%</div>
                                <div style="font-size: 0.6rem; color: ${isEntropyActive ? '#ff9800' : '#666'}; font-weight: bold;">${isEntropyActive ? 'PADR√ÉO ATIVO!' : 'N√≠vel de Caos'}</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; ${isHarmonicActive ? 'border: 1px solid #00d2ff; box-shadow: 0 0 10px rgba(0, 210, 255, 0.3);' : ''}">
                                <div style="font-size: 0.7rem; color: #aaa;">RESSON√ÇNCIA HARM√îNICA</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: #00d2ff; margin: 2px 0;">${harmonicPct}%</div>
                                <div style="font-size: 0.6rem; color: ${isHarmonicActive ? '#00d2ff' : '#666'}; font-weight: bold;">${isHarmonicActive ? 'ALINHAMENTO QU√ÇNTICO' : 'Estabilidade de Campo'}</div>
                            </div>
                            <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                                <div style="font-size: 0.7rem; color: #aaa;">PRESS√ÉO DE APOSTA</div>
                                <div style="font-size: 1.1rem; font-weight: bold; color: #fff; margin: 2px 0;">${crowdSide}</div>
                                <div style="font-size: 0.6rem; color: #666;">Contrarian: <span style="color: #00d2ff;">${contrarianSide}</span></div>
                                <div style="width: 100%; height: 4px; background: #333; margin-top: 5px; border-radius: 2px; overflow: hidden;"><div style="width: ${pressureVal}%; background: ${pressureColor}; height: 100%;"></div></div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 15px; background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 0, 0, 0.3)); border: 1px solid #00ff88; padding: 10px; border-radius: 6px; display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <div style="display: flex; align-items: center;">
                                    <div style="font-size: 0.7rem; color: #00ff88; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;">üéØ C√ÅLCULO DE PRECIS√ÉO (100%)</div>
                                    <label class="switch" style="transform: scale(0.6); margin-left: 5px;" title="Trocar gatilho ap√≥s Win">
                                        <input type="checkbox" onchange="toggleSmartTrigger()" ${smartTriggerMode ? 'checked' : ''}>
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                <div style="font-size: 0.65rem; color: #aaa;">Padr√£o mais assertivo identificado</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.75rem; color: #ccc;">GATILHO: <span style="color: #fff; font-weight: bold; font-size: 1rem;">${bestPreRoll}</span>${smartSkipActive ? ' <span title="Smart Trigger: Gatilho anterior pulado" style="color: #00d2ff; font-size: 0.8rem; cursor: help;">‚ö°</span>' : ''} ‚ûî SOMA IDEAL: <span style="color: #fff; font-weight: bold; font-size: 1rem;">${bestSum}</span></div>
                                <div style="font-size: 0.6rem; color: #666;">Frequ√™ncia: ${bestPreRollCount}x (Gatilho) / ${hotSums.length > 0 ? hotSums[0].count : 0}x (Soma)</div>
                            </div>
                        </div>
                        ${triggerAlert}

                        <div style="margin-top: 15px; background: rgba(0,0,0,0.2); padding: 10px 15px; border-radius: 6px;">
                            <h5 style="margin: 0 0 8px 0; font-size: 0.7rem; color: #aaa; text-transform: uppercase; border-bottom: 1px solid #444; padding-bottom: 5px;">Hist√≥rico de Somas</h5>
                            <div>
                                ${historyHtml}
                            </div>
                        </div>
                    </div>`;
            }

            const scoreboardHtml = `<div class="futuristic-scoreboard"><div class="score-card last"><span class="score-label">√öLTIMO</span><span class="score-value last-text">${lastInterval}m</span></div><div class="score-card avg"><span class="score-label">${analysisLabel}</span><span class="score-value avg-text">${avg}m</span></div><div class="score-card min"><span class="score-label">M√çNIMO</span><span class="score-value min-text">${min}m</span></div><div class="score-card max"><span class="score-label">M√ÅXIMO</span><span class="score-value max-text">${max}m</span></div></div>`;

            const chartData = variationViewMode === 'all' ? intervals : intervals.slice(-100);
            const sliceStart = variationViewMode === 'all' ? 0 : Math.max(0, intervals.length - 100);
            const viewBoxW = 1000; // Largura l√≥gica fixa para preencher o layout
            const viewBoxH = 100, padding = 10;
            const maxValChart = Math.max(...chartData, avg, 1); // Garante que a m√©dia caiba no gr√°fico
            
            // --- Regress√£o Linear (Linha de Tend√™ncia) ---
            let trendLineSvg = "";
            let slopeHtml = "";
            if (chartData.length > 1) {
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                const n = chartData.length;
                chartData.forEach((y, x) => {
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumX2 += x * x;
                });
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                const startVal = intercept;
                const endVal = slope * (n - 1) + intercept;
                const x1 = padding;
                const y1 = (viewBoxH - padding) - ((startVal / maxValChart) * (viewBoxH - 2 * padding));
                const x2 = viewBoxW - padding;
                const y2 = (viewBoxH - padding) - ((endVal / maxValChart) * (viewBoxH - 2 * padding));
                const trendColor = slope > 0 ? '#ff5500' : '#00ff88'; // Laranja (Aumentando) / Verde (Diminuindo)
                trendLineSvg = `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${trendColor}" stroke-width="2" stroke-dasharray="5,3" opacity="0.9"><title>Tend√™ncia: ${slope > 0 ? 'Aumentando' : 'Diminuindo'} (Slope: ${slope.toFixed(3)})</title></line>`;
                slopeHtml = `<span style="font-size: 0.7rem; color: ${trendColor}; margin-left: 8px; border: 1px solid ${trendColor}; padding: 1px 6px; border-radius: 4px; font-weight: normal;">${slope > 0 ? '‚Üó' : '‚Üò'} ${slope.toFixed(4)}</span>`;
            }

            // Linha da M√©dia
            let avgLine = "";
            if (!isNaN(avg) && maxValChart > 0) {
                const avgY = (viewBoxH - padding) - ((avg / maxValChart) * (viewBoxH - 2 * padding));
                avgLine = `<line x1="${padding}" y1="${avgY}" x2="${viewBoxW - padding}" y2="${avgY}" stroke="#fff" stroke-width="1" stroke-dasharray="4,4" opacity="0.3"><title>M√©dia: ${avg}m</title></line><text x="${viewBoxW - padding}" y="${avgY - 4}" fill="#fff" font-size="9" text-anchor="end" opacity="0.5">M√©dia</text>`;
            }

            let svgLines = "", circles = "", prevX = 0, prevY = 0;
            let areaPathD = "";
            chartData.forEach((val, idx) => {
                const originalIdx = sliceStart + idx;
                const isPatternPoint = patternIndices.includes(originalIdx);
                
                const iDate = intervalDates[originalIdx];
                const dateTooltip = iDate ? `${iDate.getDate().toString().padStart(2, '0')}/${(iDate.getMonth() + 1).toString().padStart(2, '0')} ${iDate.getHours().toString().padStart(2, '0')}:${iDate.getMinutes().toString().padStart(2, '0')}` : '';
                
                const x = (idx / (chartData.length - 1 || 1)) * (viewBoxW - 2 * padding) + padding;
                const y = (viewBoxH - padding) - ((val / maxValChart) * (viewBoxH - 2 * padding));
                
                if (idx === 0) areaPathD += `M ${x} ${y}`;
                else areaPathD += ` L ${x} ${y}`;

                let color = val > avg ? '#ff0055' : '#00d2ff';
                let radius = 3;
                
                if (isPatternPoint) {
                    color = '#ffeb3b'; // Amarelo para destaque do padr√£o
                    radius = 5;
                }

                if (idx > 0) svgLines += `<line x1="${prevX}" y1="${prevY}" x2="${x}" y2="${y}" stroke="${color}" stroke-width="2" />`;
                
                if (isPatternPoint) {
                    // Adiciona efeito de halo pulsante para os pontos do padr√£o
                    circles += `<circle cx="${x}" cy="${y}" r="${radius}" fill="none" stroke="${color}" stroke-width="2" opacity="0.6"><animate attributeName="r" values="${radius};${radius+6};${radius}" dur="2s" repeatCount="indefinite" /><animate attributeName="opacity" values="0.8;0;0.8" dur="2s" repeatCount="indefinite" /></circle>`;
                }
                
                circles += `<circle cx="${x}" cy="${y}" r="${radius}" fill="${color}" stroke="${isPatternPoint ? '#fff' : 'none'}" stroke-width="${isPatternPoint ? 1 : 0}" class="chart-dot"><title>üìÖ ${dateTooltip}&#10;‚è±Ô∏è Intervalo: ${val} min ${isPatternPoint ? ' (Padr√£o)' : ''}</title></circle>`;
                prevX = x; prevY = y;
            });
            
            // Fecha o caminho da √°rea (vai at√© o fundo do gr√°fico)
            if (chartData.length > 0) areaPathD += ` L ${prevX} ${viewBoxH - padding} L ${padding} ${viewBoxH - padding} Z`;
            const areaSvg = chartData.length > 0 ? `<defs><linearGradient id="chartAreaGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#00d2ff" stop-opacity="0.2"/><stop offset="100%" stop-color="#00d2ff" stop-opacity="0"/></linearGradient></defs><path d="${areaPathD}" fill="url(#chartAreaGrad)" />` : '';
            
            // --- Gera√ß√£o da Barra de Hist√≥rico (Resultados Anteriores + Ao Vivo) ---
            let historyBarHtml = '';
            // Combina hist√≥rico calculado (passado) com hist√≥rico monitorado (atual/recente)
            const liveHistory = cycleMonitorHistory.map(item => ({
                time: `${item.targetTime.getHours().toString().padStart(2, '0')}:${item.targetTime.getMinutes().toString().padStart(2, '0')}`,
                result: item.result
            }));
            const fullHistory = [...dailyHistory, ...liveHistory];
            
            if (fullHistory.length > 0) {
                // Pega os √∫ltimos 50 resultados para exibir (maior hist√≥rico para an√°lise)
                const recentHistory = fullHistory.slice(-50);
                
                // C√°lculo de Assertividade dos itens vis√≠veis
                let visibleWins = 0;
                let visibleLosses = 0;
                recentHistory.forEach(item => {
                    if (item.result === 'WIN') visibleWins++;
                    else visibleLosses++;
                });
                const visibleTotal = visibleWins + visibleLosses;
                const visibleAssertiveness = visibleTotal > 0 ? Math.round((visibleWins / visibleTotal) * 100) : 0;

                const statsHtml = `<div style="flex-shrink: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); padding: 5px 15px; border-radius: 6px; margin-right: 15px; min-width: 100px;"><div style="font-size: 0.65rem; color: #aaa; text-transform: uppercase; letter-spacing: 1px;">Assertividade</div><div style="font-size: 1.2rem; font-weight: bold; color: ${visibleAssertiveness >= 50 ? '#00ff88' : '#ff0055'};">${visibleAssertiveness}%</div><div style="font-size: 0.65rem; color: #ccc; display: flex; gap: 8px;"><span style="color: #00ff88;">${visibleWins} W</span> <span style="color: #ff0055;">${visibleLosses} L</span></div></div>`;

                const historyItemsHtml = recentHistory.map(item => {
                    const isWin = item.result === 'WIN';
                    const color = isWin ? '#00ff88' : '#ff0055';
                    const bg = isWin ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 0, 85, 0.1)';
                    const border = isWin ? 'rgba(0, 255, 136, 0.3)' : 'rgba(255, 0, 85, 0.3)';
                    return `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; background: ${bg}; border: 1px solid ${border}; padding: 5px 10px; border-radius: 6px; min-width: 50px;"><span style="color: ${color}; font-weight: bold; font-size: 0.9rem;">${item.time}</span></div>`;
                }).join('');
                historyBarHtml = `<div style="display: flex; align-items: center; overflow-x: auto; padding-bottom: 10px; margin-bottom: 20px;">${statsHtml}<div style="display: flex; gap: 10px;">${historyItemsHtml}</div></div>`;
            }

            const variationTitle = variationViewMode === 'all' ? `Varia√ß√£o (Todos: ${intervals.length})` : 'Varia√ß√£o (√öltimos 100)';
            const toggleVariationBtn = `<button onclick="toggleVariationViewMode()" style="float: right; background: rgba(255,255,255,0.1); border: 1px solid #333; color: #ccc; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem; transition: all 0.3s;">${variationViewMode === 'all' ? 'Ver Recentes' : 'Ver Todos'}</button>`;

            content.innerHTML = `${dailyStatsHtml}${historyBarHtml}${countdownHtml}${probChartHtml}${scoreboardHtml}${hourlyChartHtml}<div style="margin-bottom: 20px; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 10px; border: 1px solid #333;"><div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;"><h4 style="margin: 0; color: #ccc; font-size: 0.8rem;">${variationTitle}${slopeHtml}</h4>${toggleVariationBtn}</div><div id="chartScrollContainer" style="overflow-x: hidden; padding-bottom: 5px;"><svg viewBox="0 0 ${viewBoxW} 100" preserveAspectRatio="none" style="width: 100%; height: 100px; overflow: visible;">${areaSvg}${avgLine}${trendLineSvg}${svgLines}${circles}</svg></div></div><div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;"><h4 style="margin-top: 0; color: #ccc;">√öltimos 10 Intervalos:</h4><div style="font-family: monospace; color: #00d2ff; word-break: break-all;">${intervals.slice(-10).join('m ‚ûî ')}m</div></div>${rastreioHtml}`;
            
            // Scroll autom√°tico para o final do gr√°fico (lado direito)
            const scrollContainer = document.getElementById('chartScrollContainer');
            if (scrollContainer) {
                scrollContainer.scrollLeft = scrollContainer.scrollWidth;
            }

            if (targetHotTime) {
                const updateTimer = () => {
                    const now = new Date();
                    const diff = targetHotTime - now;
                    const el = document.getElementById('hot_countdown_display');
                    if (!el) return;
                    
                    if (diff <= 0) {
                        el.innerHTML = "AGORA";
                        el.style.animation = "pulse-text 0.5s infinite alternate";
                    } else {
                        const m = Math.floor(diff / 60000);
                        const s = Math.floor((diff % 60000) / 1000);
                        el.innerHTML = `${m}:${s.toString().padStart(2, '0')}`;
                    }
                };
                updateTimer();
                hotMinuteCountdownInterval = setInterval(updateTimer, 1000);
            }
        }

        function sendNotification(title, body) {
            // Envia notifica√ß√£o apenas se a aba estiver oculta (em segundo plano)
            if ("Notification" in window && Notification.permission === "granted" && document.hidden) {
                new Notification(title, { body: body });
            }
        }

        function playWinAlertSound() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (!ctx) return; // AudioContext not supported

                const t = ctx.currentTime;
                const osc1 = ctx.createOscillator();
                const gain1 = ctx.createGain();
                osc1.connect(gain1);
                gain1.connect(ctx.destination);
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(659.25, t); // E5
                gain1.gain.setValueAtTime(0.1, t);
                gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                osc1.start(t);
                osc1.stop(t + 0.2);

                const osc2 = ctx.createOscillator();
                const gain2 = ctx.createGain();
                osc2.connect(gain2);
                gain2.connect(ctx.destination);
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(880.00, t + 0.1); // A5
                gain2.gain.setValueAtTime(0.1, t + 0.1);
                gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                osc2.start(t + 0.1);
                osc2.stop(t + 0.3);
            } catch (e) {
                console.error("Erro ao tocar som de WIN:", e);
            }
        }
    </script>
</body>
</html>