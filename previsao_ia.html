<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Previsão I.A. - Cortex Virtual</title>
    <style>
        :root {
            --bg-color: #0f0f13; --panel-bg: #1a1a1a; --text-color: #fff; --border-color: #333; --input-bg: #0f0f13;
            --accent: #00d2ff; --accent-blaze: #ff0055; --accent-jonbet: #00ff88; --text-muted: #888;
        }
        * {
            box-sizing: border-box;
        }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; }
        .main-container { max-width: 1200px; margin: 0 auto; display: flex; gap: 15px; }
        .layout-panel { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
        h1 { margin: 0; font-size: 1.5rem; }
        
        .cortex-text-anim { background: linear-gradient(90deg, #00d2ff, #ff0055, #ff9800, #00d2ff); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: cortex-gradient 3s linear infinite; font-weight: bold; }
        @keyframes cortex-gradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        
        .btn-back { display: inline-flex; align-items: center; gap: 5px; padding: 8px 15px; background: rgba(255,255,255,0.05); color: #aaa; text-decoration: none; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; border: 1px solid #333; transition: all 0.3s; cursor: pointer; }
        .btn-back:hover { background: rgba(0, 210, 255, 0.1); border-color: #00d2ff; color: #00d2ff; box-shadow: 0 0 10px rgba(0, 210, 255, 0.2); }

        .platform-switcher { display: flex; gap: 10px; }
        .platform-btn { padding: 6px 12px; border: 1px solid #444; background: #222; color: var(--text-muted); cursor: pointer; border-radius: 4px; transition: all 0.3s; font-size: 0.8rem; }
        .platform-btn.active { background: var(--accent); color: #000; font-weight: bold; border-color: var(--accent); }
        .platform-jonbet .platform-btn.active { background: var(--accent-jonbet); border-color: var(--accent-jonbet); }

        /* Toggle Switch */
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Loading Spinner */
        .spinner { border: 3px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 3px solid #ff9800; width: 20px; height: 20px; animation: spin 1s linear infinite; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* AI Visual Elements */
        .prediction-display { text-align: center; margin: 15px 0; }
        .prediction-color-box { padding: 20px; border-radius: 12px; font-size: 1.8rem; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; border: 2px solid; box-shadow: 0 0 20px rgba(0,0,0,0.5); transition: all 0.3s; }
        .prediction-color-box.red { border-color: #ff0055; color: #ff0055; text-shadow: 0 0 10px #ff0055; }
        .prediction-color-box.black { border-color: #fff; color: #fff; background: #222; }
        .prediction-color-box.white { border-color: #fff; color: #fff; text-shadow: 0 0 15px #fff; background: rgba(255,255,255,0.15); animation: pulse-white 1s infinite alternate; }
        
        .confidence-bar-container { width: 100%; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 4px; border: 1px solid #444; margin-bottom: 15px; box-sizing: border-box; }
        .confidence-bar { height: 12px; border-radius: 4px; background: linear-gradient(90deg, #a100ff, #ff45d4); transition: width 0.5s ease-out; box-shadow: 0 0 10px #ff45d4; }
        .confidence-label { font-size: 0.9rem; color: #ccc; margin-bottom: 5px; display: block; }
        
        .prediction-reasoning { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; font-size: 0.85rem; color: #aaa; line-height: 1.5; text-align: left; }
        .prediction-reasoning strong { color: #ff45d4; }
        .prediction-reasoning ul { padding-left: 20px; margin: 0; }

        /* AI Circle Animation */
        .ai-visual-container { display: flex; justify-content: center; margin-bottom: 15px; animation: glitch-anim 5s infinite; }
        .ai-circle-outer { width: 120px; height: 120px; border-radius: 50%; border: 2px solid transparent; border-top-color: #00d2ff; border-bottom-color: #ff0055; animation: spin-ai 3s linear infinite; position: relative; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 20px rgba(0, 210, 255, 0.2); transition: all 0.5s; }
        .ai-circle-inner { width: 80px; height: 80px; border-radius: 50%; border: 2px solid transparent; border-left-color: #a100ff; border-right-color: #ff9800; animation: spin-ai 2s linear infinite reverse; position: absolute; transition: all 0.5s; }
        .ai-core-dot { width: 15px; height: 15px; background-color: #fff; border-radius: 50%; box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8); animation: pulse-ai 1s ease-in-out infinite alternate; transition: all 0.5s; }
        
        @keyframes spin-ai { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse-ai { 0% { transform: scale(1); opacity: 0.8; } 100% { transform: scale(1.5); opacity: 1; } }
        @keyframes glitch-anim { 0% { transform: translate(0); opacity: 1; } 92% { transform: translate(0); opacity: 1; } 92.5% { transform: translate(-3px, 2px) skew(10deg); opacity: 0.8; } 93% { transform: translate(3px, -2px) skew(-10deg); opacity: 1; } 93.5% { transform: translate(0); opacity: 1; } 98% { transform: translate(1px, -1px) skew(5deg); } 98.5% { transform: translate(-1px, 1px) skew(-5deg); } 100% { transform: translate(0); } }
        @keyframes pulse-white { 0% { box-shadow: 0 0 15px rgba(255,255,255,0.3); } 100% { box-shadow: 0 0 30px rgba(255,255,255,0.8); } }
        .chart-dot { animation: pulse-chart 1s infinite; } 
        @keyframes pulse-chart { 0% { r: 3; opacity: 0.6; } 50% { r: 5; opacity: 1; box-shadow: 0 0 5px #fff; } 100% { r: 3; opacity: 0.6; } }

        /* Trend Meter */
        .trend-meter-container { margin-bottom: 20px; background: rgba(10, 15, 25, 0.6); padding: 15px; border-radius: 12px; border: 1px solid #333; position: relative; overflow: hidden; box-shadow: 0 0 20px rgba(0,0,0,0.3); }
        .trend-meter-container::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px; background: linear-gradient(90deg, transparent, #00d2ff, transparent); opacity: 0.7; }
        .trend-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.75rem; color: #aaa; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; font-weight: bold; }
        .trend-segments { display: flex; gap: 2px; height: 8px; width: 100%; margin-bottom: 5px; }
        .trend-segment { flex: 1; background: rgba(255,255,255,0.05); border-radius: 1px; transition: all 0.3s; }
        .trend-value { font-family: 'Courier New', monospace; font-size: 1rem; font-weight: bold; }

        /* 24h Winrate Circle */
        .winrate-circle-bg { fill: none; stroke: rgba(255,255,255,0.1); stroke-width: 4; }
        .winrate-circle-progress {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dashoffset 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .winrate-text {
            font-size: 1.4rem;
            font-weight: 900;
            font-family: 'Courier New', monospace;
            text-anchor: middle;
            dominant-baseline: middle;
            animation: fadeInText 1s ease-in-out;
        }
        .winrate-subtext { font-size: 0.7rem; fill: #888; text-anchor: middle; dominant-baseline: middle; }
        @keyframes fadeInText { from { opacity: 0; } to { opacity: 1; } }

        /* --- Win Streak Counter --- */
        .win-streak-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding-top: 5px;
        }
        .win-streak-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.4);
        }
        .win-streak-bar-bg {
            width: 100%; height: 6px; background: rgba(0,0,0,0.4);
            border-radius: 3px; overflow: hidden; border: 1px solid #333;
        }
        .win-streak-bar-fill {
            height: 100%; background: linear-gradient(90deg, #00ff88, #00d2ff); width: 0%;
            transition: width 0.5s ease-out; border-radius: 3px; box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
        }

        /* Connection Status Indicator */
        .connection-status { display: flex; align-items: center; gap: 6px; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background-color: #555; transition: all 0.3s; }
        .status-text { font-size: 0.8rem; color: #888; font-weight: bold; }
        .connection-status.online .status-dot { background-color: #00ff88; box-shadow: 0 0 8px #00ff88; }
        .connection-status.online .status-text { color: #00ff88; }
        .connection-status.connecting .status-dot { background-color: #ff9800; animation: pulse-connecting 1s infinite alternate; }
        .connection-status.connecting .status-text { color: #ff9800; }
        .connection-status.fair .status-dot { background-color: #ffc107; box-shadow: 0 0 8px #ffc107; }
        .connection-status.fair .status-text { color: #ffc107; }
        .connection-status.slow .status-dot { background-color: #ff5722; box-shadow: 0 0 8px #ff5722; }
        .connection-status.slow .status-text { color: #ff5722; }
        @keyframes pulse-connecting { from { transform: scale(0.8); opacity: 0.7; } to { transform: scale(1.2); opacity: 1; } }
        .connection-status.error .status-dot { background-color: #ff0055; }
        .connection-status.error .status-text { color: #ff0055; }

        /* Sidebar Styles */
        .sidebar {
            flex: 0 0 220px; /* Sidebar with further reduced width */
            background: rgba(10, 15, 25, 0.5);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
            animation: slideInLeft 0.5s ease-out;
            align-self: flex-start; /* Aligns to top */
        }
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, var(--accent), transparent);
            animation: sidebar-scan 4s linear infinite;
        }
        @keyframes sidebar-scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        .sidebar-section {
            padding: 8px;
            background: rgba(255,255,255,0.03);
            border: 1px solid #2a2a2a;
            border-radius: 8px;
        }

        .sidebar-title {
            font-size: 0.8rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0 0 15px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        .sidebar .platform-switcher { flex-direction: column; }
        .sidebar .platform-btn { width: 100%; text-align: center; }
        .sidebar .sidebar-control { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .sidebar .sidebar-control:last-child { margin-bottom: 0; }
        .sidebar .sidebar-control span { font-size: 0.9rem; color: #ccc; }
        
        /* Grid Compacto para Controles */
        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 10px; }
        .sidebar .controls-grid .sidebar-control { flex-direction: column; margin-bottom: 0; background: rgba(0,0,0,0.2); padding: 8px 4px; border-radius: 6px; justify-content: space-between; align-items: center; min-height: 60px; }
        .sidebar .controls-grid .sidebar-control span { font-size: 0.7rem; margin-bottom: 0; text-align: center; white-space: nowrap; }

        /* Ocultar setas padrão do input number para usar botões personalizados */
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }

        .layout-panel.suite { flex: 1; }

        /* Grid de Widgets para alinhar funções */
        .widgets-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .widget-full { grid-column: span 2; }

        /* Responsividade */
        @media (max-width: 900px) {
            .main-container { flex-direction: column; }
            .sidebar { width: 100%; flex: none; margin-bottom: 20px; }
            .widgets-grid { grid-template-columns: 1fr; }
            .widget-full { grid-column: span 1; }
            .sidebar .platform-switcher { flex-direction: row; }
            .sidebar .platform-btn { flex: 1; }
            .ai-visual-container { margin-top: 20px; }
            .prediction-color-box { font-size: 1.5rem; padding: 15px; }
        }

        /* --- MOBILE RESPONSIVE (Enhanced) --- */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .layout-panel {
                padding: 15px;
            }
            .main-header {
                flex-direction: column;
                gap: 10px;
            }
            
            /* Adjust AI Visual Size */
            .ai-circle-outer {
                width: 100px;
                height: 100px;
            }
            .ai-circle-inner {
                width: 60px;
                height: 60px;
            }
            
            /* Prediction Box */
            .prediction-color-box {
                font-size: 1.2rem;
                padding: 12px;
                letter-spacing: 1px;
            }

            /* Winrate Circle scaling */
            #ai_winrate_1h_container svg {
                width: 100px;
                height: 100px;
            }
        }

        /* Animation for Vertical Ticker */
        @keyframes scrollUp {
            0% { transform: translateY(0); }
            100% { transform: translateY(-50%); }
        }

        /* White Alert Animation */
        @keyframes flash-white-screen {
            0%, 100% { box-shadow: inset 0 0 0 transparent; }
            50% { box-shadow: inset 0 0 50px 10px rgba(255, 255, 255, 0.4); }
        }
        .white-alert-active {
            animation: flash-white-screen 1.5s infinite ease-in-out;
        }

        /* Gale 1 Indicator */
        .gale-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff9800;
            color: #000;
            font-weight: 900;
            font-size: 0.7rem;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #fff;
            box-shadow: 0 0 10px #ff9800;
            animation: pulse-gale 1.5s infinite;
            z-index: 10;
        }
        @keyframes pulse-gale {
            0% { transform: scale(1); box-shadow: 0 0 10px #ff9800; }
            50% { transform: scale(1.1); box-shadow: 0 0 15px 5px #ff9800; }
            100% { transform: scale(1); box-shadow: 0 0 10px #ff9800; }
        }

        /* No Data Animation */
        .nd-container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 80px; width: 100%; position: relative; overflow: hidden; }
        .nd-ring { width: 30px; height: 30px; border: 2px solid rgba(255,255,255,0.1); border-radius: 50%; border-top-color: var(--accent); animation: spin 1s linear infinite; margin-bottom: 8px; }
        .nd-text { font-size: 0.7rem; color: #444; letter-spacing: 2px; text-transform: uppercase; animation: blink-text 2s infinite; }
        .nd-scan { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, transparent, rgba(0, 210, 255, 0.1), transparent); animation: scan-vertical 2s linear infinite; pointer-events: none; }
        @keyframes scan-vertical { 0% { transform: translateY(-100%); } 100% { transform: translateY(100%); } }
        @keyframes blink-text { 0%, 100% { opacity: 0.5; color: #444; } 50% { opacity: 1; color: #666; } }

        /* Waiting State Animation */
        .prediction-color-box.waiting {
            border-color: var(--accent); color: var(--accent); text-shadow: 0 0 10px var(--accent);
            background: rgba(0, 210, 255, 0.05); animation: pulse-waiting 1.5s infinite ease-in-out;
        }
        @keyframes pulse-waiting {
            0% { box-shadow: 0 0 10px rgba(0, 210, 255, 0.2); transform: scale(1); }
            50% { box-shadow: 0 0 25px rgba(0, 210, 255, 0.5); transform: scale(1.02); }
            100% { box-shadow: 0 0 10px rgba(0, 210, 255, 0.2); transform: scale(1); }
        }

        /* Paused State Animation */
        .prediction-color-box.paused {
            border-color: #ffc107; color: #ffc107; text-shadow: 0 0 10px #ffc107;
            background: rgba(255, 193, 7, 0.05); animation: pulse-paused 1.5s infinite ease-in-out;
        }
        @keyframes pulse-paused {
            0% { box-shadow: 0 0 10px rgba(255, 193, 7, 0.2); transform: scale(1); }
            50% { box-shadow: 0 0 25px rgba(255, 193, 7, 0.5); transform: scale(1.02); }
            100% { box-shadow: 0 0 10px rgba(255, 193, 7, 0.2); transform: scale(1); }
        }

        /* Waiting Circular Progress */
        .waiting-wrapper {
            position: relative;
            display: inline-flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
        }
        .waiting-svg-ring {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: rotate(-90deg);
        }
        .waiting-circle-track {
            fill: rgba(0, 210, 255, 0.05);
            stroke: rgba(0, 210, 255, 0.1);
            stroke-width: 3;
        }
        .waiting-circle-progress {
            fill: none; stroke-width: 3;
            stroke-dasharray: 151; /* 2 * PI * 24 */
            stroke-dashoffset: 0;
            animation: waiting-countdown 4s linear forwards;
            stroke-linecap: round;
        }
        @keyframes waiting-countdown {
            0% { stroke-dashoffset: 0; stroke: #00d2ff; filter: drop-shadow(0 0 5px #00d2ff); }
            50% { stroke: #a100ff; filter: drop-shadow(0 0 5px #a100ff); }
            100% { stroke-dashoffset: 151; stroke: #ff0055; filter: drop-shadow(0 0 5px #ff0055); }
        }
        .waiting-content {
            font-size: 0.8rem;
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
            font-weight: bold;
            letter-spacing: 1px;
            animation: pulse-text 1s infinite alternate;
        }
        @keyframes pulse-text { from { opacity: 0.7; } to { opacity: 1; } }

        /* Recalibrating Text Animation */
        .recalibrating-anim {
            display: inline-block;
            position: relative;
            color: #00d2ff;
            font-family: 'Courier New', monospace;
            letter-spacing: 0.5px;
            overflow: hidden;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(0, 210, 255, 0.05);
            border: 1px solid rgba(0, 210, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.1);
        }
        .recalibrating-anim::after {
            content: '';
            position: absolute;
            top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 210, 255, 0.4), transparent);
            transform: skewX(-20deg);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 200%; }
        }
        @keyframes pulse-gauss-red {
            0% { box-shadow: 0 0 10px rgba(255, 0, 85, 0.2); border-color: #ff0055; }
            50% { box-shadow: 0 0 30px rgba(255, 0, 85, 0.8); border-color: #ff0055; }
            100% { box-shadow: 0 0 10px rgba(255, 0, 85, 0.2); border-color: #ff0055; }
        }
        @keyframes pulse-gauss-green {
            0% { box-shadow: 0 0 10px rgba(0, 255, 136, 0.2); border-color: #00ff88; }
            50% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.8); border-color: #00ff88; }
            100% { box-shadow: 0 0 10px rgba(0, 255, 136, 0.2); border-color: #00ff88; }
        }
    </style>
    <style>
        /* --- Scrollbar Futurista Aprimorada --- */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(10, 10, 15, 0.5);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, rgba(161, 0, 255, 0.6), rgba(255, 69, 212, 0.6));
            border-radius: 10px;
            border: 1px solid rgba(161, 0, 255, 0.2);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #a100ff, #ff45d4);
            box-shadow: 0 0 15px rgba(161, 0, 255, 0.5);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="layout-panel suite">
            <div class="main-header">
                <h1 class="cortex-text-anim" style="display: none;">PREVISÃO I.A.</h1>
                <div id="ai_loading_indicator" class="spinner"></div>
            </div>

            <div class="content-section">
                <!-- Main Prediction Content -->
                <div id="ai_prediction_content">
                    <div style="text-align: center; padding: 20px; color: #888;">
                        <div class="spinner" style="display: inline-block; margin-bottom: 10px;"></div>
                        <br>Inicializando I.A...
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <button class="btn-back" onclick="parent.closeTool()" style="display: none;">⬅ Voltar ao Menu</button>
            <div class="sidebar-section" style="display: none;">
                <h3 class="sidebar-title">Plataforma</h3>
                <div class="platform-switcher">
                    <input type="hidden" id="ai_platformSelector" value="blaze">
                    <button class="platform-btn active" id="ai_btn-blaze" onclick="ai_selectPlatform('blaze')">Blaze</button>
                    <button class="platform-btn" id="ai_btn-jonbet" onclick="ai_selectPlatform('jonbet')" style="display: none;">Jonbet</button>
                </div>
            </div>
            <div class="sidebar-section">
                <h3 class="sidebar-title">Controles</h3>
                <div class="sidebar-control">
                    <div id="ai_connection_status" class="connection-status">
                        <div class="status-dot"></div>
                        <span class="status-text">Offline</span>
                    </div>
                </div>
                
                <div class="controls-grid">
                    <div class="sidebar-control">
                        <span>Auto-Busca</span>
                        <label class="switch"><input type="checkbox" id="ai_autoFetchToggle" checked><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Som</span>
                        <label class="switch"><input type="checkbox" id="ai_soundToggle" onchange="ai_toggleSound()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Gale Virtual</span>
                        <label class="switch"><input type="checkbox" id="ai_virtualGaleToggle" onchange="ai_toggleVirtualGale()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Gale 1</span>
                        <label class="switch"><input type="checkbox" id="ai_gale1Toggle" onchange="ai_toggleGale1()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Inv. Gale 1</span>
                        <label class="switch"><input type="checkbox" id="ai_invertGaleToggle" onchange="ai_toggleInvertGale()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Conservador</span>
                        <label class="switch"><input type="checkbox" id="ai_conservativeToggle" onchange="ai_toggleConservativeMode()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Horário Ouro</span>
                        <label class="switch"><input type="checkbox" id="ai_goldenHourToggle" onchange="ai_toggleGoldenHourMode()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Opções Double</span>
                        <label class="switch"><input type="checkbox" id="ai_opcoesDoubleToggle" onchange="ai_toggleOpcoesDouble()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Minutos 1-5</span>
                        <label class="switch"><input type="checkbox" id="ai_minute1to5Toggle" onchange="ai_toggleMinute1to5()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Tempo Espera</span>
                        <div style="display: flex; align-items: center; gap: 3px;">
                            <button onmousedown="ai_startAdjustWaitTime(-1)" onmouseup="ai_stopAdjustWaitTime()" onmouseleave="ai_stopAdjustWaitTime()" style="width: 20px; height: 20px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; line-height: 1;">-</button>
                            <input type="number" id="ai_waitTimeInput" value="4" min="1" max="300" style="width: 40px; background: #222; border: 1px solid #444; color: #fff; border-radius: 3px; padding: 2px; text-align: center; -moz-appearance: textfield;" onchange="ai_updateWaitTime()" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                            <button onmousedown="ai_startAdjustWaitTime(1)" onmouseup="ai_stopAdjustWaitTime()" onmouseleave="ai_stopAdjustWaitTime()" style="width: 20px; height: 20px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; line-height: 1;">+</button>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <span>Pedras Espera</span>
                        <div style="display: flex; align-items: center; gap: 3px;">
                            <button onmousedown="ai_startAdjustStonesWait(-1)" onmouseup="ai_stopAdjustStonesWait()" onmouseleave="ai_stopAdjustStonesWait()" style="width: 20px; height: 20px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; line-height: 1;">-</button>
                            <input type="number" id="ai_stonesWaitInput" value="1" min="1" max="100" style="width: 40px; background: #222; border: 1px solid #444; color: #fff; border-radius: 3px; padding: 2px; text-align: center; -moz-appearance: textfield;" onchange="ai_updateStonesWait()" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                            <button onmousedown="ai_startAdjustStonesWait(1)" onmouseup="ai_stopAdjustStonesWait()" onmouseleave="ai_stopAdjustStonesWait()" style="width: 20px; height: 20px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; line-height: 1;">+</button>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <span>Auto Inc. Loss</span>
                        <label class="switch"><input type="checkbox" id="ai_autoWaitLossToggle" onchange="ai_toggleAutoWaitLoss()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Pausa Manual</span>
                        <label class="switch"><input type="checkbox" id="ai_manualPauseToggle" onchange="ai_toggleManualPause()"><span class="slider"></span></label>
                    </div>
                    <div class="sidebar-control">
                        <span>Anti-Xadrez</span>
                        <label class="switch"><input type="checkbox" id="ai_antiChessToggle" onchange="ai_toggleAntiChessMode()"><span class="slider"></span></label>
                    </div>
                </div>
            </div>
            <div class="sidebar-section">
                <h3 class="sidebar-title">Placar</h3>
                <div id="ai_stats_container" style="margin-bottom: 10px;"></div>
                <button onclick="ai_resetAIStats()" style="width:100%; padding: 8px; background: rgba(255,0,85,0.2); border: 1px solid #ff0055; color: #ff0055; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: all 0.2s;">Resetar Placar</button>
            </div>
            <div class="sidebar-section">
                <h3 class="sidebar-title">Sequência Atual</h3>
                <div id="ai_win_streak_container">
                    <!-- Content will be injected by JS -->
                </div>
            </div>
            <div class="sidebar-section">
                <h3 class="sidebar-title">Recordes da Sessão</h3>
                <div id="ai_record_streaks_container">
                    <!-- Content will be injected by JS -->
                </div>
            </div>
            <div class="sidebar-section">
                <h3 class="sidebar-title">Assertividade (1h)</h3>
                <div id="ai_winrate_1h_container" style="display: flex; justify-content: center; align-items: center; position: relative;">
                    <!-- SVG for the circular progress bar will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Variáveis Globais ---
        let ai_interval = null;
        let ai_last_processed_signature = '';
        // Carregar estatísticas salvas (Placar persistente)
        const savedStats = localStorage.getItem('ai_session_stats');
        const initialStats = savedStats ? JSON.parse(savedStats) : {};

        let ai_wins = initialStats.wins || 0;
        let ai_losses = initialStats.losses || 0;
        let ai_current_prediction = null;
        let ai_balance_history = initialStats.balance || [0];
        let ai_use_virtual_gale = localStorage.getItem('ai_use_virtual_gale') === 'true';
        let ai_virtual_stage = 0; // 0 = Virtual, 1 = Real
        let ai_results_history = []; // Para o placar de 24h
        let ai_volume = 0.5;
        let ai_sound_enabled = localStorage.getItem('ai_sound_enabled') === 'true';
        let ai_pause_until = 0; // Timestamp for pause after loss
        let ai_consecutive_wins = initialStats.consecutive_wins || 0;
        let ai_consecutive_losses = initialStats.consecutive_losses || 0;
        let ai_max_consecutive_wins = initialStats.max_consecutive_wins || 0;
        let ai_max_consecutive_losses = initialStats.max_consecutive_losses || 0;
        let ai_filter_history = false;
        let ai_conservative_mode = localStorage.getItem('ai_conservative_mode') === 'true';
        let ai_golden_hour_mode = localStorage.getItem('ai_golden_hour_mode') === 'true';
        let ai_use_gale1 = localStorage.getItem('ai_use_gale1') === 'true';
        let ai_invert_gale = localStorage.getItem('ai_invert_gale') === 'true';
        let ai_last_prediction_on_loss = null;
        let ai_waiting_until = 0;
        let ai_opcoes_double_mode = localStorage.getItem('ai_opcoes_double_mode') === 'true';
        let ai_minute_1_5_mode = localStorage.getItem('ai_minute_1_5_mode') === 'true';
        let ai_confidence_history = [];
        let ai_win_wait_time = parseInt(localStorage.getItem('ai_win_wait_time')) || 4;
        let ai_manual_pause = localStorage.getItem('ai_manual_pause') === 'true';
        let ai_anti_chess_mode = localStorage.getItem('ai_anti_chess_mode') === 'true';
        let ai_wait_time_timer = null;
        let ai_wait_time_timeout = null;
        let ai_waiting_for_next_stone = false;
        let ai_stones_wait_setting = parseInt(localStorage.getItem('ai_stones_wait_setting')) || 1;
        let ai_stones_current_wait = 0;
        let ai_stones_wait_timer = null;
        let ai_stones_wait_timeout = null;
        let ai_auto_wait_loss = localStorage.getItem('ai_auto_wait_loss') === 'true';

        function updateConnectionStatus(status, text) {
            const statusContainer = document.getElementById('ai_connection_status');
            if (!statusContainer) return;
            const statusText = statusContainer.querySelector('.status-text');

            if (statusText) {
                statusContainer.className = 'connection-status ' + status;
                statusText.textContent = text;
            }
        }

        function ai_updateWaitTime() {
            const val = parseInt(document.getElementById('ai_waitTimeInput').value);
            if (!isNaN(val) && val >= 1) {
                ai_win_wait_time = val;
                localStorage.setItem('ai_win_wait_time', val);
            }
        }

        function ai_adjustWaitTime(delta) {
            const input = document.getElementById('ai_waitTimeInput');
            let val = parseInt(input.value) || 0;
            val += delta;
            if (val < 1) val = 1;
            if (val > 300) val = 300;
            input.value = val;
            ai_updateWaitTime();
        }

        function ai_startAdjustWaitTime(delta) {
            ai_adjustWaitTime(delta); // Muda 1 vez imediatamente
            ai_wait_time_timeout = setTimeout(() => {
                ai_wait_time_timer = setInterval(() => {
                    ai_adjustWaitTime(delta); // Continua mudando rapidamente
                }, 100); // Velocidade da mudança (100ms)
            }, 500); // Espera 0.5s antes de começar a acelerar
        }

        function ai_stopAdjustWaitTime() {
            clearTimeout(ai_wait_time_timeout);
            clearInterval(ai_wait_time_timer);
        }

        function ai_updateStonesWait() {
            const val = parseInt(document.getElementById('ai_stonesWaitInput').value);
            if (!isNaN(val) && val >= 1) {
                ai_stones_wait_setting = val;
                localStorage.setItem('ai_stones_wait_setting', val);
            }
        }

        function ai_adjustStonesWait(delta) {
            const input = document.getElementById('ai_stonesWaitInput');
            let val = parseInt(input.value) || 1;
            val += delta;
            if (val < 1) val = 1;
            if (val > 100) val = 100;
            input.value = val;
            ai_updateStonesWait();
        }

        function ai_startAdjustStonesWait(delta) {
            ai_adjustStonesWait(delta);
            ai_stones_wait_timeout = setTimeout(() => {
                ai_stones_wait_timer = setInterval(() => { ai_adjustStonesWait(delta); }, 100);
            }, 500);
        }

        function ai_stopAdjustStonesWait() {
            clearTimeout(ai_stones_wait_timeout);
            clearInterval(ai_stones_wait_timer);
        }

        function ai_toggleAutoWaitLoss() {
            const el = document.getElementById('ai_autoWaitLossToggle');
            ai_auto_wait_loss = el.checked;
            localStorage.setItem('ai_auto_wait_loss', ai_auto_wait_loss);
        }

        function ai_toggleSound() {
            const el = document.getElementById('ai_soundToggle');
            ai_sound_enabled = el.checked;
            localStorage.setItem('ai_sound_enabled', ai_sound_enabled);
        }

        function ai_toggleHistoryFilter() {
            ai_filter_history = !ai_filter_history;
            ai_showAIPrediction();
        }

        function ai_toggleConservativeMode() {
            const el = document.getElementById('ai_conservativeToggle');
            ai_conservative_mode = el.checked;
            localStorage.setItem('ai_conservative_mode', ai_conservative_mode);
            ai_showAIPrediction();
        }

        function ai_toggleGoldenHourMode() {
            const el = document.getElementById('ai_goldenHourToggle');
            ai_golden_hour_mode = el.checked;
            localStorage.setItem('ai_golden_hour_mode', ai_golden_hour_mode);
            ai_showAIPrediction();
        }

        function ai_toggleMinute1to5() {
            const el = document.getElementById('ai_minute1to5Toggle');
            ai_minute_1_5_mode = el.checked;
            localStorage.setItem('ai_minute_1_5_mode', ai_minute_1_5_mode);
            ai_showAIPrediction();
        }

        function ai_toggleInvertGale() {
            const el = document.getElementById('ai_invertGaleToggle');
            ai_invert_gale = el.checked;
            localStorage.setItem('ai_invert_gale', ai_invert_gale);
            ai_showAIPrediction();
        }

        function ai_toggleGale1() {
            const el = document.getElementById('ai_gale1Toggle');
            ai_use_gale1 = el.checked;
            localStorage.setItem('ai_use_gale1', ai_use_gale1);
            ai_showAIPrediction();
        }

        function ai_toggleVirtualGale() {
            const el = document.getElementById('ai_virtualGaleToggle');
            ai_use_virtual_gale = el.checked;
            localStorage.setItem('ai_use_virtual_gale', ai_use_virtual_gale);
            ai_virtual_stage = 0;
            ai_showAIPrediction();
        }

        function ai_toggleManualPause() {
            const el = document.getElementById('ai_manualPauseToggle');
            ai_manual_pause = el.checked;
            localStorage.setItem('ai_manual_pause', ai_manual_pause);
            ai_showAIPrediction();
        }

        function ai_toggleAntiChessMode() {
            const el = document.getElementById('ai_antiChessToggle');
            ai_anti_chess_mode = el.checked;
            localStorage.setItem('ai_anti_chess_mode', ai_anti_chess_mode);
            ai_showAIPrediction();
        }

        function ai_toggleOpcoesDouble() {
            const el = document.getElementById('ai_opcoesDoubleToggle');
            ai_opcoes_double_mode = el.checked;
            localStorage.setItem('ai_opcoes_double_mode', ai_opcoes_double_mode);
            ai_showAIPrediction();
        }

        function ai_selectPlatform(platform) {
            document.getElementById('ai_platformSelector').value = platform;
            document.getElementById('ai_btn-blaze').classList.remove('active');
            document.getElementById('ai_btn-jonbet').classList.remove('active');
            document.getElementById(`ai_btn-${platform}`).classList.add('active');
            
            ai_fetchData();
        }

        async function ai_fetchData() {
            updateConnectionStatus('connecting', 'Buscando...');
            const loader = document.getElementById('ai_loading_indicator');
            if (loader) loader.style.display = 'block';
            const startTime = Date.now();

            let SEU_TOKEN_BLAZE = localStorage.getItem('blaze_token');
            if (!SEU_TOKEN_BLAZE) {
                try {
                    if (window.parent && window.parent.localStorage) {
                        SEU_TOKEN_BLAZE = window.parent.localStorage.getItem('blaze_token');
                    }
                } catch (e) { /* cross-origin error */ }
                if (!SEU_TOKEN_BLAZE) SEU_TOKEN_BLAZE = "";
            }

            try {
                const agora = new Date();
                const ontem = new Date();
                ontem.setHours(ontem.getHours() - 24);
        
                const endDate = agora.toISOString();
                const startDate = ontem.toISOString();
        
                const headers = {};
                if (SEU_TOKEN_BLAZE) {
                    headers['Authorization'] = `Bearer ${SEU_TOKEN_BLAZE}`;
                    headers['x-access-token'] = SEU_TOKEN_BLAZE;
                }

                const pages = [1, 2, 3, 4, 5, 6, 7, 8]; // Aumentado para garantir histórico de 100+
                let allGames = [];
                for (const page of pages) {
                    try {
                        const baseUrl = `https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/history/${page}`;
                        const params = `?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}&page=${page}&_nc=${Date.now()}`;
                        const targetUrl = `${baseUrl}${params}`;
                        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                        
                        const response = await fetch(proxyUrl, { method: 'GET', headers: headers });
                        if (response.ok) {
                            const data = await response.json();
                            if (data) {
                                const records = Array.isArray(data) ? data : (data.records || []);
                                allGames = allGames.concat(records);
                                if (records.length === 0) break;
                            }
                        } else {
                            if (response.status === 401) throw new Error("Token inválido (401).");
                            console.warn(`Falha ao buscar página ${page}: Status ${response.status}`);
                        }
                    } catch (err) {
                        console.warn(`Erro de rede ao buscar página ${page}:`, err);
                    }
                    await new Promise(resolve => setTimeout(resolve, 250));
                }

                const seenIds = new Set();
                const uniqueGames = allGames.filter(game => {
                    if (game.id && !seenIds.has(game.id)) { seenIds.add(game.id); return true; }
                    return false;
                }).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                if (uniqueGames.length === 0) {
                    throw new Error("A API não retornou jogos.");
                }
        
                let formattedText = "";
                uniqueGames.forEach(game => {
                    if (game.created_at && game.roll !== undefined) {
                        const dateObj = new Date(game.created_at);
                        const hours = dateObj.getHours().toString().padStart(2, '0');
                        const minutes = dateObj.getMinutes().toString().padStart(2, '0');
                        const timeStr = `${hours}:${minutes}`;
                        const day = dateObj.getDate().toString().padStart(2, '0');
                        const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
                        const year = dateObj.getFullYear();
                        const dateStr = `${day}/${month}/${year}`;
                        formattedText += `${dateStr}\n${game.roll}\n${timeStr}\n\n`; 
                    }
                });

                sessionStorage.setItem('raw_blaze_data', formattedText);
                ai_processData(formattedText);

                const latency = Date.now() - startTime;
                let status = 'online';
                if (latency > 1000) status = 'slow';
                else if (latency > 500) status = 'fair';
                updateConnectionStatus(status, `Online (${latency}ms)`);

            } catch (error) {
                console.error("Erro no Auto-Fetch da Previsão IA:", error);
                updateConnectionStatus('error', `Erro: ${error.message}`);
            } finally {
                if (loader) loader.style.display = 'none';
            }
        }

        function ai_processData(rawData) {
            if (!rawData) return;
            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            const results = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    results.push({ date: tokens[i], roll: parseInt(tokens[i + 1]), time: tokens[i + 2] });
                    i += 2;
                }
            }
            
            if (results.length > 0) {
                const latest = results[0];
                const signature = latest.date + latest.time + latest.roll;
                if (signature !== ai_last_processed_signature) {
                    // Só libera a espera da próxima pedra se o tempo de espera (delay) já tiver encerrado
                    if (ai_waiting_for_next_stone && Date.now() >= ai_waiting_until) {
                        if (ai_stones_current_wait > 0) {
                            ai_stones_current_wait--;
                        }
                        if (ai_stones_current_wait <= 0) {
                            ai_waiting_for_next_stone = false;
                        }
                    }

                    if (ai_current_prediction && ai_last_processed_signature !== '') {
                        const resultColor = ai_identificarCor(latest.roll);
                        const isWin = (resultColor === ai_current_prediction || resultColor === 'branco');

                        // Atualiza o placar e histórico independentemente do Gale Virtual
                        if (isWin) {
                            ai_consecutive_wins++;
                            if (ai_consecutive_wins > ai_max_consecutive_wins) {
                                ai_max_consecutive_wins = ai_consecutive_wins;
                            }
                            ai_consecutive_losses = 0;
                            ai_last_prediction_on_loss = null; 
                            ai_playWinSound();
                            
                            ai_wins++;
                            ai_results_history.push({ timestamp: Date.now(), result: 'win' });
                            ai_balance_history.push(ai_balance_history[ai_balance_history.length-1] + 1);
                            
                            ai_waiting_until = Date.now() + (ai_win_wait_time * 1000);
                            setTimeout(() => ai_showAIPrediction(), (ai_win_wait_time * 1000));
                            ai_waiting_for_next_stone = true;
                            
                            // Reset Auto Wait on Win
                            if (ai_auto_wait_loss && ai_stones_wait_setting > 1) {
                                ai_stones_wait_setting = 1;
                                localStorage.setItem('ai_stones_wait_setting', ai_stones_wait_setting);
                                const input = document.getElementById('ai_stonesWaitInput');
                                if (input) input.value = ai_stones_wait_setting;
                            }
                            ai_stones_current_wait = ai_stones_wait_setting;
                        } else {
                            ai_consecutive_losses++;
                            if (ai_consecutive_losses > ai_max_consecutive_losses) {
                                ai_max_consecutive_losses = ai_consecutive_losses;
                            }
                            ai_consecutive_wins = 0;
                            if (ai_use_gale1) {
                                if (ai_last_prediction_on_loss) {
                                    // Já estava no Gale e perdeu (Gale falhou) -> Reseta para evitar loop infinito
                                    ai_last_prediction_on_loss = null;
                                } else {
                                    // Primeira perda -> Ativa Gale 1
                                    ai_last_prediction_on_loss = ai_current_prediction;
                                }
                            }
                            ai_playLossSound();
                            
                            ai_losses++;
                            ai_results_history.push({ timestamp: Date.now(), result: 'loss' });
                            ai_balance_history.push(ai_balance_history[ai_balance_history.length-1] - 1);
                            
                            ai_waiting_until = Date.now() + (ai_win_wait_time * 1000);
                            setTimeout(() => ai_showAIPrediction(), (ai_win_wait_time * 1000));
                            ai_waiting_for_next_stone = true;

                            // Auto Increment Wait on Loss
                            if (ai_auto_wait_loss) {
                                ai_stones_wait_setting++;
                                localStorage.setItem('ai_stones_wait_setting', ai_stones_wait_setting);
                                const input = document.getElementById('ai_stonesWaitInput');
                                if (input) input.value = ai_stones_wait_setting;
                            }
                            ai_stones_current_wait = ai_stones_wait_setting;
                        }

                        // Salvar placar atualizado
                        localStorage.setItem('ai_session_stats', JSON.stringify({
                            wins: ai_wins,
                            losses: ai_losses,
                            balance: ai_balance_history,
                            consecutive_wins: ai_consecutive_wins,
                            consecutive_losses: ai_consecutive_losses,
                            max_consecutive_wins: ai_max_consecutive_wins,
                            max_consecutive_losses: ai_max_consecutive_losses
                        }));

                        // Lógica do Gale Virtual (Apenas para controle de estado visual)
                        if (ai_use_virtual_gale) {
                            if (ai_virtual_stage === 0) {
                                // Estágio Virtual: Apenas monitora
                                if (!isWin) {
                                    ai_virtual_stage = 1; // Loss Virtual -> Ativa Entrada Real
                                } else {
                                    ai_virtual_stage = 0; // Win Virtual -> Continua simulando
                                }
                            } else {
                                ai_virtual_stage = 0; // Reseta para virtual após a aposta real
                            }
                        }
                        ai_current_prediction = null;
                    }
                    ai_last_processed_signature = signature;

                    // Limpa histórico antigo e salva
                    const oneHourAgo = Date.now() - (60 * 60 * 1000);
                    ai_results_history = ai_results_history.filter(r => r.timestamp > oneHourAgo);
                    localStorage.setItem('ai_results_history', JSON.stringify(ai_results_history));
                }
            }
            
            ai_showAIPrediction();
        }

        function ai_identificarCor(numero) {
            numero = parseInt(numero);
            if (numero === 0) return 'branco';
            if (numero >= 1 && numero <= 7) return 'vermelho';
            if (numero >= 8 && numero <= 14) return 'preto';
            return 'desconhecido';
        }

        function ai_showAIPrediction() {
            const rawData = sessionStorage.getItem('raw_blaze_data');
            
            // Inicializa variáveis com valores padrão
            let redScore = 0, blackScore = 0, reasoning = [];
            let whiteScore = 0;
            let prediction = 'Aguardando Dados...', confidence = 0, predictionClass = '';
            let history = [], fullHistory = [];
            let redCount = 0, blackCount = 0;
            let marketTrend = 0, r10 = 0, b10 = 0;

            // --- PARSING GLOBAL (Para garantir que gráficos funcionem sempre) ---
            if (rawData) {
                const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
                for (let i = 0; i < tokens.length; i++) {
                    if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                        const timeParts = tokens[i+2].split(':');
                        const minuteDigit = timeParts[1] ? parseInt(timeParts[1][1]) : 0; // Pega o último dígito do minuto
                        fullHistory.push({ 
                            color: ai_identificarCor(parseInt(tokens[i + 1])), 
                            roll: parseInt(tokens[i + 1]),
                            minuteDigit: minuteDigit
                        });
                        i += 2;
                    }
                }
                history = fullHistory.filter(item => item.color !== 'branco').map(item => item.color);
            }

            // Verifica estado do toggle Opções Double
            const opcoesDoubleToggle = document.getElementById('ai_opcoesDoubleToggle');
            if (opcoesDoubleToggle) {
                ai_opcoes_double_mode = opcoesDoubleToggle.checked;
            }

            // Verifica se está em pausa manual
            if (ai_manual_pause) {
                prediction = 'PAUSADO';
                confidence = 0;
                predictionClass = 'paused';
                reasoning.push("<strong>⏸️ Pausa Manual:</strong> Robô pausado pelo usuário.");
                document.body.classList.remove('white-alert-active');
                ai_current_prediction = null;
            }
            // Verifica se está em pausa pós-loss
            else if (Date.now() < ai_pause_until) {
                prediction = 'Analisando...';
                confidence = 0;
                predictionClass = '';
                reasoning.push("Pausa tática de segurança.");
                document.body.classList.remove('white-alert-active');
                ai_current_prediction = null;
            }
            // Verifica se está em espera visual pós-resultado
            else if (Date.now() < ai_waiting_until) {
                prediction = 'AGUARDANDO..';
                predictionClass = 'waiting';
                confidence = 0;
                reasoning.push("<span class='recalibrating-anim'>🔄 Reiniciando: Processando resultados e recalibrando I.A.</span>");
                ai_current_prediction = null;
            }
            // Verifica se está aguardando a próxima pedra (Nova Regra)
            else if (ai_waiting_for_next_stone) {
                prediction = `Aguardando Pedra (${ai_stones_current_wait})...`;
                predictionClass = 'waiting';
                confidence = 0;
                reasoning.push("<span class='recalibrating-anim'>⏳ Sincronizando: Aguardando nova pedra para análise.</span>");
                ai_current_prediction = null;
            }
            // Executa a lógica de previsão apenas se houver dados suficientes e não estiver em pausa
            else if (fullHistory.length >= 7) {
                
                // GALE 1 OVERRIDE LOGIC
                if (ai_use_gale1 && ai_last_prediction_on_loss && (ai_last_prediction_on_loss === 'vermelho' || ai_last_prediction_on_loss === 'preto')) {
                    const galeTargetColor = ai_invert_gale 
                        ? (ai_last_prediction_on_loss === 'vermelho' ? 'preto' : 'vermelho') 
                        : ai_last_prediction_on_loss;

                    if (galeTargetColor === 'vermelho') {
                        redScore += 1000; // Prioridade máxima para garantir a entrada do Gale
                    } else {
                        blackScore += 1000; // Prioridade máxima para garantir a entrada do Gale
                    }
                    reasoning.unshift(`<strong>🔄 GALE 1 (${ai_invert_gale ? 'Invertido' : 'Normal'}):</strong> Recuperação ativa -> ${galeTargetColor.toUpperCase()}.`);
                    
                }

                // --- NOVA LÓGICA DE ANÁLISE ADAPTATIVA (V2.0) ---
                
                // 1. Análise de Contexto de Mercado (Trend vs Lateral)
                const recent10 = history.slice(0, 10);
                r10 = recent10.filter(c => c === 'vermelho').length;
                b10 = recent10.filter(c => c === 'preto').length;
                marketTrend = Math.abs(r10 - b10) / 10; // 0.0 a 1.0
                const isTrend = marketTrend >= 0.4; // Tendência se diferença >= 40%
                
                if (isTrend) reasoning.push(`<strong>📊 Contexto:</strong> Mercado em Tendência (${(marketTrend*100).toFixed(0)}% força).`);
                else reasoning.push(`<strong>📊 Contexto:</strong> Mercado Lateralizado/Equilíbrio.`);

                // 2. Estratégias Baseadas no Contexto

                // A. Surf Inteligente (Apenas em Tendência)
                if (isTrend && history.length >= 3 && history[0] === history[1]) {
                    if (history[0] === 'vermelho') redScore += 3; else blackScore += 3;
                    reasoning.push("<strong>🌊 Surf de Tendência:</strong> Aproveitando o fluxo forte.");
                }

                // B. Quebra de Padrão (Apenas em Lateralização)
                if (!isTrend && history.length >= 2 && history[0] === history[1]) {
                    if (history[0] === 'vermelho') blackScore += 2; else redScore += 2;
                    reasoning.push("<strong>⚡ Quebra de Lateralização:</strong> Apostando contra micro-sequência.");
                }

                // C. Padrão Xadrez (Alternância)
                if (history.length >= 3 && history[0] !== history[1] && history[1] !== history[2]) {
                    if (history[0] === 'vermelho') blackScore += 2.5; else redScore += 2.5;
                    reasoning.push("<strong>♟️ Xadrez Confirmado:</strong> Seguindo a alternância.");
                }

                // D. Padrão 2x2 (Formação de Duplas)
                if (history.length >= 3 && history[0] !== history[1] && history[1] === history[2]) {
                    // Ex: V V P -> P (Para formar V V P P)
                    if (history[0] === 'vermelho') redScore += 2; else blackScore += 2;
                    reasoning.push("<strong>🪞 Padrão 2x2:</strong> Buscando simetria de duplas.");
                }

                // E. Reversão Crítica (Sniper)
                if (history.length >= 6 && history.slice(0, 6).every(c => c === history[0])) {
                    if (history[0] === 'vermelho') blackScore += 4; else redScore += 4;
                    reasoning.push("<strong>⚠️ Reversão Crítica:</strong> Sequência esticada (6+), alta probabilidade de corte.");
                }

                // F. MHI Adaptativo (Maioria em Trend, Minoria em Lateral)
                if (history.length >= 3) {
                    const last3 = history.slice(0, 3);
                    const r3 = last3.filter(c => c === 'vermelho').length;
                    const b3 = last3.filter(c => c === 'preto').length;
                    if (!isTrend) {
                        if (r3 > b3) { blackScore += 1.5; reasoning.push("<strong>📉 MHI (Lateral):</strong> Apostando na minoria."); }
                        else { redScore += 1.5; reasoning.push("<strong>📉 MHI (Lateral):</strong> Apostando na minoria."); }
                    } else {
                        if (r3 > b3) { redScore += 1.5; reasoning.push("<strong>📈 MHI Reverso (Trend):</strong> Apostando na maioria."); }
                        else { blackScore += 1.5; reasoning.push("<strong>📈 MHI Reverso (Trend):</strong> Apostando na maioria."); }
                    }
                }

                // G. Balanceamento Global (100 rodadas)
                if (fullHistory.length >= 100) {
                    const last100 = fullHistory.slice(0, 100).filter(x => x.color !== 'branco');
                    if (last100.length > 0) {
                        const r100 = last100.filter(x => x.color === 'vermelho').length;
                        const rPct = r100 / last100.length;
                        
                        if (rPct >= 0.56) { // > 56% Vermelho
                            blackScore += 8;
                            reasoning.unshift(`<strong>⚖️ Balanceamento (100):</strong> Excesso de Vermelhos (${(rPct*100).toFixed(0)}%). Correção para Preto.`);
                        } else if (rPct <= 0.44) { // < 44% Vermelho (Excesso de Preto)
                            redScore += 8;
                            reasoning.unshift(`<strong>⚖️ Balanceamento (100):</strong> Excesso de Pretos (${((1-rPct)*100).toFixed(0)}%). Correção para Vermelho.`);
                        }
                    }
                } else if (fullHistory.length >= 50) {
                    const last50 = fullHistory.slice(0, 50).filter(x => x.color !== 'branco');
                    const r50 = last50.filter(x => x.color === 'vermelho').length;
                    const rPct = r50 / last50.length;
                    if (rPct > 0.60) { blackScore += 3; reasoning.push("<strong>⚖️ Balanceamento (50):</strong> Vermelho sobrecomprado (>60%)."); }
                    if (rPct < 0.40) { redScore += 3; reasoning.push("<strong>⚖️ Balanceamento (50):</strong> Vermelho sobrevendido (<40%)."); }
                }

                // H. Padrão Diamante (Alta Precisão 95%+)
                if (history.length >= 4 && history[0] === history[1] && history[2] === history[3] && history[1] !== history[2]) {
                    const target = history[2]; // Busca a reversão para a cor anterior
                    if (target === 'vermelho') redScore += 5; else blackScore += 5;
                    reasoning.unshift(`<strong>💎 Padrão Diamante (95%+):</strong> Reversão de Dupla Alternada (2x2) identificada.`);
                }

                // I. Padrão 3-1-3 (Simetria de Tendência - 93%)
                if (history.length >= 6 && history[0] === history[1] && history[1] !== history[2] && history[3] === history[4] && history[4] === history[5] && history[0] === history[3]) {
                    if (history[0] === 'vermelho') redScore += 4.5; else blackScore += 4.5;
                    reasoning.unshift(`<strong>📐 Padrão 3-1-3 (93%):</strong> Completando simetria de tendência.`);
                }

                // J. Fluxo de Repetição 4x4 (Memória de Mercado - 97%)
                if (history.length >= 8) {
                    const block1 = history.slice(0, 4).join('');
                    const block2 = history.slice(4, 8).join('');
                    if (block1 === block2) {
                        const target = history[3]; // Segue o fluxo do ciclo anterior
                        if (target === 'vermelho') redScore += 6; else blackScore += 6;
                        reasoning.unshift(`<strong>🔁 Fluxo de Repetição 4x4 (97%):</strong> Fractal de mercado identificado.`);
                    }
                }

                // K. Desvio Padrão de Bollinger (Reversão Estatística - 96%)
                if (fullHistory.length >= 20) {
                    const last20 = fullHistory.slice(0, 20).filter(x => x.color !== 'branco');
                    const redCount20 = last20.filter(x => x.color === 'vermelho').length;
                    // Média em 20 = 10. Desvio Padrão (σ) ≈ 2.23. Limites 2σ: ~14.5 e ~5.5.
                    if (redCount20 >= 15) { 
                        blackScore += 5;
                        reasoning.unshift(`<strong>📉 Desvio Padrão (96%):</strong> Excesso de Vermelhos (>2σ). Correção estatística iminente.`);
                    } else if (redCount20 <= 5) { 
                        redScore += 5;
                        reasoning.unshift(`<strong>📈 Desvio Padrão (96%):</strong> Escassez de Vermelhos (<-2σ). Correção estatística iminente.`);
                    }
                }

                // L. Cadeias de Markov (Probabilidade Condicional - 99%)
                if (history.length >= 50) {
                    const t0 = history[0]; // Último resultado
                    const t1 = history[1]; // Penúltimo resultado
                    let markovRed = 0, markovBlack = 0;
                    // Varre o histórico buscando o que aconteceu após a sequência [t1 -> t0]
                    for (let k = 2; k < history.length - 1; k++) {
                        if (history[k+1] === t1 && history[k] === t0) {
                            const nextResult = history[k-1];
                            if (nextResult === 'vermelho') markovRed++;
                            else if (nextResult === 'preto') markovBlack++;
                        }
                    }
                    const totalMarkov = markovRed + markovBlack;
                    if (totalMarkov >= 4) { // Amostra mínima para relevância
                        const pRed = markovRed / totalMarkov;
                        if (pRed >= 0.90) {
                            redScore += 6;
                            reasoning.unshift(`<strong>🧬 Cadeias de Markov (99%):</strong> Padrão histórico indica ${(pRed*100).toFixed(0)}% de chance para Vermelho.`);
                        } else if (pRed <= 0.10) {
                            blackScore += 6;
                            reasoning.unshift(`<strong>🧬 Cadeias de Markov (99%):</strong> Padrão histórico indica ${((1-pRed)*100).toFixed(0)}% de chance para Preto.`);
                        }
                    }
                }

                // M. Oscilador Estocástico Numérico (Cálculo de Valor - 96%)
                if (fullHistory.length >= 5) {
                    const last5Rolls = fullHistory.slice(0, 5).map(x => x.roll);
                    const sum5 = last5Rolls.reduce((a, b) => a + b, 0);
                    // Média esperada (7.5 * 5) = 37.5. 
                    // Soma Baixa (<25) indica excesso de Vermelhos (1-7). Soma Alta (>50) indica excesso de Pretos (8-14).
                    if (sum5 <= 22) {
                        blackScore += 5.5;
                        reasoning.unshift(`<strong>📉 Oscilador Estocástico (96%):</strong> Soma numérica crítica (${sum5}). Zona de Sobrevenda (Reds).`);
                    } else if (sum5 >= 53) {
                        redScore += 5.5;
                        reasoning.unshift(`<strong>📈 Oscilador Estocástico (96%):</strong> Soma numérica crítica (${sum5}). Zona de Sobrecompra (Blacks).`);
                    }
                }

                // N. Anomalia de Distribuição de Primos (Cálculo Matemático - 98%)
                if (fullHistory.length >= 8) {
                    const last8 = fullHistory.slice(0, 8);
                    const primes = [2, 3, 5, 7, 11, 13]; // Primos na roleta (0-14)
                    const primeCount = last8.filter(x => primes.includes(x.roll)).length;
                    
                    // Probabilidade normal ~42%. Se > 80% (7+ em 8) é anomalia matemática.
                    if (primeCount >= 7) {
                        if (last8[0].color === 'vermelho') { blackScore += 6; } else { redScore += 6; }
                        reasoning.unshift(`<strong>⚛️ Anomalia de Primos (98%):</strong> Saturação matemática detectada (${primeCount}/8 Primos).`);
                    }
                }

                // O. Indicador RSI (Relative Strength Index - 99%)
                if (fullHistory.length >= 14) {
                    const last14 = fullHistory.slice(0, 14).filter(x => x.color !== 'branco');
                    if (last14.length > 0) {
                        const redCount14 = last14.filter(x => x.color === 'vermelho').length;
                        const rsi = (redCount14 / last14.length) * 100;
                        
                        if (rsi >= 80) { // Sobrecompra de Vermelho
                            blackScore += 6;
                            reasoning.unshift(`<strong>📉 Indicador RSI (99%):</strong> Zona de Sobrecompra (${rsi.toFixed(0)}%). Reversão para Preto.`);
                        } else if (rsi <= 20) { // Sobrevenda de Vermelho (Sobrecompra de Preto)
                            redScore += 6;
                            reasoning.unshift(`<strong>📈 Indicador RSI (99%):</strong> Zona de Sobrevenda (${rsi.toFixed(0)}%). Reversão para Vermelho.`);
                        }
                    }
                }

                // P. Padrão Palíndromo (Espelho - 96%)
                // Busca formação A B B ... Prever A para fechar A B B A
                if (history.length >= 3 && history[0] === history[1] && history[1] !== history[2]) {
                    const target = history[2]; // A cor que iniciou o padrão
                    if (target === 'vermelho') redScore += 4.5; else blackScore += 4.5;
                    reasoning.unshift(`<strong>🪞 Padrão Palíndromo (96%):</strong> Fechamento de simetria espelhada (A-B-B-A).`);
                }

                // Q. Ciclo de Repetição Temporal (4-Step - 97%)
                // Verifica se o resultado atual repete o de 4 rodadas atrás (Ciclo curto)
                if (history.length >= 5 && history[0] === history[4]) {
                    const nextInCycle = history[3]; // O que veio depois do history[4]
                    if (nextInCycle === 'vermelho') redScore += 5; else blackScore += 5;
                    reasoning.unshift(`<strong>⏳ Ciclo Temporal 4-Step (97%):</strong> Repetição de fractal de curto prazo.`);
                }

                // R. Análise de Vetor de Força (Momentum - 98%)
                // Se tivermos 3 vitórias seguidas de uma cor com números crescentes ou decrescentes (Força direcional)
                if (fullHistory.length >= 3) {
                    const last3 = fullHistory.slice(0, 3);
                    if (last3[0].color === last3[1].color && last3[1].color === last3[2].color && last3[0].color !== 'branco') {
                        // Verifica se os números estão em tendência (ex: 2 -> 5 -> 11)
                        const val0 = last3[0].roll;
                        const val1 = last3[1].roll;
                        const val2 = last3[2].roll;
                        
                        if ((val0 > val1 && val1 > val2) || (val0 < val1 && val1 < val2)) {
                            // Momentum forte confirmado -> Seguir a tendência
                            if (last3[0].color === 'vermelho') redScore += 5.5; else blackScore += 5.5;
                            reasoning.unshift(`<strong>🚀 Vetor de Força (98%):</strong> Momentum numérico confirmado. Surf de tendência.`);
                        }
                    }
                }
                
                // S. Indicador de Soma Tripla (Reversão - 97%)
                if (fullHistory.length >= 3) {
                    const last3Rolls = fullHistory.slice(0, 3).map(x => x.roll);
                    const sum3 = last3Rolls.reduce((a, b) => a + b, 0);
                    
                    if (sum3 <= 12) {
                        blackScore += 5;
                        reasoning.unshift(`<strong>🔢 Soma Tripla (97%):</strong> Soma baixa (${sum3}). Reversão para Preto.`);
                    } else if (sum3 >= 33) {
                        redScore += 5;
                        reasoning.unshift(`<strong>🔢 Soma Tripla (97%):</strong> Soma alta (${sum3}). Reversão para Vermelho.`);
                    }
                }

                // T. Paridade da Soma (Estatística - 96%)
                if (fullHistory.length >= 3) {
                    const last3Rolls = fullHistory.slice(0, 3).map(x => x.roll);
                    const sum3 = last3Rolls.reduce((a, b) => a + b, 0);
                    const isEven = sum3 % 2 === 0;
                    
                    if (isEven) {
                        blackScore += 4;
                        reasoning.unshift(`<strong>⚖️ Paridade da Soma (96%):</strong> Soma PAR (${sum3}). Probabilidade maior para Preto.`);
                    } else {
                        redScore += 4;
                        reasoning.unshift(`<strong>⚖️ Paridade da Soma (96%):</strong> Soma ÍMPAR (${sum3}). Probabilidade maior para Vermelho.`);
                    }
                }

                // U. Estratégia Pós-Loss Imediato (Seguir a Cor - 99%)
                if (ai_consecutive_losses > 0 && history.length > 0) {
                    const lastResult = history[0];
                    if (lastResult === 'vermelho') {
                        redScore += 10;
                        reasoning.unshift(`<strong>🔄 Pós-Loss (99%):</strong> Seguindo a cor do último resultado (Vermelho).`);
                    } else if (lastResult === 'preto') {
                        blackScore += 10;
                        reasoning.unshift(`<strong>🔄 Pós-Loss (99%):</strong> Seguindo a cor do último resultado (Preto).`);
                    }
                }

                // --- LÓGICA OPÇÕES DOUBLE (PROBABILIDADE TÉCNICA) ---
                if (ai_opcoes_double_mode) {
                    const candles = ai_od_generateCandles(rawData);
                    if (candles.length >= 26) {
                        const trendSignal = ai_od_getTrendSignal(candles);
                        if (trendSignal.signal !== "NEUTRO") {
                            if (trendSignal.signal === "VERMELHO") {
                                redScore += 5; // Peso alto para análise técnica
                                reasoning.unshift(`<strong>📈 Opções Double:</strong> Tendência de ALTA confirmada (SMA/MACD).`);
                            } else if (trendSignal.signal === "PRETO") {
                                blackScore += 5; // Peso alto para análise técnica
                                reasoning.unshift(`<strong>📉 Opções Double:</strong> Tendência de BAIXA confirmada (SMA/MACD).`);
                            }
                        } else {
                            reasoning.push(`<strong>⚖️ Opções Double:</strong> Mercado sem tendência clara.`);
                        }
                    }
                }
                // -----------------------------------------------------

                // Cálculo para UI
                const recentHistory = history.slice(0, 20);
                redCount = recentHistory.filter(c => c === 'vermelho').length;
                blackCount = recentHistory.filter(c => c === 'preto').length;
                
                const lastWhiteIndex = fullHistory.findIndex(x => x.color === 'branco');
                const roundsSinceWhite = lastWhiteIndex === -1 ? fullHistory.length : lastWhiteIndex;
                
                // Cálculo de Probabilidade de Branco (Estimativa)
                let whiteProb = 7.14; // Base 1/14
                if (roundsSinceWhite > 15) whiteProb += (roundsSinceWhite - 15) * 0.6;
                
                if (whiteProb > 10) {
                    if (!document.body.classList.contains('white-alert-active')) {
                        document.body.classList.add('white-alert-active');
                    }
                    reasoning.push(`<strong>⚪ ALERTA DE BRANCO:</strong> Probabilidade > 10% (${whiteProb.toFixed(1)}%).`);
                } else {
                    document.body.classList.remove('white-alert-active');
                }

                if (roundsSinceWhite >= 25) { whiteScore += 1; reasoning.push(`<strong>Alerta Branco:</strong> ${roundsSinceWhite} rodadas sem branco.`); }
                if (roundsSinceWhite >= 50) { whiteScore += 2; reasoning.push(`<strong>Branco Crítico:</strong> Acúmulo muito alto (${roundsSinceWhite}).`); }

                const totalScore = redScore + blackScore;
                
                if (whiteScore >= 3.5) {
                    prediction = 'POSSÍVEL BRANCO';
                    predictionClass = 'white';
                    confidence = Math.min(98, 50 + (whiteScore * 10));
                    reasoning.unshift("<strong>ALTA PROBABILIDADE:</strong> Indicadores de Branco convergindo.");
                } else if (totalScore > 0) {
                    if (redScore > blackScore) { prediction = 'VERMELHO'; predictionClass = 'red'; confidence = (redScore / totalScore) * 100; } 
                    else if (blackScore > redScore) { prediction = 'PRETO'; predictionClass = 'black'; confidence = (blackScore / totalScore) * 100; }
                } else {
                    prediction = 'Analisando...';
                }

                // Análise de Minuto Quente (Frequência 0-9)
                const minuteCounts = Array(10).fill(0);
                fullHistory.forEach(item => {
                    if (item.minuteDigit !== undefined && !isNaN(item.minuteDigit)) {
                        minuteCounts[item.minuteDigit]++;
                    }
                });
                let hotMinute = 0;
                let maxFreq = 0;
                for(let i=0; i<10; i++) {
                    if (minuteCounts[i] > maxFreq) { maxFreq = minuteCounts[i]; hotMinute = i; }
                }
                const nowTime = new Date();
                const currentMinuteUnit = nowTime.getMinutes() % 10;
                if (currentMinuteUnit === hotMinute && confidence > 0) {
                    confidence += 10;
                    reasoning.push(`<strong>⏰ Minuto Quente (${hotMinute}):</strong> Alta frequência histórica neste final de minuto.`);
                }

                // Filtro Horário de Ouro (19h - 21h)
                if (ai_golden_hour_mode) {
                    const now = new Date();
                    const currentHour = now.getHours();
                    // Aumenta a confiança se estiver entre 19:00 e 20:59
                    if (currentHour >= 19 && currentHour < 21 && confidence > 0) {
                        confidence += 15;
                        reasoning.push("<strong>🌟 Horário de Ouro:</strong> Bônus de confiança ativo (19h-21h).");
                    }
                }

                // Filtro Minutos 1-5
                if (ai_minute_1_5_mode) {
                    const now = new Date();
                    const currentMinuteUnit = now.getMinutes() % 10;
                    if (currentMinuteUnit >= 1 && currentMinuteUnit <= 5 && confidence > 0) {
                        confidence += 10;
                        reasoning.push("<strong>⏰ Minuto 1-5:</strong> Entrada validada pelo intervalo de tempo.");
                    }
                }

                // --- Lógica de Gale Virtual Retroativo (Correção) ---
                // Verifica se a estratégia teria errado nas rodadas anteriores (Loss Virtual)
                let galeLevel = 0;
                if (history.length >= 2) {
                    const last = history[0];
                    // Simulação: Se vinha de sequência (2+), aposta a favor. Se não, aposta contra (xadrez).
                    let predictedForLast = null;
                    if (history.length >= 3 && history[1] === history[2]) {
                        predictedForLast = history[1]; // Surf
                    } else {
                        predictedForLast = history[1] === 'vermelho' ? 'preto' : 'vermelho'; // Alternância
                    }
                    
                    if (last !== predictedForLast && last !== 'branco') {
                        galeLevel = 1;
                        // Verifica Gale 2
                        if (history.length >= 4) {
                             let predictedForPrev = null;
                             if (history[2] === history[3]) predictedForPrev = history[2];
                             else predictedForPrev = history[2] === 'vermelho' ? 'preto' : 'vermelho';
                             if (history[1] !== predictedForPrev && history[1] !== 'branco') galeLevel = 2;
                        }
                    }
                }

                if (galeLevel > 0) {
                    confidence += (galeLevel * 15); // Aumenta confiança no Gale
                    reasoning.push(`<strong>🔥 GALE ${galeLevel} VIRTUAL:</strong> Recuperação de perda anterior detectada.`);
                    if (ai_use_virtual_gale) ai_virtual_stage = 1; // Força entrada Real
                }
                
                // Garante que a confiança não ultrapasse 100%
                if (confidence > 100) confidence = 100;

                if (prediction === 'VERMELHO') ai_current_prediction = 'vermelho';
                else if (prediction === 'PRETO') ai_current_prediction = 'preto';
                else if (prediction === 'POSSÍVEL BRANCO') ai_current_prediction = 'branco';
                else ai_current_prediction = null;
            } else {
                reasoning.push("Aguardando dados suficientes para análise...");
                document.body.classList.remove('white-alert-active');
            }
            
            // Filtro do Modo Conservador (Confiança > 90%)
            if (ai_conservative_mode && confidence <= 90 && prediction !== 'Aguardando Dados...' && prediction !== 'Analisando...') {
                prediction = 'Modo Conservador';
                predictionClass = '';
                ai_current_prediction = null;
                // Adiciona nota ao raciocínio
                reasoning.unshift("<strong>Filtro Ativo:</strong> Aguardando sinal com confiança > 90%.");
            }

            let predictionDisplayText = prediction;
            let gale1IndicatorHtml = '';

            if (ai_use_gale1 && prediction !== 'Aguardando Dados...' && prediction !== 'Analisando...' && prediction !== 'Sinal Fraco' && prediction !== 'Modo Conservador' && prediction !== 'Buscando Certeira...' && prediction !== 'POSSÍVEL BRANCO' && prediction !== 'AGUARDANDO..') {
                gale1IndicatorHtml = `<div class="gale-indicator">1x</div>`;
                reasoning.push("<strong>🔄 Gale 1 Ativo:</strong> Cobrir até a 2ª tentativa.");
            }

            let virtualStatusHtml = "";
            let boxStyle = "";

            // O restante da função continua, usando os valores padrão ou os calculados
            if (ai_use_virtual_gale) {
                if (ai_virtual_stage === 0) {
                    predictionDisplayText += " (VIRTUAL)";
                    virtualStatusHtml = `<div style="color: #aaa; font-size: 0.8rem; margin-top: 5px; border-top: 1px solid #444; padding-top: 5px;">🤖 Simulando... Aguardando Loss para entrar.</div>`;
                    boxStyle = "opacity: 0.7; border-style: dashed;";
                } else {
                    predictionDisplayText += " (REAL)";
                    virtualStatusHtml = `<div style="color: #00ff88; font-size: 0.9rem; margin-top: 5px; font-weight: bold; border-top: 1px solid #444; padding-top: 5px;">🔥 LOSS VIRTUAL DETECTADO! ENTRADA LIBERADA!</div>`;
                    boxStyle = "box-shadow: 0 0 25px " + (predictionClass === 'red' ? 'rgba(255, 0, 85, 0.6)' : 'rgba(255, 255, 255, 0.4)') + "; transform: scale(1.05); border-width: 3px;";
                }
            }

            let whiteHtml = '';
            if (whiteScore >= 1 && predictionClass !== 'white') whiteHtml = `<div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 6px; border: 1px solid #fff; color: #fff; font-weight: bold; text-shadow: 0 0 5px #fff; box-shadow: 0 0 10px rgba(255,255,255,0.2);">⚪ SUGESTÃO: COBRIR O BRANCO</div>`;
            
            let outerStyle = '', innerStyle = '', coreStyle = '';
            if (predictionClass === 'red') {
                outerStyle = 'border-top-color: #ff0055; border-bottom-color: #ff9800; box-shadow: 0 0 20px rgba(255, 0, 85, 0.4);';
                innerStyle = 'border-left-color: #ff45d4; border-right-color: #ff0000;';
                coreStyle = 'background-color: #ff0055; box-shadow: 0 0 15px 5px rgba(255, 0, 85, 0.6);';
            } else if (predictionClass === 'black') {
                outerStyle = 'border-top-color: #666; border-bottom-color: #999; box-shadow: 0 0 20px rgba(150, 150, 150, 0.3);';
                innerStyle = 'border-left-color: #555; border-right-color: #888;';
                coreStyle = 'background-color: #777; box-shadow: 0 0 15px 5px rgba(150, 150, 150, 0.5);';
            } else if (predictionClass === 'white') {
                outerStyle = 'border-top-color: #fff; border-bottom-color: #fff; box-shadow: 0 0 30px rgba(255, 255, 255, 0.6); animation-duration: 1s;';
                innerStyle = 'border-left-color: #ccc; border-right-color: #eee; animation-duration: 0.5s;';
                coreStyle = 'background-color: #fff; box-shadow: 0 0 25px 10px rgba(255, 255, 255, 0.9); animation: pulse-ai 0.2s ease-in-out infinite alternate;';
            } else if (predictionClass === 'waiting') {
                outerStyle = 'border-top-color: #00d2ff; border-bottom-color: #00d2ff; animation: spin-ai 1s linear infinite;';
                innerStyle = 'border-left-color: #00d2ff; border-right-color: #00d2ff; opacity: 0.5;';
                coreStyle = 'background-color: #00d2ff; box-shadow: 0 0 15px #00d2ff; animation: pulse-ai 0.5s infinite;';
            } else if (predictionClass === 'paused') {
                outerStyle = 'border-top-color: #ffc107; border-bottom-color: #ffc107; box-shadow: 0 0 20px rgba(255, 193, 7, 0.4);';
                innerStyle = 'border-left-color: #ffc107; border-right-color: #ffc107; opacity: 0.5;';
                coreStyle = 'background-color: #ffc107; box-shadow: 0 0 15px #ffc107; animation: pulse-ai 1s infinite;';
            }

            const aiVisualHtml = `
                <div class="ai-visual-container">
                    <div class="ai-circle-outer" style="${outerStyle}">
                        <div class="ai-circle-inner" style="${innerStyle}"></div>
                        <div class="ai-core-dot" style="${coreStyle}"></div>
                    </div>
                </div>
            `;

            // Chart
            const chartData = ai_balance_history.slice(-30);
            const cw = 400, ch = 60, cpad = 5;
            let minVal = Math.min(...chartData);
            let maxVal = Math.max(...chartData);
            if (minVal === maxVal) { minVal -= 1; maxVal += 1; }
            const cRange = maxVal - minVal;
            
            let points = "";
            let dotsHtml = "";
            chartData.forEach((val, i) => {
                const x = (i / (chartData.length - 1 || 1)) * (cw - 2*cpad) + cpad;
                const y = (ch - cpad) - ((val - minVal) / cRange * (ch - 2*cpad));
                points += `${x},${y} `;

                if (i > 0) {
                    const prev = chartData[i-1];
                    let dotColor = '#888';
                    if (val > prev) dotColor = '#00ff88'; // Win
                    else if (val < prev) dotColor = '#ff0055'; // Loss
                    
                    dotsHtml += `<circle cx="${x}" cy="${y}" r="2.5" fill="${dotColor}" stroke="#1a1a1a" stroke-width="1" />`;
                } else {
                    dotsHtml += `<circle cx="${x}" cy="${y}" r="2" fill="#888" />`;
                }
            });

            const lastBal = ai_balance_history[ai_balance_history.length-1];
            const balColor = lastBal >= 0 ? '#00ff88' : '#ff0055';
            const chartHtml = `
                <div style="margin-bottom: 20px; background: rgba(0,0,0,0.4); border: 1px solid #333; border-radius: 8px; padding: 10px; position: relative; overflow: hidden;">
                    <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 5px; display: flex; justify-content: space-between; text-transform: uppercase; letter-spacing: 1px;"><span>Evolução do Saldo</span><span style="color: ${balColor}; font-weight: bold;">${lastBal > 0 ? '+' : ''}${lastBal}</span></div>
                    <svg viewBox="0 0 ${cw} ${ch}" style="width: 100%; height: 50px; overflow: visible;"><defs><linearGradient id="gradChart" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style="stop-color:#00d2ff;stop-opacity:1" /><stop offset="100%" style="stop-color:#a100ff;stop-opacity:1" /></linearGradient></defs><polyline points="${points}" fill="none" stroke="url(#gradChart)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />${dotsHtml}<circle cx="${(cw-cpad)}" cy="${(ch-cpad) - ((chartData[chartData.length-1]-minVal)/cRange*(ch-2*cpad))}" r="4" fill="#fff" class="chart-dot" /></svg>
                </div>
            `;

            // Trend Meter
            let trendScore = 0;
            const recentTotal = redCount + blackCount;
            if (recentTotal > 0) {
                const dominance = Math.max(redCount, blackCount) / recentTotal;
                trendScore = (dominance - 0.5) * 200;
            }
            let currentStreak = 0;
            if (history.length > 0) {
                currentStreak = 1;
                for(let i=1; i<history.length; i++) { if(history[i] === history[0]) currentStreak++; else break; }
            }
            if (currentStreak >= 3) trendScore += (currentStreak * 10);
            trendScore = Math.min(100, Math.max(0, trendScore));
            
            let trendLabel = "Lateral (Neutro)";
            let trendColor = "#00d2ff"; // Blue
            let trendIcon = "↔";
            
            if (trendScore >= 80) { trendLabel = "TENDÊNCIA FORTE"; trendColor = "#ff0055"; trendIcon = "🔥"; } // Red
            else if (trendScore >= 40) { trendLabel = "TENDÊNCIA MODERADA"; trendColor = "#ff9800"; trendIcon = "⚡"; } // Orange

            const totalSegments = 25;
            const activeSegments = Math.floor((trendScore / 100) * totalSegments);
            let segmentsHtml = '';
            for(let i=0; i<totalSegments; i++) {
                const isActive = i < activeSegments;
                const opacity = isActive ? '1' : '0.1';
                const glow = isActive ? `box-shadow: 0 0 5px ${trendColor};` : '';
                segmentsHtml += `<div class="trend-segment" style="background: ${trendColor}; opacity: ${opacity}; ${glow}"></div>`;
            }

            const trendHtml = `
                <div class="trend-meter-container">
                    <div class="trend-header">
                        <span style="display: flex; align-items: center; gap: 6px;"><span style="font-size: 1.2rem;">${trendIcon}</span> FORÇA DO MERCADO</span>
                        <span class="trend-value" style="color: ${trendColor}; text-shadow: 0 0 8px ${trendColor};">${trendScore.toFixed(0)}%</span>
                    </div>
                    <div style="width: 100%; height: 1px; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); margin-bottom: 10px;"></div>
                    <div class="trend-segments">
                        ${segmentsHtml}
                    </div>
                    <div style="text-align: right; font-size: 0.7rem; color: ${trendColor}; text-transform: uppercase; letter-spacing: 1px; margin-top: 5px; font-weight: bold;">${trendLabel}</div>
                </div>
            `;

            // Placar Movendo de Baixo para Cima (Ticker Vertical - Últimos Resultados)
            let tickerHtml = '';
            let displayItems = [];

            if (ai_filter_history) {
                // Show AI Results (Wins/Losses)
                displayItems = [...ai_results_history].reverse().slice(0, 20).map(r => ({
                    main: r.result === 'win' ? 'WIN' : 'LOSS',
                    sub: new Date(r.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}),
                    color: r.result === 'win' ? 'green' : 'red',
                    is_ai: true
                }));
            } else if (fullHistory.length > 0) {
                // Show Raw Game History
                displayItems = fullHistory.slice(0, 20).map(item => ({
                    main: item.roll,
                    sub: item.color,
                    color: item.color,
                    is_ai: false
                }));
            }

            let itemsHtml = '';
            if (displayItems.length > 0) {
                itemsHtml = displayItems.map(item => {
                    let colorHex, bg, textShadow;
                    if (item.is_ai) {
                        colorHex = item.color === 'green' ? '#00ff88' : '#ff0055';
                        bg = item.color === 'green' ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 0, 85, 0.1)';
                        textShadow = item.color === 'green' ? '0 0 5px rgba(0,255,136,0.5)' : 'none';
                    } else {
                        colorHex = item.color === 'vermelho' ? '#ff0055' : (item.color === 'branco' ? '#fff' : '#ccc');
                        bg = item.color === 'branco' ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.05)';
                        textShadow = item.color === 'branco' ? '0 0 5px #fff' : 'none';
                    }
                    return `<div style="display: flex; justify-content: space-between; padding: 6px 10px; background: ${bg}; border-radius: 4px; border-left: 3px solid ${colorHex}; font-size: 0.8rem; color: ${colorHex}; text-shadow: ${textShadow}; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        <span style="font-weight: bold;">${item.main}</span>
                        <span style="text-transform: uppercase; font-size: 0.7rem; opacity: 0.8;">${item.sub}</span>
                    </div>`;
                }).join('');
            } else {
                itemsHtml = `<div class="nd-container"><div class="nd-scan"></div><div class="nd-ring"></div><div class="nd-text">AGUARDANDO DADOS</div></div>`;
            }

            const filterLabel = ai_filter_history ? 'FILTRO: I.A.' : 'FILTRO: GERAL';
            const filterStyle = ai_filter_history ? 'color: #00d2ff; cursor: pointer; text-decoration: underline;' : 'color: #666; cursor: pointer;';
            const animationStyle = displayItems.length > 0 ? 'animation: scrollUp 15s linear infinite;' : '';

            tickerHtml = `
            <div style="margin-top: 15px; margin-bottom: 20px; height: 100px; overflow: hidden; position: relative; background: rgba(0,0,0,0.4); border: 1px solid #333; border-radius: 8px;">
                <div style="position: absolute; top: 0; left: 0; right: 0; padding: 10px; ${animationStyle}">
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        ${itemsHtml}
                        ${displayItems.length > 0 ? itemsHtml : ''} <!-- Duplicado para efeito de loop infinito -->
                    </div>
                </div>
                <!-- Máscaras de Gradiente para suavizar topo e base -->
                <div style="position: absolute; top: 0; left: 0; right: 0; height: 20px; background: linear-gradient(to bottom, var(--panel-bg), transparent); z-index: 2; pointer-events: none;"></div>
                <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 20px; background: linear-gradient(to top, var(--panel-bg), transparent); z-index: 2; pointer-events: none;"></div>
                <div onclick="ai_toggleHistoryFilter()" style="position: absolute; top: 5px; right: 10px; font-size: 0.6rem; z-index: 3; text-transform: uppercase; font-weight: bold; ${filterStyle}">${filterLabel}</div>
            </div>`;

            const totalPreds = ai_wins + ai_losses;
            const winRate = totalPreds > 0 ? ((ai_wins / totalPreds) * 100).toFixed(0) : 0;
            const statsContainer = document.getElementById('ai_stats_container');
            if (statsContainer) {
                statsContainer.innerHTML = `
                    <div style="display: flex; justify-content: space-around; text-align: center;">
                        <div><div style="font-size: 0.7rem; color: #aaa; text-transform: uppercase;">Wins</div><div style="font-size: 1.2rem; font-weight: bold; color: #00ff88;">${ai_wins}</div></div>
                        <div><div style="font-size: 0.7rem; color: #aaa; text-transform: uppercase;">Losses</div><div style="font-size: 1.2rem; font-weight: bold; color: #ff0055;">${ai_losses}</div></div>
                        <div><div style="font-size: 0.7rem; color: #aaa; text-transform: uppercase;">Assert.</div><div style="font-size: 1.2rem; font-weight: bold; color: #fff;">${winRate}%</div></div>
                    </div>`;
            }

            // --- Win Streak Counter ---
            const winStreakContainer = document.getElementById('ai_win_streak_container');
            if (winStreakContainer) {
                let streakCount = 0;
                let streakType = 'NEUTRO';
                let streakColor = '#888';
                let streakGoal = 4;

                if (ai_consecutive_losses > 0) {
                    streakCount = ai_consecutive_losses;
                    streakType = 'LOSS';
                    streakColor = '#ff0055';
                    streakGoal = 1; // Pausa imediata no loss
                } else if (ai_consecutive_wins > 0) {
                    streakCount = ai_consecutive_wins;
                    streakType = 'WIN';
                    streakColor = '#00ff88';
                }

                const streakPercent = Math.min(100, (streakCount / streakGoal) * 100);

                winStreakContainer.innerHTML = `
                    <div class="win-streak-display">
                        <div class="win-streak-text" style="color: ${streakColor}; text-shadow: 0 0 8px ${streakColor};">${streakCount} <span style="font-size:0.6em">${streakType}</span></div>
                        <div class="win-streak-bar-bg">
                            <div class="win-streak-bar-fill" style="width: ${streakPercent}%; background: ${streakColor}; box-shadow: 0 0 8px ${streakColor};"></div>
                        </div>
                    </div>
                `;
            }
            // --- End Win Streak Counter ---

            // --- Record Streaks Counter ---
            const recordStreaksContainer = document.getElementById('ai_record_streaks_container');
            if (recordStreaksContainer) {
                recordStreaksContainer.innerHTML = `
                    <div style="display: flex; justify-content: space-around; text-align: center; font-size: 0.8rem; color: #ccc;">
                        <div>
                            <div>Maior Win Streak</div>
                            <div style="font-size: 1.2rem; font-weight: bold; color: #00ff88; margin-top: 4px;">${ai_max_consecutive_wins}</div>
                        </div>
                        <div>
                            <div>Maior Loss Streak</div>
                            <div style="font-size: 1.2rem; font-weight: bold; color: #ff0055; margin-top: 4px;">${ai_max_consecutive_losses}</div>
                        </div>
                    </div>
                `;
            }

            // Renderiza o placar de 1h
            const winrateContainer = document.getElementById('ai_winrate_1h_container');
            if (winrateContainer) {
                const oneHourAgo = Date.now() - (60 * 60 * 1000);
                const recentResults = ai_results_history.filter(r => r.timestamp > oneHourAgo);

                const wins1h = recentResults.filter(r => r.result === 'win').length;
                const total1h = recentResults.length;
                const winRate1h = total1h > 0 ? (wins1h / total1h) * 100 : 0;

                const radius = 38;
                const circumference = 2 * Math.PI * radius;
                const offset = circumference - (winRate1h / 100) * circumference;

                let progressColor = '#00d2ff'; // default
                if (winRate1h >= 75) progressColor = '#00ff88'; // green
                else if (winRate1h < 50) progressColor = '#ff0055'; // red

                winrateContainer.innerHTML = `
                    <svg width="120" height="120" viewBox="0 0 100 100">
                        <circle class="winrate-circle-bg" cx="50" cy="50" r="${radius}"></circle>
                        <circle class="winrate-circle-progress" cx="50" cy="50" r="${radius}"
                            stroke-dasharray="${circumference}"
                            stroke-dashoffset="${offset}"
                            style="stroke: ${progressColor}; filter: drop-shadow(0 0 5px ${progressColor});">
                        </circle>
                        <text x="50" y="48" class="winrate-text" style="fill: ${progressColor};">${winRate1h.toFixed(0)}%</text>
                        <text x="50" y="65" class="winrate-subtext">${wins1h}W / ${total1h - wins1h}L</text>
                    </svg>
                `;
            }

            // Frequência por Minuto (0-9) - Design Futurista
            let barChartHtml = '';
            let radarChartHtml = '';
            let gaussChartHtml = '';
            if (fullHistory.length > 0) {
                const minuteStats = Array.from({ length: 10 }, () => ({ total: 0, vermelho: 0, preto: 0, branco: 0 }));
                // Analisa todo o histórico disponível para maior precisão estatística
                fullHistory.forEach(item => {
                    if (item.minuteDigit !== undefined && !isNaN(item.minuteDigit)) {
                        minuteStats[item.minuteDigit].total++;
                        if (item.color === 'vermelho') minuteStats[item.minuteDigit].vermelho++;
                        else if (item.color === 'preto') minuteStats[item.minuteDigit].preto++;
                        else if (item.color === 'branco') minuteStats[item.minuteDigit].branco++;
                    }
                });
                
                const maxCount = Math.max(...minuteStats.map(s => s.total)) || 1;
                let bars = '';
                
                for(let i=0; i<10; i++) {
                    const stats = minuteStats[i];
                    const heightPct = Math.max((stats.total / maxCount) * 100, 5); // Mínimo 5% para visualização
                    const isHot = (stats.total / maxCount) >= 0.85;
                    const borderStyle = isHot ? 'border: 1px solid rgba(0, 210, 255, 0.5); box-shadow: 0 0 5px rgba(0, 210, 255, 0.3);' : '';
                    const labelColor = isHot ? '#00d2ff' : '#888';

                    const pRed = stats.total > 0 ? (stats.vermelho / stats.total) * 100 : 0;
                    const pBlack = stats.total > 0 ? (stats.preto / stats.total) * 100 : 0;
                    const pWhite = stats.total > 0 ? (stats.branco / stats.total) * 100 : 0;

                    bars += `
                        <div style="flex: 1; display: flex; flex-direction: column; align-items: center; position: relative; z-index: 1;" onmouseover="this.querySelector('.tooltip').style.opacity=1; this.style.zIndex=10" onmouseout="this.querySelector('.tooltip').style.opacity=0; this.style.zIndex=1">
                            <div style="width: 100%; height: 100%; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 5px;">
                                <div style="width: 70%; height: ${heightPct}%; display: flex; flex-direction: column-reverse; background: rgba(255,255,255,0.05); border-radius: 3px 3px 0 0; overflow: hidden; transition: height 0.5s; ${borderStyle}">
                                    ${pRed > 0 ? `<div style="height: ${pRed}%; background: #ff0055;"></div>` : ''}
                                    ${pBlack > 0 ? `<div style="height: ${pBlack}%; background: #444;"></div>` : ''}
                                    ${pWhite > 0 ? `<div style="height: ${pWhite}%; background: #fff; box-shadow: 0 0 5px #fff; z-index: 2;"></div>` : ''}
                                </div>
                            </div>
                            <div style="font-size: 0.7rem; color: ${labelColor}; font-family: 'Courier New', monospace; font-weight: ${isHot ? 'bold' : 'normal'};">${i}</div>
                            <div class="tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.95); color: #fff; padding: 5px; border-radius: 4px; font-size: 0.65rem; opacity: 0; transition: opacity 0.2s; pointer-events: none; border: 1px solid #333; white-space: nowrap; text-align: left; line-height: 1.3; box-shadow: 0 5px 15px rgba(0,0,0,0.5);">
                                <div style="border-bottom: 1px solid #444; margin-bottom: 2px; padding-bottom: 2px; font-weight: bold; text-align: center;">Minuto ${i}</div>
                                <div>🔴 ${stats.vermelho} (${pRed.toFixed(0)}%)</div>
                                <div>⚫ ${stats.preto} (${pBlack.toFixed(0)}%)</div>
                                <div>⚪ ${stats.branco} (${pWhite.toFixed(0)}%)</div>
                                <div style="margin-top: 2px; color: #aaa; font-size: 0.6rem; text-align: center;">Total: ${stats.total}</div>
                            </div>
                        </div>
                    `;
                }

                barChartHtml = `
                <div style="margin-top: 15px; background: rgba(15, 20, 30, 0.6); padding: 15px; border-radius: 12px; border: 1px solid #333; position: relative; overflow: visible; box-shadow: 0 0 20px rgba(0,0,0,0.3);">
                    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 2px; background: linear-gradient(90deg, transparent, #00d2ff, transparent);"></div>
                    <h4 style="margin: 0 0 15px 0; font-size: 0.8rem; color: #ccc; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: space-between; align-items: center;">
                        <span>📊 Frequência por Minuto</span>
                        <span style="font-size: 0.65rem; color: #00d2ff; border: 1px solid rgba(0, 210, 255, 0.3); padding: 2px 6px; border-radius: 4px; background: rgba(0, 210, 255, 0.1);">0-9</span>
                    </h4>
                    <div style="display: flex; justify-content: space-between; height: 90px; gap: 4px;">
                        ${bars}
                    </div>
                </div>`;

                // --- Radar Chart (Spider) Generation ---
                const rMax = Math.max(...minuteStats.map(s => Math.max(s.vermelho, s.preto, s.branco))) || 1;
                const cx = 100, cy = 100, radius = 70;
                
                const getPoints = (type) => {
                    return minuteStats.map((s, i) => {
                        const val = s[type];
                        const angle = (i * 36 - 90) * (Math.PI / 180);
                        const r = (val / rMax) * radius;
                        const x = cx + r * Math.cos(angle);
                        const y = cy + r * Math.sin(angle);
                        return `${x},${y}`;
                    }).join(' ');
                };

                const ptsRed = getPoints('vermelho');
                const ptsBlack = getPoints('preto');
                const ptsWhite = getPoints('branco');

                // Grid (Teia) e Eixos
                let webHtml = '';
                let axesHtml = '';
                let labelsHtml = '';
                
                for(let level=1; level<=4; level++) {
                    const r = (radius / 4) * level;
                    const pts = Array.from({length: 10}, (_, i) => `${cx + r * Math.cos((i * 36 - 90) * Math.PI / 180)},${cy + r * Math.sin((i * 36 - 90) * Math.PI / 180)}`).join(' ');
                    webHtml += `<polygon points="${pts}" fill="none" stroke="#333" stroke-width="1" opacity="0.5" />`;
                }
                for(let i=0; i<10; i++) {
                    const angle = (i * 36 - 90) * (Math.PI / 180);
                    axesHtml += `<line x1="${cx}" y1="${cy}" x2="${cx + radius * Math.cos(angle)}" y2="${cy + radius * Math.sin(angle)}" stroke="#333" stroke-width="1" />`;
                    labelsHtml += `<text x="${cx + (radius + 15) * Math.cos(angle)}" y="${cy + (radius + 15) * Math.sin(angle)}" fill="#888" font-size="8" text-anchor="middle" dominant-baseline="middle" font-family="Courier New">${i}</text>`;
                }

                radarChartHtml = `
                <div style="margin-top: 15px; background: rgba(10, 15, 25, 0.6); padding: 15px; border-radius: 12px; border: 1px solid #333; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.3); display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 100%; display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center;">
                        <span style="font-size: 0.8rem; color: #ccc; text-transform: uppercase; font-weight: bold; letter-spacing: 1px;">🕸️ Radar (0-9)</span>
                        <div style="font-size: 0.6rem; display: flex; gap: 8px;"><span style="color:#ff0055">● Red</span><span style="color:#888">● Black</span><span style="color:#fff">● White</span></div>
                    </div>
                    <svg viewBox="0 0 200 200" style="width: 100%; max-width: 220px; overflow: visible;"><g>${webHtml}${axesHtml}</g><polygon points="${ptsBlack}" fill="rgba(100, 100, 100, 0.2)" stroke="#888" stroke-width="1.5" /><polygon points="${ptsRed}" fill="rgba(255, 0, 85, 0.2)" stroke="#ff0055" stroke-width="1.5" /><polygon points="${ptsWhite}" fill="rgba(255, 255, 255, 0.1)" stroke="#fff" stroke-width="1.5" stroke-dasharray="2,2" />${labelsHtml}</svg>
                </div>`;

                // --- Gaussian Chart (Desvio Padrão) ---
                if (fullHistory.length >= 20) {
                    const last20 = fullHistory.slice(0, 20).filter(x => x.color !== 'branco');
                    const redCount = last20.filter(x => x.color === 'vermelho').length;
                    const N = 20;
                    const mean = 10;
                    const stdDev = 2.236;
                    
                    // Soma dos últimos 5 (Sigma)
                    const sum5 = fullHistory.slice(0, 5).reduce((acc, curr) => acc + curr.roll, 0);

                    let sigmaColor = '#aaa';
                    let sigmaBorder = '#444';
                    
                    const width = 300, height = 60, padding = 10;
                    const plotWidth = width - 2 * padding;
                    const plotHeight = height - padding;
                    
                    let pathD = `M ${padding} ${height}`;
                    for (let i = 0; i <= plotWidth; i+=5) {
                        const xVal = (i / plotWidth) * N;
                        const z = (xVal - mean) / stdDev;
                        const yVal = Math.exp(-0.5 * z * z);
                        const plotX = padding + i;
                        const plotY = height - (yVal * (plotHeight - 5));
                        pathD += ` L ${plotX} ${plotY}`;
                    }
                    pathD += ` L ${width - padding} ${height} Z`;

                    const currentX = padding + (redCount / N) * plotWidth;
                    
                    // Rastro da rodada anterior (Visualização de Movimento)
                    let prevX = null;
                    if (fullHistory.length >= 21) {
                        const prev20 = fullHistory.slice(1, 21).filter(x => x.color !== 'branco');
                        const prevRedCount = prev20.filter(x => x.color === 'vermelho').length;
                        prevX = padding + (prevRedCount / N) * plotWidth;
                    }
                    
                    // Cálculo do Sigma (Z-Score) para Tooltip
                    const sigmaVal = (redCount - mean) / stdDev;
                    const sigmaText = (sigmaVal > 0 ? '+' : '') + sigmaVal.toFixed(2) + 'σ';

                    let statusColor = '#00d2ff', statusText = 'Equilibrado';
                    let animStyle = 'border: 1px solid #333;';
                    if (redCount >= 15) { statusColor = '#ff0055'; statusText = 'Excesso Vermelho (>2σ)'; animStyle = `border: 1px solid ${statusColor}; animation: pulse-gauss-red 1s infinite;`; }
                    else if (redCount <= 5) { statusColor = '#00ff88'; statusText = 'Escassez Vermelho (<-2σ)'; animStyle = `border: 1px solid ${statusColor}; animation: pulse-gauss-green 1s infinite;`; }

                    gaussChartHtml = `
                    <div style="margin-top: 15px; background: rgba(10, 15, 25, 0.6); padding: 10px; border-radius: 12px; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.3); ${animStyle}" onmouseover="this.querySelector('.gauss-tooltip').style.opacity=1" onmouseout="this.querySelector('.gauss-tooltip').style.opacity=0">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-size: 0.7rem; color: #ccc; text-transform: uppercase; font-weight: bold; letter-spacing: 1px;">📉 Desvio Padrão (20 Rodadas)</span>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <span style="font-size: 0.65rem; color: ${sigmaColor}; border: 1px solid ${sigmaBorder}; padding: 1px 5px; border-radius: 3px; font-family: 'Courier New', monospace;" title="Soma dos últimos 5 números">∑ ${sum5}</span>
                                <span style="font-size: 0.65rem; color: ${statusColor}; border: 1px solid ${statusColor}; padding: 1px 5px; border-radius: 3px;">${statusText}</span>
                            </div>
                        </div>
                        <svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: 60px; overflow: visible;">
                            <path d="${pathD}" fill="rgba(0, 210, 255, 0.1)" stroke="#00d2ff" stroke-width="1" />
                            <line x1="${width/2}" y1="0" x2="${width/2}" y2="${height}" stroke="#444" stroke-dasharray="3" stroke-width="1" />
                            ${prevX !== null ? `<line x1="${prevX}" y1="15" x2="${prevX}" y2="${height}" stroke="rgba(255,255,255,0.3)" stroke-dasharray="2,2" stroke-width="1" />` : ''}
                            <line x1="${currentX}" y1="10" x2="${currentX}" y2="${height}" stroke="${statusColor}" stroke-width="2" />
                            <circle cx="${currentX}" cy="10" r="4" fill="${statusColor}" stroke="#fff" stroke-width="1" class="chart-dot" />
                            <text x="${currentX}" y="0" fill="${statusColor}" font-size="8" text-anchor="middle" font-family="Courier New" font-weight="bold">${redCount}</text>
                        </svg>
                        <div style="display: flex; justify-content: space-between; font-size: 0.6rem; color: #666; margin-top: 2px;"><span>0 (Full Black)</span><span>10 (Média)</span><span>20 (Full Red)</span></div>
                        <div class="gauss-tooltip" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 0.85rem; opacity: 0; transition: opacity 0.2s; pointer-events: none; border: 1px solid ${statusColor}; box-shadow: 0 0 15px rgba(0,0,0,0.6); text-align: center; z-index: 10; backdrop-filter: blur(4px);">
                            <div style="font-weight: bold; color: ${statusColor}; font-family: 'Courier New', monospace; font-size: 1.1rem; margin-bottom: 2px;">${sigmaText}</div>
                            <div style="font-size: 0.7rem; color: #ccc;">Desvio Padrão (Z-Score)</div>
                        </div>
                    </div>`;
                }
            }

            const content = document.getElementById('ai_prediction_content');
            
            // Organização em Grid para melhor alinhamento
            const widgetsHtml = `
                <div class="widgets-grid">
                    <div class="widget-full">${chartHtml}</div>
                    <div class="widget-full">${trendHtml}</div>
                </div>
            `;

            let predictionBoxHtml = '';
            if (predictionClass === 'waiting') {
                const waitDuration = Math.max(1, (ai_waiting_until - Date.now()) / 1000);
                predictionBoxHtml = `
                    <div class="waiting-wrapper">
                        <div style="width: 60px; height: 60px; position: relative;">
                            <svg class="waiting-svg-ring" viewBox="0 0 60 60">
                                <circle class="waiting-circle-track" cx="30" cy="30" r="24"></circle>
                                <circle class="waiting-circle-progress" cx="30" cy="30" r="24" style="animation-duration: ${waitDuration}s"></circle>
                            </svg>
                        </div>
                        <div class="waiting-content" style="margin-top: 5px; display: flex; align-items: center; gap: 6px;">
                            <span>AGUARDANDO..</span>
                            <span id="ai_waiting_countdown" style="font-family: 'Courier New', monospace; background: rgba(255,255,255,0.1); padding: 1px 5px; border-radius: 4px; font-size: 0.9em; color: #fff;">${Math.ceil(waitDuration)}s</span>
                        </div>
                    </div>`;
            } else {
                predictionBoxHtml = `<div style="position: relative; display: inline-block;"><div class="prediction-color-box ${predictionClass}" style="${boxStyle}">${predictionDisplayText}</div>${gale1IndicatorHtml}</div>`;
            }

            content.innerHTML = aiVisualHtml + widgetsHtml + `<div class="prediction-display">${predictionBoxHtml}${virtualStatusHtml}${whiteHtml}<div class="confidence-label">CONFIANÇA DA PREVISÃO: <strong>${confidence.toFixed(0)}%</strong></div><div class="confidence-bar-container"><div class="confidence-bar" style="width: ${confidence.toFixed(0)}%;"></div></div></div><div class="prediction-reasoning"><h4 style="margin: 0 0 10px 0; color: #fff;">Raciocínio da I.A.:</h4><ul>${reasoning.map(r => `<li>${r}</li>`).join('')}</ul></div>` + gaussChartHtml + barChartHtml + radarChartHtml + tickerHtml + `<p style="font-size: 0.7rem; text-align: center; color: #888; margin-top: 15px;">*Esta é uma previsão estatística e não uma garantia de resultado.</p>`;

            // Countdown Logic
            if (predictionClass === 'waiting') {
                if (window.ai_countdown_interval) clearInterval(window.ai_countdown_interval);
                window.ai_countdown_interval = setInterval(() => {
                    const el = document.getElementById('ai_waiting_countdown');
                    if (el) {
                        const remaining = Math.max(0, Math.ceil((ai_waiting_until - Date.now()) / 1000));
                        el.innerText = remaining + 's';
                        if (remaining <= 0) clearInterval(window.ai_countdown_interval);
                    } else {
                        clearInterval(window.ai_countdown_interval);
                    }
                }, 1000);
            }
        }

        function ai_resetAIStats() {
            if (confirm("Você tem certeza que deseja resetar o placar da sessão E o histórico de 1 hora?")) {
                ai_wins = 0;
                ai_losses = 0;
                ai_balance_history = [0];
                ai_current_prediction = null;
                ai_virtual_stage = 0;
                ai_consecutive_wins = 0;
                ai_consecutive_losses = 0;
                ai_last_prediction_on_loss = null;
                ai_max_consecutive_wins = 0;
                ai_max_consecutive_losses = 0;
                
                // Reset 1h history
                ai_results_history = [];
                localStorage.removeItem('ai_results_history');
                localStorage.removeItem('ai_session_stats');

                ai_showAIPrediction();
            }
        }

        function ai_playWinSound() {
            if (!ai_sound_enabled) return;
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const t = ctx.currentTime;
                
                // Som de Vitória: Tríade Maior (C-E-G) - Mais musical e distinto
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.type = 'triangle'; // Timbre mais rico que sine
                    
                    const startTime = t + (i * 0.08);
                    osc.frequency.setValueAtTime(freq, startTime);
                    
                    gain.gain.setValueAtTime(0.05 * ai_volume, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);
                    
                    osc.start(startTime);
                    osc.stop(startTime + 0.4);
                });
            } catch (e) { console.error("Erro som win:", e); }
        }

        function ai_playLossSound() {
            if (!ai_sound_enabled) return;
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                
                osc.type = 'sawtooth'; 
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0.1 * ai_volume, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
                
                osc.start(); osc.stop(ctx.currentTime + 0.3);
            } catch (e) { console.error("Erro som loss:", e); }
        }

        // Inicialização
        const autoFetch = document.getElementById('ai_autoFetchToggle');
        if (autoFetch) {
            // Restaurar estado do Auto-Busca
            const savedAutoFetch = localStorage.getItem('ai_autoFetch');
            if (savedAutoFetch !== null) {
                autoFetch.checked = (savedAutoFetch === 'true');
            }

            // Restaurar visualmente os outros botões
            document.getElementById('ai_soundToggle').checked = ai_sound_enabled;
            document.getElementById('ai_virtualGaleToggle').checked = ai_use_virtual_gale;
            document.getElementById('ai_gale1Toggle').checked = ai_use_gale1;
            document.getElementById('ai_invertGaleToggle').checked = ai_invert_gale;
            document.getElementById('ai_conservativeToggle').checked = ai_conservative_mode;
            document.getElementById('ai_goldenHourToggle').checked = ai_golden_hour_mode;
            document.getElementById('ai_opcoesDoubleToggle').checked = ai_opcoes_double_mode;
            document.getElementById('ai_minute1to5Toggle').checked = ai_minute_1_5_mode;
            document.getElementById('ai_manualPauseToggle').checked = ai_manual_pause;
            document.getElementById('ai_antiChessToggle').checked = ai_anti_chess_mode;
            document.getElementById('ai_autoWaitLossToggle').checked = ai_auto_wait_loss;

            autoFetch.addEventListener('change', (e) => {
                localStorage.setItem('ai_autoFetch', e.target.checked);
                if (e.target.checked) { ai_fetchData(); ai_interval = setInterval(ai_fetchData, 15000); } 
                else { 
                    clearInterval(ai_interval); 
                    updateConnectionStatus('offline', 'Offline');
                }
            });

            // Restaurar Tempo de Espera salvo no input visual
            const waitTimeInput = document.getElementById('ai_waitTimeInput');
            if (waitTimeInput) waitTimeInput.value = ai_win_wait_time;

            // Restaurar Pedras Espera salvo no input visual
            const stonesWaitInput = document.getElementById('ai_stonesWaitInput');
            if (stonesWaitInput) stonesWaitInput.value = ai_stones_wait_setting;

            // Carrega o histórico de 1h
            const savedResults = localStorage.getItem('ai_results_history');
            if (savedResults) {
                try {
                    ai_results_history = JSON.parse(savedResults);
                } catch(e) { console.error("Erro ao carregar histórico de resultados."); }
            }

            // Renderiza o layout da página imediatamente com valores padrão
            ai_showAIPrediction();
            // Inicia a busca de dados
            if (autoFetch.checked) {
                ai_fetchData();
                ai_interval = setInterval(ai_fetchData, 15000);
            }
        }

        // --- FUNÇÕES AUXILIARES OPÇÕES DOUBLE (INTEGRAÇÃO) ---
        function ai_od_calculateEMA(data, period) {
            const emaArray = new Array(data.length).fill(null);
            if (data.length < period) return emaArray;
            const k = 2 / (period + 1);
            let sum = 0;
            for (let i = 0; i < period; i++) { if (data[i] && typeof data[i].close === 'number') sum += data[i].close; }
            emaArray[period - 1] = sum / period;
            for (let i = period; i < data.length; i++) {
                if (data[i] && typeof data[i].close === 'number' && emaArray[i - 1] !== null) {
                    emaArray[i] = (data[i].close * k) + (emaArray[i - 1] * (1 - k));
                }
            }
            return emaArray;
        }

        function ai_od_calculateSMA(data, period) {
            const smaData = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) { smaData.push(null); continue; }
                let sum = 0;
                for (let j = 0; j < period; j++) { sum += data[i - j].close; }
                smaData.push(sum / period);
            }
            return smaData;
        }

        function ai_od_calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const emaFast = ai_od_calculateEMA(data, fastPeriod);
            const emaSlow = ai_od_calculateEMA(data, slowPeriod);
            const macdLine = []; const histogram = [];
            for (let i = 0; i < data.length; i++) {
                if (emaFast[i] !== null && emaSlow[i] !== null) { macdLine.push(emaFast[i] - emaSlow[i]); } else { macdLine.push(null); }
            }
            const signalLine = ai_od_calculateEMA(macdLine.map(v => ({ close: v })), signalPeriod);
            for (let i = 0; i < data.length; i++) {
                if (macdLine[i] !== null && signalLine[i] !== null) { histogram.push(macdLine[i] - signalLine[i]); } else { histogram.push(null); }
            }
            return { macdLine, signalLine, histogram };
        }

        function ai_od_getTrendSignal(data) {
            if (data.length < 26) return { signal: "NEUTRO" };
            const smaData = ai_od_calculateSMA(data, 14);
            const lastSMA = smaData[smaData.length - 1];
            const lastClose = data[data.length - 1].close;
            const macdData = ai_od_calculateMACD(data, 12, 26, 9);
            const lastHist = macdData.histogram[macdData.histogram.length - 1];
            if (lastSMA !== null && lastHist !== null) {
                if (lastClose > lastSMA && lastHist > 0) return { signal: "VERMELHO" };
                if (lastClose < lastSMA && lastHist < 0) return { signal: "PRETO" };
            }
            return { signal: "NEUTRO" };
        }

        function ai_od_generateCandles(rawData) {
            const tokens = rawData.split(/[\s\n]+/).filter(n => n.trim() !== '');
            const games = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].includes('/') && !isNaN(parseInt(tokens[i + 1])) && tokens[i + 2].includes(':')) {
                    const dateParts = tokens[i].split('/');
                    const timeParts = tokens[i+2].split(':');
                    const date = new Date(dateParts[2], dateParts[1] - 1, dateParts[0], timeParts[0], timeParts[1]);
                    games.push({ roll: parseInt(tokens[i+1]), created_at: date.getTime() });
                    i += 2;
                }
            }
            games.sort((a, b) => a.created_at - b.created_at);
            let priceData = []; let lastClose = 100;
            games.forEach(game => {
                const open = lastClose; let high, low, close;
                const color = ai_identificarCor(game.roll);
                if (color === 'vermelho') { close = open + 10; high = close; low = open; } 
                else if (color === 'preto') { close = open - 10; high = open; low = close; } 
                else { close = open; high = open + 5; low = open - 5; }
                priceData.push({ open, high, low, close, color, roll: game.roll, timestamp: game.created_at, volume: 1 });
                lastClose = close;
            });
            return priceData;
        }

        function ai_renderConfidenceChartHTML() {
            const width = 500; // Largura fixa para consistência
            const height = 120;

            if (ai_confidence_history.length < 2) {
                return `<div class="confidence-chart-container"><h4 class="confidence-chart-title">Evolução da Confiança</h4><div style="height: ${height}px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 0.8rem; border: 1px dashed #444; border-radius: 4px;">Aguardando histórico...</div></div>`;
            }

            const data = ai_confidence_history;
            const padding = { top: 10, right: 30, bottom: 20, left: 30 };

            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            const getX = (index) => padding.left + (index / (data.length - 1)) * plotWidth;
            const getY = (confidence) => padding.top + plotHeight - (confidence / 100) * plotHeight;

            let pathD = '';
            let areaD = `M ${padding.left} ${height - padding.bottom}`;

            data.forEach((point, i) => {
                const x = getX(i);
                const y = getY(point.confidence);
                if (i === 0) {
                    pathD += `M ${x} ${y}`;
                } else {
                    pathD += ` L ${x} ${y}`;
                }
                areaD += ` L ${x} ${y}`;
            });
            areaD += ` L ${getX(data.length - 1)} ${height - padding.bottom} Z`;

            const lastPoint = data[data.length - 1];
            const lastColor = lastPoint.prediction.includes('VERMELHO') ? '#ff0055' : (lastPoint.prediction.includes('PRETO') ? '#ccc' : '#00d2ff');

            const gridLines = `
                <line class="confidence-chart-grid" x1="${padding.left}" y1="${getY(25)}" x2="${width - padding.right}" y2="${getY(25)}"></line>
                <line class="confidence-chart-grid" x1="${padding.left}" y1="${getY(50)}" x2="${width - padding.right}" y2="${getY(50)}"></line>
                <line class="confidence-chart-grid" x1="${padding.left}" y1="${getY(75)}" x2="${width - padding.right}" y2="${getY(75)}"></line>
            `;

            const axisLabels = `
                <text class="confidence-chart-axis-label" x="${width - padding.right + 4}" y="${getY(100) + 4}">100%</text>
                <text class="confidence-chart-axis-label" x="${width - padding.right + 4}" y="${getY(50) + 4}">50%</text>
                <text class="confidence-chart-axis-label" x="${width - padding.right + 4}" y="${getY(0) + 4}">0%</text>
                ${data.map((p, i) => `<text class="confidence-chart-axis-label" x="${getX(i)}" y="${height - 5}" text-anchor="middle">-${data.length - 1 - i}</text>`).join('')}
            `;

            const dots = data.map((point, i) => {
                let color = '#888'; // Default for 'Sinal Fraco' etc.
                if (point.prediction.includes('VERMELHO')) color = '#ff0055';
                else if (point.prediction.includes('PRETO')) color = '#ccc';
                else if (point.prediction.includes('BRANCO')) color = '#00d2ff';
                
                return `<circle class="confidence-chart-dot" cx="${getX(i)}" cy="${getY(point.confidence)}" r="4" fill="${color}"><title>Confiança: ${point.confidence.toFixed(0)}% em ${point.prediction}</title></circle>`;
            }).join('');

            return `<div class="confidence-chart-container"><h4 class="confidence-chart-title">Evolução da Confiança (Últimas ${data.length} Rodadas)</h4><svg class="confidence-chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">${gridLines}<path d="${areaD}" fill="${lastColor}" class="confidence-chart-area" /><path d="${pathD}" stroke="${lastColor}" class="confidence-chart-line" />${dots}${axisLabels}</svg></div>`;
        }
    </script>
</body>
</html>