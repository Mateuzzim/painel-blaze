<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Op√ß√µes Double - Gr√°fico</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic styles from other pages */
        :root {
            --bg-color: #0f0f13; --panel-bg: #1a1a1a; --text-color: #fff; --border-color: #333; --input-bg: #0f0f13;
            --accent: #00d2ff; --accent-blaze: #ff0055; --accent-jonbet: #00ff88; --text-muted: #888;
        }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 5px; }
        .main-container { max-width: 100%; margin: 0 auto; }
        .layout-panel { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .main-header { display: flex; justify-content: center; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
        h1 { margin: 0; }
        .cortex-text-anim { background: linear-gradient(90deg, #00d2ff, #ff0055, #ff9800, #00d2ff); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: cortex-gradient 3s linear infinite; font-weight: bold; }
        @keyframes cortex-gradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        .btn-back { display: inline-flex; align-items: center; gap: 5px; padding: 8px 15px; background: rgba(255,255,255,0.05); color: #aaa; text-decoration: none; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; border: 1px solid #333; transition: all 0.3s; }
        .btn-back:hover { background: rgba(0, 210, 255, 0.1); border-color: #00d2ff; color: #00d2ff; box-shadow: 0 0 10px rgba(0, 210, 255, 0.2); }
        
        /* Chart specific styles */
        #chart-container, #adx-container, #volume-container, #macd-container, #rsi-container {
            width: 100%;
            background-color: #0c1014; /* Darker blueish background */
            background-image: 
                linear-gradient(rgba(0, 210, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 210, 255, 0.05) 1px, transparent 1px);
            background-size: 25px 25px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.7);
            border-radius: 8px;
            border: 1px solid #333;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }
        #chart-container { height: 650px; }
        #adx-container { height: 150px; margin-top: 10px; display: none; }
        #volume-container {
            height: 100px;
            margin-top: 10px;
            display: none;
        }
        #macd-container { height: 150px; margin-top: 10px; display: none; }
        #rsi-container { height: 150px; margin-top: 10px; display: none; }
        #stoch-container { height: 150px; margin-top: 10px; display: none; }

        #chart-container svg, #rsi-container svg, #macd-container svg, #volume-container svg, #adx-container svg, #stoch-container svg {
            background-color: transparent; /* Make SVG background transparent to see the container's grid */
        }
        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 1.2rem;
        }
        .controls-panel {
            background: rgba(0,0,0,0.2);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            animation: card-pulse 4s infinite;
            flex-direction: column !important;
            align-items: stretch !important;
            padding: 0 !important;
            gap: 0 !important;
        }
        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .control-row:last-child { border-bottom: none; }
        
        @keyframes card-pulse {
            0% { border-color: rgba(255,255,255,0.05); box-shadow: 0 0 0 rgba(0,0,0,0); }
            50% { border-color: rgba(0, 210, 255, 0.3); box-shadow: 0 0 15px rgba(0, 210, 255, 0.1); }
            100% { border-color: rgba(255,255,255,0.05); box-shadow: 0 0 0 rgba(0,0,0,0); }
        }

        .draw-mode-btn {
            background: rgba(0, 210, 255, 0.05) !important;
            border: 1px solid rgba(0, 210, 255, 0.2) !important;
            color: #00d2ff !important;
            padding: 10px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 5px rgba(0, 210, 255, 0.1);
        }
        .draw-mode-btn:hover {
            background: rgba(0, 210, 255, 0.2) !important;
            color: #fff !important;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.4);
            border-color: #00d2ff !important;
            transform: translateY(-2px) scale(1.02);
        }
        .draw-mode-btn:active { transform: translateY(0) scale(0.98); }
        .draw-mode-btn.active {
            background: #00d2ff !important;
            color: #000 !important;
            border-color: #00d2ff !important;
            box-shadow: 0 0 25px rgba(0, 210, 255, 0.5);
        }

        .tool-group {
            display: flex; align-items: center; gap: 8px;
            background: rgba(255,255,255,0.03);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
        }
        .tool-group:hover {
            border-color: rgba(0, 210, 255, 0.3);
            background: rgba(0, 210, 255, 0.05);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.1);
        }
        .tool-group span { font-size: 0.8rem; color: #aaa; font-weight: bold; text-transform: uppercase; }
        .tool-group input[type="number"] {
            background: rgba(0,0,0,0.3) !important;
            border: 1px solid rgba(255,255,255,0.2) !important;
            color: #fff !important;
            border-radius: 4px !important;
            padding: 4px !important;
            text-align: center;
        }
        
        #timeframeSelect {
            background: rgba(0, 210, 255, 0.05) !important;
            border: 1px solid rgba(0, 210, 255, 0.2) !important;
            color: #00d2ff !important;
            border-radius: 20px !important;
            padding: 8px 15px !important;
            font-weight: bold;
            cursor: pointer;
        }
        #timeframeSelect:hover { background: rgba(0, 210, 255, 0.1) !important; }

        .current-price-line {
            animation: pulse-line 1.5s infinite alternate;
        }
        .indicator-line {
            filter: url(#glow);
        }
        .candle-wick {
            stroke-linecap: round;
        }

        @keyframes pulse-line { from { opacity: 0.4; } to { opacity: 0.9; } }
        .bb-alert-marker { animation: pulse-alert 1s infinite; }
        @keyframes pulse-alert {
            0% { r: 2.5; opacity: 1; stroke-width: 0.5; }
            50% { r: 5; opacity: 0.8; stroke-width: 2; }
            100% { r: 2.5; opacity: 1; stroke-width: 0.5; }
        }

        .chart-tooltip {
            position: fixed;
            background: rgba(10, 15, 25, 0.95);
            border: 1px solid #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 9999;
            display: none;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        /* Market Strength Widget */
        #widgets-wrapper {
            position: absolute; top: 20px; left: 20px; z-index: 20;
            display: flex; flex-direction: column; gap: 15px;
            pointer-events: none;
        }
        .market-strength-widget {
            position: relative;
            top: auto;
            left: auto;
            pointer-events: auto;
            width: 70px;
            padding: 10px;
            background: rgba(12, 16, 20, 0.85);
            border: 1px solid #333;
            border-radius: 8px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: border-color 0.5s, box-shadow 0.5s;
        }
        .market-strength-widget::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, transparent, rgba(255,255,255,0.05), transparent);
            pointer-events: none; animation: scan-strength 3s infinite linear;
        }
        @keyframes scan-strength { 0% { transform: translateY(-100%); } 100% { transform: translateY(100%); } }
        .strength-title { font-size: 0.6rem; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; text-align: center; font-weight: bold; }
        .strength-meter-bg { width: 8px; height: 100px; background: #222; border-radius: 4px; position: relative; overflow: hidden; border: 1px solid #444; }
        .strength-meter-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; background: #555;
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.5s;
            border-radius: 4px; box-shadow: 0 0 10px currentColor;
        }
        .strength-value { font-size: 1.1rem; font-weight: 900; margin-top: 8px; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 5px currentColor; }
        .strength-trend-icon { font-size: 1.2rem; margin-top: 2px; }

        /* Trend History Panel */
        #trend-history-panel {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 200px;
            background: rgba(12, 16, 20, 0.5);
            border: 1px solid rgba(0, 210, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            z-index: 90;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.1);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }
        .history-title { font-size: 0.8rem; color: #00d2ff; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 5px rgba(0, 210, 255, 0.5); }
        .history-list { list-style: none; padding: 0; margin: 0; overflow: hidden; }
        .history-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 0.75rem; animation: slideInRight 0.4s ease-out;
        }
        .history-time { color: #888; font-family: monospace; }
        .history-signal { font-weight: bold; display: flex; align-items: center; gap: 5px; }
        @keyframes slideInRight { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }

        @media (max-width: 768px) {
            body { padding: 0; overflow-x: hidden; } /* Remove padding extra e evita scroll horizontal */
            .main-container { width: 100%; padding: 0; margin: 0; }
            .layout-panel { padding: 5px; border-radius: 0; border: none; box-shadow: none !important; } /* Full width e remove sombras pesadas */
            
            /* Altura din√¢mica para caber na tela do celular */
            #chart-container { height: 50vh; min-height: 350px; border-left: none; border-right: none; border-radius: 0; }
            
            #adx-container, #macd-container, #rsi-container, #stoch-container { height: 100px; border-radius: 0; }
            #volume-container { height: 60px; border-radius: 0; }
            
            .controls-panel { padding: 5px; gap: 8px; margin-top: 10px; background: transparent; border: none; }
            .control-row { padding: 5px 0; gap: 6px; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.05); }
            .control-row > * { flex: 1 1 auto; margin: 2px; } /* Melhor distribui√ß√£o dos bot√µes */
            
            .draw-mode-btn { padding: 8px 10px; font-size: 0.75rem; width: auto; min-width: 80px; justify-content: center; }
            .tool-group { padding: 6px 10px; justify-content: center; flex-wrap: wrap; }
            
            h1 { font-size: 1.2rem; }
            .btn-back { width: 100%; justify-content: center; box-sizing: border-box; margin-bottom: 10px; }
            .chart-tooltip { display: none !important; } /* Desativa tooltip no touch para n√£o atrapalhar a vis√£o */
            #trend-history-panel { display: none; } /* Hide on mobile to save space */

            /* Responsive Widgets */
            #widgets-wrapper {
                flex-direction: row;
                top: 10px; left: 0; width: 100%;
                justify-content: center; gap: 8px;
            }
            .market-strength-widget { width: 55px; padding: 5px; box-shadow: none !important; background: rgba(12, 16, 20, 0.95); }
            .strength-meter-bg { height: 50px; }
            
            /* Ajustes nos Cards de An√°lise */
            .analysis-card { padding: 8px; min-height: 70px; box-shadow: none !important; border: 1px solid rgba(255,255,255,0.1); }
            .analysis-title { font-size: 0.6rem; }
            .analysis-value { font-size: 0.9rem; }
        }

        /* Light Mode Styles */
        body.light-mode #chart-container, body.light-mode #adx-container, body.light-mode #volume-container, 
        body.light-mode #macd-container, body.light-mode #rsi-container, body.light-mode #stoch-container {
            background-color: #ffffff;
            background-image: linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.02); border-color: #ddd;
        }
        body.light-mode .loading-text { color: #333; }

        /* Analysis Panel Styles (Nova Aba) */
        #analysis-panel {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .analysis-card {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: border-color 0.3s;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, var(--panel-bg) 0%, rgba(20,20,25,0.95) 100%);
        }
        /* Garante que o texto fique sobre o efeito de fundo */
        .analysis-card > * {
            position: relative;
            z-index: 1;
        }
        /* Efeito Scanline no Fundo do Card */
        .analysis-card::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 0;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            opacity: 0.3;
        }
        /* Anima√ß√£o de Glitch para atualiza√ß√µes de valor */
        @keyframes text-glitch {
            0% { transform: translate(0); opacity: 1; text-shadow: none; }
            20% { transform: translate(-2px, 2px); opacity: 0.8; text-shadow: 2px 0 #ff0055; }
            40% { transform: translate(-2px, -2px); opacity: 0.9; text-shadow: -2px 0 #00d2ff; }
            60% { transform: translate(2px, 2px); opacity: 0.8; text-shadow: 2px 0 #ff0055; }
            80% { transform: translate(2px, -2px); opacity: 0.9; text-shadow: -2px 0 #00d2ff; }
            100% { transform: translate(0); opacity: 1; text-shadow: none; }
        }
        .value-update-anim {
            animation: text-glitch 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
        }
        .analysis-title {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            font-weight: bold;
            text-align: center;
        }
        .analysis-value {
            font-size: 1rem;
            font-weight: bold;
            color: var(--text-color);
            font-family: 'Orbitron', sans-serif;
        }
        .wl-counter {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 6px;
            font-family: monospace;
            background: rgba(0,0,0,0.2);
            padding: 2px 5px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-family: 'Orbitron', sans-serif;
        }
        @keyframes flash-win {
            0% { background-color: rgba(0, 255, 136, 0.7); box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); border-color: rgba(0, 255, 136, 0.8); color: #fff; }
            100% { background-color: rgba(0,0,0,0.2); box-shadow: none; border-color: var(--border-color); color: var(--text-muted); }
        }
        .flash-win-anim {
            animation: flash-win 0.8s ease-out;
        }

        @keyframes flash-loss {
            0% { background-color: rgba(255, 0, 85, 0.7); box-shadow: 0 0 10px rgba(255, 0, 85, 0.5); border-color: rgba(255, 0, 85, 0.8); color: #fff; }
            100% { background-color: rgba(0,0,0,0.2); box-shadow: none; border-color: var(--border-color); color: var(--text-muted); }
        }
        .flash-loss-anim {
            animation: flash-loss 0.8s ease-out;
        }
        .meter-horizontal {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin-bottom: 5px;
            overflow: hidden;
        }
        /* History Grid for Telegram Scoreboard */
        .history-grid-container {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        .history-grid-header {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        #telegram-history-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 140px; /* 3 rows approx */
            overflow-y: auto;
            align-content: flex-start;
        }
        .history-badge {
            width: 45px;
            height: 45px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1.2rem;
            position: relative;
            background: #0f0f13;
            border: 1px solid #333;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.7);
            color: #fff;
        }
        .history-badge .badge-time {
            font-family: 'Segoe UI', sans-serif;
            font-size: 0.6rem;
            color: #888;
            font-weight: normal;
            margin-top: 2px;
        }
        .history-badge.vermelho { border-color: #ff0055; color: #ff0055; }
        .history-badge.preto { border-color: #555; color: #aaa; }
        .history-badge.branco { border-color: #fff; color: #000; background: #fff; text-shadow: 0 0 5px #000; }
        @keyframes slideInBadge {
            0% { opacity: 0; transform: translateX(-30px); }
            100% { opacity: 1; transform: translateX(0); }
        }
        @keyframes intenseGlow {
            0% { box-shadow: inset 0 0 8px rgba(0,0,0,0.7), 0 0 10px 2px #fff; }
            50% { box-shadow: inset 0 0 8px rgba(0,0,0,0.7), 0 0 25px 8px #fff; }
            100% { box-shadow: inset 0 0 8px rgba(0,0,0,0.7); }
        }
        .slide-in-anim {
            animation: slideInBadge 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), intenseGlow 1.5s ease-out;
        }
        .meter-horizontal {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin-bottom: 5px;
            overflow: hidden;
        }
        .meter-fill-horizontal {
            height: 100%;
            background: #555;
            width: 0%;
            transition: width 0.5s ease, background-color 0.5s;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        /* Brilho passando na barra (Scanner) */
        .meter-fill-horizontal::after {
            content: ''; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transform: translateX(-100%);
            animation: meter-scan 2s infinite linear;
        }
        @keyframes meter-scan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }
        /* Barra de Progresso Futurista (Warmup) */
        .warmup-bar-container {
            width: 70%;
            height: 4px;
            background: rgba(0, 210, 255, 0.1);
            border: 1px solid rgba(0, 210, 255, 0.2);
            border-radius: 4px;
            margin-top: 5px;
            display: none;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 5px rgba(0, 210, 255, 0.1);
        }
        .warmup-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d2ff, #00ff88);
            width: 0%;
            transition: width 0.2s linear;
            position: relative;
            box-shadow: 0 0 8px #00d2ff;
        }
        .warmup-bar-fill::after { content: ''; position: absolute; top: 0; left: 0; bottom: 0; right: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.9), transparent); transform: translateX(-100%); animation: warmup-scan 1s infinite linear; }
        @keyframes warmup-scan { 0% { transform: translateX(-100%); } 100% { transform: translateX(200%); } }

        @media (max-width: 1200px) {
            #analysis-panel {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        @media (max-width: 768px) {
            #analysis-panel {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 480px) {
            #analysis-panel {
                grid-template-columns: 1fr;
            }
        }

        /* Alerta Visual de Branco (Borda Piscante) */
        @keyframes white-alert-pulse {
            0% { box-shadow: inset 0 0 0 0 rgba(255, 255, 255, 0); border-color: transparent; }
            50% { box-shadow: inset 0 0 80px 20px rgba(255, 255, 255, 0.4); border-color: rgba(255, 255, 255, 0.6); }
            100% { box-shadow: inset 0 0 0 0 rgba(255, 255, 255, 0); border-color: transparent; }
        }
        .white-alert-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10000;
            border: 0px solid transparent;
            box-sizing: border-box;
            transition: all 0.3s;
        }
        .white-alert-active {
            animation: white-alert-pulse 1s infinite ease-in-out;
            border-width: 8px;
        }

        /* Anima√ß√£o para Linhas de Suporte/Resist√™ncia */
        .sr-alert-blink { animation: blink-sr 0.8s infinite alternate; }
        @keyframes blink-sr { from { opacity: 1; stroke-width: 1px; } to { opacity: 0.3; stroke-width: 3px; } }

        /* --- Scrollbar Futurista Aprimorada --- */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(10, 10, 15, 0.5);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, rgba(0, 210, 255, 0.5), rgba(161, 0, 255, 0.5));
            border-radius: 10px;
            border: 1px solid rgba(0, 210, 255, 0.2);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, var(--accent), var(--accent-blaze));
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
        }
        ::-webkit-scrollbar-corner {
            background: transparent;
        }

        /* News Panel Styles */
        .news-panel {
            background: linear-gradient(90deg, rgba(20,20,25,0.95) 0%, rgba(30,30,35,0.95) 100%);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 15px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .news-panel::before {
            content: ''; position: absolute; top: 0; left: 0; width: 4px; height: 100%;
            background: var(--accent); box-shadow: 0 0 10px var(--accent);
        }
        .news-label {
            font-family: 'Orbitron', sans-serif; font-size: 0.75rem; font-weight: bold;
            color: var(--accent); text-transform: uppercase; letter-spacing: 1px;
            white-space: nowrap; animation: blink-label 2s infinite;
        }
        @keyframes blink-label { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .news-text {
            font-family: 'Segoe UI', sans-serif; font-size: 0.9rem; color: #ddd;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1;
        }

        /* Focus Mode Styles */
        body.focus-mode .btn-back,
        body.focus-mode .main-header,
        body.focus-mode #analysis-panel,
        body.focus-mode .history-grid-container,
        body.focus-mode .controls-panel,
        body.focus-mode #adx-container,
        body.focus-mode #volume-container,
        body.focus-mode #macd-container,
        body.focus-mode #rsi-container,
        body.focus-mode #stoch-container {
            display: none !important;
        }
        body.focus-mode #chart-container { height: 92vh; border: none; }
        body.focus-mode .layout-panel { border: none; background: transparent; box-shadow: none; padding: 0; }
    </style>
</head>
<body>
    <div id="white-alert-overlay" class="white-alert-overlay"></div>
    <div class="main-container">
        <div class="layout-panel">
            <a href="index.html" class="btn-back" style="display: none;">‚¨Ö Voltar ao Menu</a>
            <div class="main-header" style="display: none;">
                <h1 class="cortex-text-anim">OP√á√ïES DOUBLE</h1>
            </div>
            <div id="chart-container">
                <button id="focus-btn" onclick="toggleFocusMode()" style="position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 1rem; transition: all 0.3s;" title="Modo Foco (Ocultar Ferramentas)">üëÅÔ∏è</button>
                <div class="loading-text">Carregando dados do gr√°fico...</div>
                <!-- Painel Lateral de Hist√≥rico -->
                <div id="trend-history-panel" style="display: none;">
                    <div class="history-header"><span class="history-title">Hist√≥rico</span><span style="font-size:0.8rem">‚è≥</span></div>
                    <ul id="history-list" class="history-list">
                        <li style="text-align: center; color: #555; padding: 10px; font-size: 0.7rem;">Aguardando sinais...</li>
                    </ul>
                </div>
                <!-- Painel OHLC -->
                <div id="ohlc-display" style="position: absolute; top: 10px; left: 60px; z-index: 15; font-family: 'Orbitron', sans-serif; font-size: 0.7rem; color: #888; pointer-events: none; display: none; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(2px);">
                    O: <span id="ohlc-open" style="color: #fff; margin-right: 8px;">-</span>
                    H: <span id="ohlc-high" style="color: #fff; margin-right: 8px;">-</span>
                    L: <span id="ohlc-low" style="color: #fff; margin-right: 8px;">-</span>
                    C: <span id="ohlc-close" style="color: #fff;">-</span>
                </div>
            </div>
            <!-- Nova Aba de An√°lise (For√ßa, Tend√™ncia, Volatilidade) -->
            <div id="analysis-panel">
                <div class="analysis-card">
                    <div class="analysis-title">FOR√áA DO MERCADO</div>
                    <div class="meter-horizontal"><div id="panel-strength-fill" class="meter-fill-horizontal"></div></div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="panel-strength-val" class="analysis-value">0%</span>
                        <span id="panel-strength-icon" style="font-size: 1.5rem;">‚ûñ</span>
                    </div>
                </div>
                <div class="analysis-card" id="panel-trend-card">
                    <div class="analysis-title">TEND√äNCIA ATUAL</div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <span id="panel-trend-val" class="analysis-value" style="margin-bottom: 5px;">NEUTRO</span>
                        <span id="panel-trend-icon" style="font-size: 2rem;">‚öñÔ∏è</span>
                    </div>
                </div>
                <div class="analysis-card">
                    <div class="analysis-title">VOLATILIDADE BRANCO</div>
                    <div class="meter-horizontal"><div id="panel-volatility-fill" class="meter-fill-horizontal"></div></div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="panel-volatility-val" class="analysis-value">0%</span>
                        <span id="panel-volatility-icon" style="font-size: 1.5rem;">„Ä∞Ô∏è</span>
                    </div>
                    <div id="warmup-bar-container" class="warmup-bar-container">
                        <div id="warmup-bar-fill" class="warmup-bar-fill"></div>
                    </div>
                    <div id="last-white-counter" style="font-size: 0.7rem; color: var(--text-muted); margin-top: 8px;">Velas s/ Branco: N/A</div>
                    <div id="wl-counter-white" class="wl-counter"><span style="color: #00ff88">W</span>: 0 - <span style="color: #ff0055">L</span>: 0</div>
                </div>
                <div class="analysis-card">
                    <div class="analysis-title">VOLATILIDADE VERMELHO</div>
                    <div class="meter-horizontal"><div id="panel-volatility-red-fill" class="meter-fill-horizontal"></div></div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="panel-volatility-red-val" class="analysis-value">0%</span>
                        <span id="panel-volatility-red-icon" style="font-size: 1.5rem;">„Ä∞Ô∏è</span>
                    </div>
                    <div id="last-red-counter" style="font-size: 0.7rem; color: var(--text-muted); margin-top: 8px;">Seq. s/ Vermelho: 0</div>
                    <div id="wl-counter-red" class="wl-counter"><span style="color: #00ff88">W</span>: 0 - <span style="color: #ff0055">L</span>: 0</div>
                </div>
                <div class="analysis-card">
                    <div class="analysis-title">VOLATILIDADE PRETO</div>
                    <div class="meter-horizontal"><div id="panel-volatility-black-fill" class="meter-fill-horizontal"></div></div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="panel-volatility-black-val" class="analysis-value">0%</span>
                        <span id="panel-volatility-black-icon" style="font-size: 1.5rem;">„Ä∞Ô∏è</span>
                    </div>
                    <div id="last-black-counter" style="font-size: 0.7rem; color: var(--text-muted); margin-top: 8px;">Seq. s/ Preto: 0</div>
                    <div id="wl-counter-black" class="wl-counter"><span style="color: #00ff88">W</span>: 0 - <span style="color: #ff0055">L</span>: 0</div>
                </div>
                <div class="analysis-card" id="panel-surf-card">
                    <div class="analysis-title">PROBABILIDADE</div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <span id="panel-surf-val" class="analysis-value" style="margin-bottom: 5px;">--</span>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span id="panel-surf-icon" style="font-size: 1.5rem;">‚è≥</span>
                            <span id="panel-surf-pct" style="font-size: 0.9rem; color: #888;">0%</span>
                        </div>
                    </div>
                    <div id="surf-message" style="font-size: 0.7rem; color: var(--text-muted); margin-top: 8px; text-align: center;">Aguardando dados...</div>
                    <div id="wl-counter-surf" class="wl-counter"><span style="color: #00ff88">W</span>: 0 - <span style="color: #ff0055">L</span>: 0 <span style="color: #fff; margin-left: 4px;">‚ö™: 0</span></div>
                </div>
            </div>
            <div class="history-grid-container">
                <div class="history-grid-header">Hist√≥rico de Resultados</div>
                <div id="telegram-history-grid">
                    <!-- Badges will be inserted here by JS -->
                </div>
            </div>
            <div id="adx-container"></div>
            <div id="volume-container"></div>
            <div id="macd-container"></div>
            <div id="rsi-container"></div>
            <div id="stoch-container"></div>
            <div class="controls-panel">
                <div class="control-row">
                    <select id="timeframeSelect" onchange="updateChart()">
                        <option value="tick">Tick</option>
                        <option value="1">1 Min</option>
                        <option value="5">5 Min</option>
                    </select>
                    <button id="haToggleBtn" class="draw-mode-btn" onclick="toggleHeikinAshi()" title="Suavizar Tend√™ncia">üïØÔ∏è Heikin Ashi</button>
                    <button id="themeToggleBtn" class="draw-mode-btn" onclick="toggleTheme()">‚òÄÔ∏è Tema</button>
                    <button id="autoTgBtn" class="draw-mode-btn" onclick="toggleAutoTg()" style="border-color: #555; color: #888; background: rgba(255,255,255,0.05);">ü§ñ Auto TG: OFF</button>
                    <div class="tool-group" style="border-color: #00d2ff;" title="Configura√ß√£o de Probabilidade Auto TG">
                        <span style="font-size: 0.8rem; color: #00d2ff; font-weight: bold;">Prob:</span>
                        <input type="number" id="autoTelegramMinProbability" value="75" min="50" max="99" step="1" onchange="saveAutoTgConfig()" style="width: 40px;" title="Probabilidade M√≠nima para Envio (%)">
                        <span style="font-size: 0.7rem; color: #aaa;">-</span>
                        <input type="number" id="autoTelegramMaxProbability" value="95" min="50" max="99" step="1" onchange="saveAutoTgConfig()" style="width: 40px;" title="Probabilidade M√°xima para Envio (%)">
                        <span style="font-size: 0.7rem; color: #00d2ff;">%</span>
                    </div>
                    <div class="tool-group" style="border-color: #00d2ff;" title="Minutos para Entrada (Delay)">
                        <span style="font-size: 0.8rem; color: #00d2ff; font-weight: bold;">Min:</span>
                        <input type="number" id="autoTelegramEntryMinute" value="1" min="1" max="5" step="1" onchange="saveAutoTgConfig()" style="width: 35px;" title="Minutos √† frente para entrada">
                    </div>
                    <button id="resetTgBtn" class="draw-mode-btn" onclick="resetTelegramScores()">üîÑ Zerar Placar</button>
                </div>

                <div class="control-row">
                    <button id="drawModeBtn" class="draw-mode-btn" onclick="toggleDrawMode(this)">‚úèÔ∏è Desenhar</button>
                    <input type="color" id="drawingColorPicker" value="#00d2ff" title="Cor do Desenho" style="background: #222; border: 1px solid #444; border-radius: 4px; cursor: pointer; height: 35px; padding: 2px;">
                    <div class="tool-group">
                        <span style="font-size: 0.8rem; color: #fff;">üîç Zoom</span>
                        <button onclick="zoomIn()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; padding: 2px 8px; cursor: pointer;" title="Aumentar Zoom">+</button>
                        <button onclick="resetZoom()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; padding: 2px 8px; cursor: pointer;" title="Resetar Zoom">R</button>
                        <button onclick="zoomOut()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; padding: 2px 8px; cursor: pointer;" title="Diminuir Zoom">-</button>
                    </div>
                    <button id="resetViewBtn" class="draw-mode-btn" onclick="resetView()">üîÑ Resetar Posi√ß√£o</button>
                    <button id="fullscreenBtn" class="draw-mode-btn" onclick="toggleFullscreen()">üñºÔ∏è Tela Cheia</button>
                    <button id="clearDrawingsBtn" class="draw-mode-btn" onclick="clearDrawings()">üóëÔ∏è Limpar</button>
                </div>

                <div class="control-row">
                    <div class="tool-group">
                        <input type="checkbox" id="autoFetchToggle" checked title="Atualiza√ß√£o Autom√°tica">
                        <span style="font-size: 0.8rem; color: #fff;">Auto</span>
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="soundToggle" checked title="Ativar Alertas Sonoros">
                        <span style="font-size: 0.8rem; color: #fff;">üîä</span>
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="historyToggle" onchange="toggleHistory()" title="Mostrar/Ocultar Hist√≥rico">
                        <span style="font-size: 0.8rem; color: #fff;">Hist√≥rico</span>
                    </div>
                    <div class="tool-group">
                        <span style="font-size: 0.8rem; color: #fff;">Calibra√ß√£o (s)</span>
                        <input type="number" id="warmupInput" value="30" min="0" max="600" step="30" onchange="saveWarmupConfig(); updateChart()" style="width: 45px;" title="Tempo de Aquecimento (0 para desativar)">
                    </div>
                    <div class="tool-group">
                        <span style="font-size: 0.8rem; color: #fff;">Velas:</span>
                        <input type="color" id="candleUpColor" value="#ff0055" title="Cor de Alta" onchange="updateChart()" style="width: 25px; height: 25px; padding: 0; border: none; background: none; cursor: pointer;">
                        <input type="color" id="candleDownColor" value="#343a40" title="Cor de Baixa" onchange="updateChart()" style="width: 25px; height: 25px; padding: 0; border: none; background: none; cursor: pointer;">
                    </div>
                    <div class="tool-group">
                        <input type="number" id="volatilityLookback" value="50" min="10" max="200" step="10" onchange="updateChart()" style="width: 40px;" title="Sensibilidade (Per√≠odo de An√°lise)">
                        <input type="number" id="volatilityWhiteThreshold" value="80" min="50" max="99" step="1" onchange="updateChart()" style="width: 35px;" title="Limiar Alerta Branco (%)">
                        <input type="number" id="whiteGaleAttempts" value="6" min="1" max="15" step="1" onchange="saveWhiteGaleConfig(); updateChart()" style="width: 35px;" title="Tentativas Gale Branco">
                    </div>
                </div>

                <div class="control-row">
                    <div class="tool-group">
                        <input type="checkbox" id="smaToggle" checked onchange="updateChart()" title="Ativar SMA">
                        <span style="font-size: 0.8rem; color: #fff;">SMA</span>
                        <input type="number" id="smaPeriodInput" value="14" min="2" max="200" onchange="updateChart()" style="width: 50px;">
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="emaToggle" onchange="updateChart()" title="Ativar EMA">
                        <span style="font-size: 0.8rem; color: #fff;">EMA</span>
                        <input type="number" id="emaPeriodInput" value="9" min="2" max="200" onchange="updateChart()" style="width: 50px;">
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="bbToggle" onchange="updateChart()" title="Ativar Bandas de Bollinger">
                        <span style="font-size: 0.8rem; color: #fff;">BB</span>
                        <input type="number" id="bbPeriodInput" value="20" min="2" max="50" onchange="updateChart()" style="width: 40px;" title="Per√≠odo">
                        <input type="number" id="bbStdDevInput" value="2" min="1" max="5" step="0.1" onchange="updateChart()" style="width: 30px;" title="Desvio Padr√£o">
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="srToggle" checked onchange="updateChart()" title="Ativar Suporte e Resist√™ncia">
                        <span style="font-size: 0.8rem; color: #fff;">Sup/Res</span>
                        <input type="number" id="srLookbackInput" value="200" min="50" max="500" step="10" onchange="updateChart()" style="width: 45px;" title="Per√≠odo de An√°lise">
                        <input type="number" id="srLinesInput" value="3" min="1" max="10" onchange="updateChart()" style="width: 30px;" title="M√°ximo de Linhas">
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="trendLineToggle" checked onchange="updateChart()" title="Ativar Linhas de Tend√™ncia">
                        <span style="font-size: 0.8rem; color: #fff;">L. Tend.</span>
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="fractalsToggle" checked onchange="updateChart()" title="Ativar Fractais">
                        <span style="font-size: 0.8rem; color: #fff;">Fractais</span>
                    </div>
                </div>

                <div class="control-row">
                    <div class="tool-group">
                        <input type="checkbox" id="volumeToggle" onchange="updateChart()" title="Ativar Volume">
                        <span style="font-size: 0.8rem; color: #fff;">VOL</span>
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="adxToggle" onchange="updateChart()" title="Ativar ADX">
                        <span style="font-size: 0.8rem; color: #fff;">ADX</span>
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="rsiToggle" onchange="updateChart()" title="Ativar RSI (√çndice de For√ßa Relativa)">
                        <span style="font-size: 0.8rem; color: #fff;">RSI</span>
                        <input type="number" id="rsiPeriodInput" value="14" min="2" max="100" onchange="updateChart()" style="width: 40px;" title="Per√≠odo">
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="macdToggle" onchange="updateChart()" title="Ativar MACD">
                        <span style="font-size: 0.8rem; color: #fff;">MACD</span>
                        <input type="number" id="macdFastInput" value="12" min="2" max="50" onchange="updateChart()" style="width: 35px;" title="R√°pida">
                        <input type="number" id="macdSlowInput" value="26" min="2" max="100" onchange="updateChart()" style="width: 35px;" title="Lenta">
                        <input type="number" id="macdSignalInput" value="9" min="2" max="50" onchange="updateChart()" style="width: 30px;" title="Sinal">
                    </div>
                    <div class="tool-group">
                        <input type="checkbox" id="stochToggle" onchange="updateChart()" title="Ativar Estoc√°stico">
                        <span style="font-size: 0.8rem; color: #fff;">Stoch</span>
                        <input type="number" id="stochKInput" value="14" min="2" max="100" onchange="updateChart()" style="width: 35px;" title="%K">
                        <input type="number" id="stochDInput" value="3" min="1" max="50" onchange="updateChart()" style="width: 30px;" title="%D">
                        <input type="number" id="stochSmoothInput" value="3" min="1" max="50" onchange="updateChart()" style="width: 30px;" title="Smooth">
                    </div>
                </div>
            </div>
            <div id="chart-tooltip" class="chart-tooltip"></div>
        </div>
    </div>

    <script>
        let globalGamesData = [];
        let isDrawMode = false;
        let isDrawing = false;
        let startPoint = null;
        let currentLine = null;
        let drawnLines = [];
        let allCandles = [];
        let isHeikinAshi = false;
        let isPanning = false;
        let panStartX = 0;
        let viewStartIndex = 0;
        let panStartViewIndex = 0;
        let autoFetchInterval = null;
        let lastDataSignature = '';
        let lastLiveTrend = null;
        let whiteAlertConsecutiveCount = 0;
        let lastCandleTimestampForWhiteAlert = 0;
        let visibleCandleCount = 100;
        let lastAutoSentTimestamp = 0;
        let lastSentSignalTimestamp = 0;
        let pageLoadTime = Date.now();
        let telegramState = {
            active: false,
            predictedColor: null,
            triggerTimestamp: 0,
            originalTriggerTimestamp: 0,
            galeLevel: 0,
            maxGales: 1,
            analysisMsg: ""
        };

        let scores = {
            white: { wins: 0, losses: 0 },
            red: { wins: 0, losses: 0 },
            black: { wins: 0, losses: 0 },
            surf: { wins: 0, losses: 0, whiteWins: 0 }
        };
        let predictionState = {
            white: { active: false, lastCheckedTimestamp: 0, attempts: 0 },
            red: { wasTriggered: false, triggerTimestamp: 0 },
            black: { wasTriggered: false, triggerTimestamp: 0 },
            surf: { wasTriggered: false, predictedColor: null, triggerTimestamp: 0, consecutiveLosses: 0, pauseUntil: 0 }
        };

        // Helper function to identify color
        function identificarCor(numero) {
            numero = parseInt(numero);
            if (numero === 0) return 'branco';
            if (numero >= 1 && numero <= 7) return 'vermelho';
            if (numero >= 8 && numero <= 14) return 'preto';
            return 'desconhecido';
        }

        function getFormattedHistory(limit = 12) {
            if (!globalGamesData || globalGamesData.length === 0) return "";
            return globalGamesData.slice(0, limit).reverse().map(g => {
                const c = identificarCor(g.roll);
                if (c === 'vermelho') return 'üî¥';
                if (c === 'preto') return '‚ö´';
                return '‚ö™';
            }).join(' ');
        }

        function calculateSMA(data, period) {
            const smaData = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    smaData.push(null);
                    continue;
                }
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += data[i - j].close;
                }
                smaData.push(sum / period);
            }
            return smaData;
        }

        function calculateBollingerBands(data, period = 20, multiplier = 2) {
            const upper = [];
            const lower = [];
            const middle = [];

            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    upper.push(null); lower.push(null); middle.push(null);
                    continue;
                }
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += data[i - j].close;
                }
                const sma = sum / period;
                middle.push(sma);
                let sumSqDiff = 0;
                for (let j = 0; j < period; j++) {
                    sumSqDiff += Math.pow(data[i - j].close - sma, 2);
                }
                const stdDev = Math.sqrt(sumSqDiff / period);
                upper.push(sma + (stdDev * multiplier));
                lower.push(sma - (stdDev * multiplier));
            }
            return { upper, middle, lower };
        }

        function calculateADX(data, period = 14) {
            const tr = new Array(data.length).fill(null);
            const plusDM = new Array(data.length).fill(null);
            const minusDM = new Array(data.length).fill(null);

            for (let i = 1; i < data.length; i++) {
                const current = data[i];
                const prev = data[i - 1];
                tr[i] = Math.max(current.high - current.low, Math.abs(current.high - prev.close), Math.abs(current.low - prev.close));
                const upMove = current.high - prev.high;
                const downMove = prev.low - current.low;
                plusDM[i] = (upMove > downMove && upMove > 0) ? upMove : 0;
                minusDM[i] = (downMove > upMove && downMove > 0) ? downMove : 0;
            }

            const wilderSmooth = (arr, period) => {
                const smoothed = new Array(arr.length).fill(null);
                if (arr.length < period) return smoothed;
                let firstValidIndex = -1;
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i] !== null) { firstValidIndex = i; break; }
                }
                if (firstValidIndex === -1 || firstValidIndex + period > arr.length) return smoothed;
                let sum = 0;
                for (let i = firstValidIndex; i < firstValidIndex + period; i++) {
                    sum += arr[i];
                }
                smoothed[firstValidIndex + period - 1] = sum / period;
                for (let i = firstValidIndex + period; i < arr.length; i++) {
                    if (arr[i] !== null && smoothed[i-1] !== null) {
                        smoothed[i] = (smoothed[i - 1] * (period - 1) + arr[i]) / period;
                    }
                }
                return smoothed;
            };

            const smoothedTR = wilderSmooth(tr, period);
            const smoothedPlusDM = wilderSmooth(plusDM, period);
            const smoothedMinusDM = wilderSmooth(minusDM, period);

            const plusDI = new Array(data.length).fill(null);
            const minusDI = new Array(data.length).fill(null);
            const dx = new Array(data.length).fill(null);

            for (let i = period; i < data.length; i++) {
                if (smoothedTR[i] > 0) {
                    plusDI[i] = 100 * (smoothedPlusDM[i] / smoothedTR[i]);
                    minusDI[i] = 100 * (smoothedMinusDM[i] / smoothedTR[i]);
                    const diSum = plusDI[i] + minusDI[i];
                    if (diSum > 0) {
                        dx[i] = 100 * (Math.abs(plusDI[i] - minusDI[i]) / diSum);
                    }
                }
            }

            const adx = wilderSmooth(dx, period);

            return { adx, plusDI, minusDI };
        }

        function calculateATR(data, period = 14) {
            const tr = new Array(data.length).fill(0);
            for (let i = 0; i < data.length; i++) {
                if (i === 0) {
                    tr[i] = data[i].high - data[i].low;
                } else {
                    tr[i] = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i - 1].close), Math.abs(data[i].low - data[i - 1].close));
                }
            }
            const atr = new Array(data.length).fill(null);
            if (data.length < period) return atr;
            let sum = 0;
            for (let i = 0; i < period; i++) sum += tr[i];
            atr[period - 1] = sum / period;
            for (let i = period; i < data.length; i++) {
                atr[i] = ((atr[i - 1] * (period - 1)) + tr[i]) / period;
            }
            return atr;
        }

        function calculateEMA(data, period) {
            const emaArray = new Array(data.length).fill(null);
            if (data.length < period) return emaArray;

            const k = 2 / (period + 1);
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += data[i].close;
            }
            emaArray[period - 1] = sum / period;

            for (let i = period; i < data.length; i++) {
                emaArray[i] = (data[i].close * k) + (emaArray[i - 1] * (1 - k));
            }
            return emaArray;
        }

        function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const emaFast = calculateEMA(data, fastPeriod);
            const emaSlow = calculateEMA(data, slowPeriod);
            const macdLine = [];
            const signalLine = [];
            const histogram = [];

            // Calculate MACD line
            for (let i = 0; i < data.length; i++) {
                if (emaFast[i] !== null && emaSlow[i] !== null) {
                    macdLine.push(emaFast[i] - emaSlow[i]);
                } else {
                    macdLine.push(null);
                }
            }

            // Calculate Signal line (EMA of MACD line)
            const macdValuesOnly = macdLine.map(v => ({ close: v })); // Adapt for EMA function
            const signalLineRaw = calculateEMA(macdValuesOnly, signalPeriod);
            for(let i=0; i<signalLineRaw.length; i++) {
                signalLine.push(signalLineRaw[i]);
            }

            // Calculate Histogram
            for (let i = 0; i < data.length; i++) {
                if (macdLine[i] !== null && signalLine[i] !== null) {
                    histogram.push(macdLine[i] - signalLine[i]);
                } else {
                    histogram.push(null);
                }
            }

            return { macdLine, signalLine, histogram };
        }

        function calculateEMA(data, period) {
            const emaArray = new Array(data.length).fill(null);
            if (data.length < period) return emaArray;

            const k = 2 / (period + 1);
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += data[i].close;
            }
            emaArray[period - 1] = sum / period;

            for (let i = period; i < data.length; i++) {
                emaArray[i] = (data[i].close * k) + (emaArray[i - 1] * (1 - k));
            }
            return emaArray;
        }

        function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const emaFast = calculateEMA(data, fastPeriod);
            const emaSlow = calculateEMA(data, slowPeriod);
            const macdLine = [];
            const signalLine = [];
            const histogram = [];

            // Calculate MACD line
            for (let i = 0; i < data.length; i++) {
                if (emaFast[i] !== null && emaSlow[i] !== null) {
                    macdLine.push(emaFast[i] - emaSlow[i]);
                } else {
                    macdLine.push(null);
                }
            }

            // Calculate Signal line (EMA of MACD line)
            const macdValuesOnly = macdLine.map(v => ({ close: v })); // Adapt for EMA function
            const signalLineRaw = calculateEMA(macdValuesOnly, signalPeriod);
            for(let i=0; i<signalLineRaw.length; i++) {
                signalLine.push(signalLineRaw[i]);
            }

            // Calculate Histogram
            for (let i = 0; i < data.length; i++) {
                if (macdLine[i] !== null && signalLine[i] !== null) {
                    histogram.push(macdLine[i] - signalLine[i]);
                } else {
                    histogram.push(null);
                }
            }

            return { macdLine, signalLine, histogram };
        }

        function calculateStochastic(data, periodK = 14, periodD = 3, smooth = 3) {
            const stochK = [];
            const stochD = [];

            // Calculate Fast %K first
            const fastK = [];
            for (let i = 0; i < data.length; i++) {
                if (i < periodK - 1) {
                    fastK.push(null);
                    continue;
                }
                
                let lowestLow = Infinity;
                let highestHigh = -Infinity;
                
                for (let j = 0; j < periodK; j++) {
                    lowestLow = Math.min(lowestLow, data[i - j].low);
                    highestHigh = Math.max(highestHigh, data[i - j].high);
                }
                
                const currentClose = data[i].close;
                let kValue = 50; // Default if high == low
                if (highestHigh - lowestLow !== 0) {
                    kValue = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
                }
                fastK.push(kValue);
            }

            // Smooth %K (Slow %K)
            for (let i = 0; i < fastK.length; i++) {
                if (i < periodK - 1 + smooth - 1) {
                    stochK.push(null);
                    continue;
                }
                let sum = 0; let count = 0;
                for (let j = 0; j < smooth; j++) { if (fastK[i - j] !== null) { sum += fastK[i - j]; count++; } }
                stochK.push(count > 0 ? sum / count : null);
            }

            // Calculate %D (SMA of %K)
            for (let i = 0; i < stochK.length; i++) {
                if (i < periodK - 1 + smooth - 1 + periodD - 1) {
                    stochD.push(null);
                    continue;
                }
                let sum = 0; let count = 0;
                for (let j = 0; j < periodD; j++) { if (stochK[i - j] !== null) { sum += stochK[i - j]; count++; } }
                stochD.push(count > 0 ? sum / count : null);
            }
            return { k: stochK, d: stochD };
        }

        function createHistoryBadge(game) {
            const colorClass = identificarCor(game.roll);
            const badge = document.createElement('div');
            badge.className = `history-badge ${colorClass}`;
            badge.dataset.id = game.id;
            
            const numberSpan = document.createElement('span');
            numberSpan.className = 'badge-number';
            numberSpan.textContent = game.roll;

            const timeSpan = document.createElement('span');
            timeSpan.className = 'badge-time';
            const date = new Date(game.created_at);
            timeSpan.textContent = date.toLocaleTimeString('pt-BR', {hour: '2-digit', minute:'2-digit'});

            badge.appendChild(numberSpan);
            badge.appendChild(timeSpan);
            return badge;
        }

        function updateTelegramHistoryGrid() {
            const grid = document.getElementById('telegram-history-grid');
            if (!grid) return;

            const recentGames = globalGamesData.slice(0, 9);
            
            if (grid.children.length === 0) {
                const fragment = document.createDocumentFragment();
                [...recentGames].reverse().forEach(game => fragment.appendChild(createHistoryBadge(game)));
                grid.appendChild(fragment);
                return;
            }

            const existingIds = new Set(Array.from(grid.children).map(b => b.dataset.id));
            const newItems = recentGames.filter(g => !existingIds.has(String(g.id)));

            for (let i = newItems.length - 1; i >= 0; i--) {
                const badge = createHistoryBadge(newItems[i]);
                badge.classList.add('slide-in-anim');
                grid.appendChild(badge);
            }
            
            while (grid.children.length > 9) {
                grid.removeChild(grid.firstChild);
            }
        }

        function renderVisibleCharts(shouldPlaySound = false) {
            const chartContainer = document.getElementById('chart-container');
            // Se o container n√£o estiver vis√≠vel, n√£o desenha nada para evitar erros.
            if (!chartContainer || chartContainer.clientWidth === 0) {
                return;
            }

            if (!allCandles || allCandles.length === 0) return;
            // Garante que o √≠ndice de in√≠cio n√£o saia dos limites do array
            
            let displayData = allCandles;
            if (isHeikinAshi) {
                displayData = calculateHeikinAshi(allCandles);
            }

            viewStartIndex = Math.max(0, Math.min(displayData.length - visibleCandleCount, viewStartIndex));
            const visibleData = displayData.slice(viewStartIndex, viewStartIndex + visibleCandleCount);
            
            drawChart(visibleData, shouldPlaySound);
            drawRSIChart(visibleData);
            drawMACDChart(visibleData);
            drawVolumeChart(visibleData);
            drawADXChart(visibleData);
            drawStochasticChart(visibleData);
        }

        function zoomIn() {
            if (visibleCandleCount > 20) {
                const center = viewStartIndex + visibleCandleCount / 2;
                visibleCandleCount -= 10;
                viewStartIndex = Math.max(0, Math.round(center - visibleCandleCount / 2));
                renderVisibleCharts();
            }
        }

        function zoomOut() {
            if (visibleCandleCount < 500 && visibleCandleCount < allCandles.length) {
                const center = viewStartIndex + visibleCandleCount / 2;
                visibleCandleCount += 10;
                viewStartIndex = Math.max(0, Math.round(center - visibleCandleCount / 2));
                renderVisibleCharts();
            }
        }

        function resetZoom() {
            visibleCandleCount = 100;
            resetView();
        }

        function resetView() {
            // Define o √≠ndice para mostrar as √∫ltimas 100 velas
            viewStartIndex = Math.max(0, allCandles.length - visibleCandleCount);
            renderVisibleCharts();
        }

        function toggleFullscreen() {
            const elem = document.querySelector('.layout-panel');
            if (!document.fullscreenElement) {
                elem.requestFullscreen().catch(err => {
                    alert(`N√£o foi poss√≠vel entrar em tela cheia: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('fullscreenBtn');
            if (btn) {
                btn.innerHTML = document.fullscreenElement ? 'üñºÔ∏è Sair' : 'üñºÔ∏è Tela Cheia';
            }
            setTimeout(() => renderVisibleCharts(), 200); // Redesenha ao mudar de tela
        });

        function calculateRSI(data, period = 14) {
            const rsi = new Array(data.length).fill(null);
            if (data.length <= period) return rsi;

            let avgGain = 0;
            let avgLoss = 0;

            // First period
            for (let i = 1; i <= period; i++) {
                const change = data[i].close - data[i - 1].close;
                if (change > 0) avgGain += change;
                else avgLoss += Math.abs(change);
            }
            avgGain /= period;
            avgLoss /= period;

            rsi[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));

            // Subsequent
            for (let i = period + 1; i < data.length; i++) {
                const change = data[i].close - data[i - 1].close;
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? Math.abs(change) : 0;

                avgGain = ((avgGain * (period - 1)) + gain) / period;
                avgLoss = ((avgLoss * (period - 1)) + loss) / period;

                rsi[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
            }
            return rsi;
        }

        function toggleDrawMode(btn) {
            isDrawMode = !isDrawMode;
            btn.classList.toggle('active', isDrawMode);
            const chartContainer = document.getElementById('chart-container');
            chartContainer.style.cursor = isDrawMode ? 'crosshair' : 'default';

            // Disable tooltips when drawing mode is active
            const hitAreas = document.querySelectorAll('#chart-container svg rect[fill="transparent"]');
            hitAreas.forEach(area => {
                area.style.pointerEvents = isDrawMode ? 'none' : 'all';
            });
        }

        function clearDrawings() {
            if (drawnLines.length > 0 && confirm('Limpar todos os desenhos?')) {
                drawnLines = [];
                updateChart(); // Redraw chart without the lines
            }
        }

        function updateChart(shouldPlaySound = false) {
            const timeframe = document.getElementById('timeframeSelect').value;
            allCandles = generateCandles(globalGamesData, timeframe);

            // Check Trend Alert (Live Data)
            if (allCandles.length > 0) {
                const { signal, color, icon } = getTrendSignal(allCandles);
                
                // Se a tend√™ncia mudou (ou √© a primeira execu√ß√£o)
                if (lastLiveTrend !== signal) {
                    addToTrendHistory(signal, color, icon);
                    if (lastLiveTrend !== null && lastLiveTrend === "NEUTRO" && (signal === "VERMELHO" || signal === "PRETO")) {
                        triggerTrendAlert(signal);
                    }
                    lastLiveTrend = signal;
                }
            }
            
            // Ao atualizar os dados, sempre volta para as velas mais recentes
            resetView();
            updateDoubleNews();

            // Verifica se deve enviar an√°lise autom√°tica para o Telegram
            checkAndSendAutoTelegram();
        }

        let isFetching = false;
        async function fetchData(shouldPlaySound = false) {
            if (isFetching) return;
            isFetching = true;
            const loadingText = document.querySelector('#chart-container .loading-text');
            try {
                if(loadingText) loadingText.innerText = 'Buscando dados da API...';

                let SEU_TOKEN_BLAZE = localStorage.getItem('blaze_token');
                 if (!SEU_TOKEN_BLAZE) {
                    try {
                        if (window.parent && window.parent.localStorage) {
                            SEU_TOKEN_BLAZE = window.parent.localStorage.getItem('blaze_token');
                        }
                    } catch (e) { /* cross-origin error */ }
                }

                const agora = new Date();
                const ontem = new Date();
                ontem.setHours(ontem.getHours() - 24);
                const endDate = agora.toISOString();
                const startDate = ontem.toISOString();
                const headers = {};
                if (SEU_TOKEN_BLAZE) {
                    headers['Authorization'] = `Bearer ${SEU_TOKEN_BLAZE}`;
                    headers['x-access-token'] = SEU_TOKEN_BLAZE;
                }

                const pages = [1, 2, 3, 4, 5];
                let allGamesApi = [];
                for (const page of pages) {
                    const baseUrl = `https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/history/${page}`;
                    const params = `?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}&page=${page}&_nc=${Date.now()}`;
                    const targetUrl = `${baseUrl}${params}`;
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                    
                    const response = await fetch(proxyUrl, { method: 'GET', headers: headers });
                    if (response.ok) {
                        const data = await response.json();
                        if (data) {
                            const records = Array.isArray(data) ? data : (data.records || []);
                            allGamesApi = allGamesApi.concat(records);
                            if (records.length === 0) break;
                        }
                    } else {
                        if (response.status === 401) throw new Error("Token inv√°lido (401).");
                        if (response.status === 429) {
                            console.warn(`Limite de requisi√ß√µes (429) na p√°gina ${page}. Interrompendo busca de hist√≥rico antigo para evitar bloqueio.`);
                            break; // Sai do loop mas mant√©m os dados j√° coletados
                        }
                        console.warn(`Falha ao buscar p√°gina ${page}: Status ${response.status}`);
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                const seenIds = new Set();
                const uniqueGames = allGamesApi.filter(game => {
                    if (game.id && !seenIds.has(game.id)) { seenIds.add(game.id); return true; }
                    return false;
                }).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                if (uniqueGames.length === 0) { throw new Error("A API n√£o retornou jogos."); }

                const newSignature = uniqueGames[0]?.id || '';
                if (newSignature === lastDataSignature) { if(loadingText && loadingText.innerText.includes('Buscando')) loadingText.style.display = 'none'; return; }
                lastDataSignature = newSignature;

                globalGamesData = uniqueGames.map(g => ({ id: g.id, created_at: g.created_at, roll: g.roll }));
                updateTelegramHistoryGrid();
                updateChart(shouldPlaySound);

            } catch (e) {
                console.error("Erro ao buscar dados para o gr√°fico:", e);
                if(loadingText) loadingText.innerText = `Erro: ${e.message}`;
            } finally {
                isFetching = false;
            }
        }

        function generateCandles(data, timeframe) {
            let priceData = [];
            let lastClose = 100;
            
            // Ordena do mais antigo para o mais novo para processamento sequencial
            const sortedData = [...data].sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

            if (timeframe === 'tick') {
                sortedData.forEach(game => {
                    const open = lastClose;
                    let high, low, close;
                    const color = identificarCor(game.roll);

                    if (color === 'vermelho') { // Up
                        close = open + 10; high = close; low = open;
                    } else if (color === 'preto') { // Down
                        close = open - 10; high = open; low = close;
                    } else { // Branco (Doji)
                        close = open; high = open + 5; low = open - 5;
                    }
                    const gameDate = new Date(game.created_at);
                    const timeStr = gameDate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    priceData.push({ open, high, low, close, color, roll: game.roll, time: timeStr, timestamp: gameDate.getTime(), volume: 1 });
                    lastClose = close;
                });
                return priceData;
            } else {
                // Agrega√ß√£o por Tempo (1m, 5m)
                const tfMs = parseInt(timeframe) * 60 * 1000;
                let currentBucketStart = null;
                let bucketCandle = null;

                sortedData.forEach(game => {
                    const gameTime = new Date(game.created_at).getTime();
                    const bucketStart = Math.floor(gameTime / tfMs) * tfMs;

                    const open = lastClose;
                    let close;
                    const gameColor = identificarCor(game.roll);
                    
                    if (gameColor === 'vermelho') close = open + 10;
                    else if (gameColor === 'preto') close = open - 10;
                    else close = open;
                    
                    if (currentBucketStart === null || bucketStart !== currentBucketStart) {
                        if (bucketCandle) priceData.push(bucketCandle);
                        currentBucketStart = bucketStart;
                        bucketCandle = {
                            open: open,
                            high: Math.max(open, close),
                            low: Math.min(open, close),
                            close: close,
                            time: new Date(bucketStart).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),
                            timestamp: bucketStart,
                            roll: game.roll, // Salva o roll da PRIMEIRA pedra do minuto
                            color: gameColor, // Salva a cor da PRIMEIRA pedra para a l√≥gica
                            volume: 1
                        };
                    } else {
                        bucketCandle.high = Math.max(bucketCandle.high, close);
                        bucketCandle.low = Math.min(bucketCandle.low, close);
                        bucketCandle.close = close; // Atualiza o 'close' para o da √∫ltima pedra, para o visual do candle
                        // N√£o atualiza o 'roll' nem a 'color', para manter os da primeira pedra
                        bucketCandle.volume++;
                    }
                    lastClose = close; // O 'open' da pr√≥xima vela ser√° o 'close' da √∫ltima pedra processada
                });
                if (bucketCandle) priceData.push(bucketCandle);

                return priceData;
            }
        }

        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            const btn = document.getElementById('themeToggleBtn');
            if(btn) btn.innerText = isLight ? 'üåô Tema' : '‚òÄÔ∏è Tema';
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
            updateChart();
        }

        function toggleFocusMode() {
            document.body.classList.toggle('focus-mode');
            const btn = document.getElementById('focus-btn');
            if (document.body.classList.contains('focus-mode')) {
                btn.innerHTML = '‚ùå';
                btn.title = "Sair do Modo Foco";
            } else {
                btn.innerHTML = 'üëÅÔ∏è';
                btn.title = "Modo Foco (Ocultar Ferramentas)";
            }
            setTimeout(renderVisibleCharts, 100);
        }

        function toggleHeikinAshi() {
            isHeikinAshi = !isHeikinAshi;
            const btn = document.getElementById('haToggleBtn');
            if (btn) {
                btn.classList.toggle('active', isHeikinAshi);
                if (isHeikinAshi) {
                    btn.style.borderColor = '#00d2ff';
                    btn.style.color = '#00d2ff';
                    btn.style.background = 'rgba(0, 210, 255, 0.1)';
                } else {
                    btn.style.borderColor = '';
                    btn.style.color = '';
                    btn.style.background = '';
                }
            }
            renderVisibleCharts();
        }

        function calculateHeikinAshi(data) {
            if (!data || data.length === 0) return [];
            const haData = [];
            let prevOpen = data[0].open;
            let prevClose = data[0].close;

            for (let i = 0; i < data.length; i++) {
                const curr = data[i];
                const haClose = (curr.open + curr.high + curr.low + curr.close) / 4;
                const haOpen = i === 0 ? (curr.open + curr.close) / 2 : (prevOpen + prevClose) / 2;
                const haHigh = Math.max(curr.high, haOpen, haClose);
                const haLow = Math.min(curr.low, haOpen, haClose);

                haData.push({ ...curr, open: haOpen, high: haHigh, low: haLow, close: haClose });
                prevOpen = haOpen; prevClose = haClose;
            }
            return haData;
        }

        // Function to render the candlestick chart
        function drawChart(priceData, shouldPlaySound = false) {
            const chartContainer = document.getElementById('chart-container');
            const historyPanel = document.getElementById('trend-history-panel'); // Preserve history panel
            const ohlcPanel = document.getElementById('ohlc-display'); // Preserve OHLC panel
            const focusBtn = document.getElementById('focus-btn'); // Preserve focus button
            chartContainer.innerHTML = ''; // Clear previous chart or loading text

            const isLight = document.body.classList.contains('light-mode');
            
            const upColor = document.getElementById('candleUpColor') ? document.getElementById('candleUpColor').value : '#ff0055';
            const downColor = document.getElementById('candleDownColor') ? document.getElementById('candleDownColor').value : '#343a40';

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            
            const containerWidth = chartContainer.clientWidth;
            const containerHeight = chartContainer.clientHeight;
            const margin = { top: 20, right: 50, bottom: 60, left: 50 };
            const width = containerWidth - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;

            svg.setAttribute('width', containerWidth);
            svg.setAttribute('height', containerHeight);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Add SVG filter for glow effect
            const defs = document.createElementNS(svgNS, 'defs');
            defs.innerHTML = `
                <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
                <filter id="glow-pulse" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="1.5" result="coloredBlur">
                        <animate attributeName="stdDeviation" values="1.5; 4; 1.5" dur="1.2s" repeatCount="indefinite" />
                    </feGaussianBlur>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            `;
            svg.appendChild(defs);

            // priceData is already prepared by generateCandles
            const digitalFont = "'Orbitron', sans-serif";
            // 2. Find min/max price for scaling
            const minPrice = Math.min(...priceData.map(p => p.low));
            const maxPrice = Math.max(...priceData.map(p => p.high));
            const priceRange = maxPrice - minPrice;

            const y = (price) => height - ((price - minPrice) / priceRange) * height;

            // 2.1 Draw Y-Axis Grid and Labels
            const tickCount = 7; // Number of grid lines/labels
            const tickValues = [];
            const tickSize = priceRange / (tickCount - 1);

            for (let i = 0; i < tickCount; i++) {
                const tickValue = minPrice + (i * tickSize);
                const tickY = y(tickValue);

                // Grid line
                const gridLine = document.createElementNS(svgNS, 'line');
                gridLine.setAttribute('x1', 0);
                gridLine.setAttribute('y1', tickY);
                gridLine.setAttribute('x2', width);
                gridLine.setAttribute('y2', tickY);
                gridLine.setAttribute('stroke', isLight ? '#e0e0e0' : '#2a2a2a'); // Grid line color
                gridLine.setAttribute('stroke-dasharray', '2,3');
                g.appendChild(gridLine);

                // Axis label
                const axisLabel = document.createElementNS(svgNS, 'text');
                axisLabel.setAttribute('x', width + 5);
                axisLabel.setAttribute('y', tickY + 4);
                axisLabel.setAttribute('fill', isLight ? '#666' : '#888');
                axisLabel.setAttribute('font-size', '10px');
                axisLabel.setAttribute('font-family', digitalFont);
                axisLabel.textContent = tickValue.toFixed(0);
                g.appendChild(axisLabel);
            }

            // Define dimensions for candles and indicators
            const candleWidth = Math.max(1, width / priceData.length * 0.5); 
            const candleSpacing = width / priceData.length;

            // Draw Bollinger Bands if enabled (Before candles to be in background)
            const showBB = document.getElementById('bbToggle') && document.getElementById('bbToggle').checked;

            if (showBB && priceData.length > 0) {
                const bbPeriodInput = document.getElementById('bbPeriodInput');
                const bbPeriod = bbPeriodInput ? parseInt(bbPeriodInput.value) : 20;
                const bbStdDevInput = document.getElementById('bbStdDevInput');
                const bbStdDev = bbStdDevInput ? parseFloat(bbStdDevInput.value) : 2;

                const bbData = calculateBollingerBands(priceData, bbPeriod, bbStdDev);
                
                // Draw Area
                let areaPath = "";
                let firstPoint = true;
                for(let i=0; i<bbData.upper.length; i++) {
                    if(bbData.upper[i] !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(bbData.upper[i]);
                        if(firstPoint) { areaPath = `M ${x} ${yVal}`; firstPoint = false; }
                        else areaPath += ` L ${x} ${yVal}`;
                    }
                }
                for(let i=bbData.lower.length-1; i>=0; i--) {
                    if(bbData.lower[i] !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(bbData.lower[i]);
                        areaPath += ` L ${x} ${yVal}`;
                    }
                }
                areaPath += " Z";
                if (areaPath !== "") {
                    const area = document.createElementNS(svgNS, 'path');
                    area.setAttribute('d', areaPath);
                    area.setAttribute('fill', 'rgba(0, 210, 255, 0.15)');
                    area.setAttribute('stroke', 'none');
                    g.appendChild(area);
                }

                // Helper to draw line
                const drawLine = (data, color, dash) => {
                    let path = "";
                    data.forEach((val, i) => {
                        if (val !== null) {
                            const x = i * candleSpacing + candleWidth / 2;
                            const yVal = y(val);
                            if (path === "") path = `M ${x} ${yVal}`;
                            else path += ` L ${x} ${yVal}`;
                        }
                    });
                    if (path !== "") {
                        const line = document.createElementNS(svgNS, 'path');
                        line.setAttribute('d', path);
                        line.setAttribute('stroke', color);
                        line.setAttribute('stroke-width', '1.5');
                        line.setAttribute('fill', 'none');
                        if(dash) line.setAttribute('stroke-dasharray', dash);
                        g.appendChild(line);
                    }
                };
                drawLine(bbData.upper, '#00d2ff');
                drawLine(bbData.lower, '#00d2ff');
                drawLine(bbData.middle, '#00d2ff', '4,4');

                // Draw Alerts for BB Touches
                let alertTriggered = false;

                priceData.forEach((d, i) => {
                    if (bbData.upper[i] !== null && bbData.lower[i] !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const isLast = i === priceData.length - 1;
                        
                        // Touch Upper Band
                        if (d.high >= bbData.upper[i]) {
                            const yVal = y(d.high) - 10; 
                            const marker = document.createElementNS(svgNS, 'circle');
                            marker.setAttribute('cx', x); marker.setAttribute('cy', yVal); marker.setAttribute('r', 3);
                            marker.setAttribute('fill', '#ff0055'); marker.setAttribute('stroke', '#fff'); marker.setAttribute('stroke-width', '1');
                            if (isLast) {
                                marker.classList.add('bb-alert-marker');
                                alertTriggered = true;
                            }
                            g.appendChild(marker);
                        }
                        // Touch Lower Band
                        if (d.low <= bbData.lower[i]) {
                            const yVal = y(d.low) + 10; 
                            const marker = document.createElementNS(svgNS, 'circle');
                            marker.setAttribute('cx', x); marker.setAttribute('cy', yVal); marker.setAttribute('r', 3);
                            marker.setAttribute('fill', '#00ff88'); marker.setAttribute('stroke', '#fff'); marker.setAttribute('stroke-width', '1');
                            if (isLast) {
                                marker.classList.add('bb-alert-marker');
                                alertTriggered = true;
                            }
                            g.appendChild(marker);
                        }
                    }
                });

                if (alertTriggered && shouldPlaySound) playAlertSound();
            }

            // 3. Draw candles
            priceData.forEach((d, i) => {
                const x = i * candleSpacing;
                
                // Wick
                const wick = document.createElementNS(svgNS, 'line');
                wick.setAttribute('x1', x + candleWidth / 2);
                wick.setAttribute('y1', y(d.high));
                wick.setAttribute('x2', x + candleWidth / 2);
                wick.setAttribute('y2', y(d.low));
                
                wick.classList.add('candle-wick');
                // Body
                const body = document.createElementNS(svgNS, 'rect');
                body.setAttribute('x', x);
                body.setAttribute('y', y(Math.max(d.open, d.close)));
                body.setAttribute('width', candleWidth);
                body.setAttribute('height', Math.max(1, Math.abs(y(d.open) - y(d.close)))); // Min height of 1 for dojis

                let candleColor;
                // A cor VISUAL da vela √© baseada na abertura/fechamento, que reflete a √∫ltima pedra do minuto.
                if (d.close > d.open) {
                    candleColor = upColor;
                } else if (d.close < d.open) {
                    candleColor = downColor;
                } else { // doji
                    candleColor = isLight ? '#cccccc' : '#ffffff';
                }
                
                wick.setAttribute('stroke', candleColor);
                wick.setAttribute('stroke-width', '1.5');
                body.setAttribute('fill', candleColor);
                
                g.appendChild(wick);
                g.appendChild(body);

                // O destaque do branco usa a cor L√ìGICA (d.color), que vem da primeira pedra.
                if (d.color === 'branco') {
                    const markerX = x + candleWidth / 2;
                    const markerY = y(d.high) - 12;
                    const size = 4;
                    
                    const diamond = document.createElementNS(svgNS, 'polygon');
                    diamond.setAttribute('points', `${markerX},${markerY-size} ${markerX+size},${markerY} ${markerX},${markerY+size} ${markerX-size},${markerY}`);
                    diamond.setAttribute('fill', '#ffffff');
                    diamond.setAttribute('stroke', '#00d2ff');
                    diamond.setAttribute('stroke-width', '1');
                    g.appendChild(diamond);

                    const label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', markerX);
                    label.setAttribute('y', markerY - 8);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', isLight ? '#333' : '#fff');
                    label.setAttribute('font-size', '9px');
                    label.setAttribute('font-family', digitalFont);
                    label.setAttribute('font-weight', 'bold');
                    label.textContent = '14x';
                    g.appendChild(label);
                }

                // Hit area for tooltip
                const hitArea = document.createElementNS(svgNS, 'rect');
                hitArea.setAttribute('x', x);
                hitArea.setAttribute('y', 0);
                hitArea.setAttribute('width', candleSpacing);
                hitArea.setAttribute('height', height);
                hitArea.setAttribute('fill', 'transparent');
                // Store data for touch interaction
                hitArea.dataset.time = d.time;
                hitArea.dataset.roll = d.roll;
                hitArea.style.cursor = 'crosshair';

                hitArea.addEventListener('mousemove', (e) => {
                    const tooltip = document.getElementById('chart-tooltip');
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';
                    const stoneColor = identificarCor(d.roll);
                    const colorHex = stoneColor === 'vermelho' ? '#ff0055' : (stoneColor === 'preto' ? '#aaa' : '#fff');
                    tooltip.innerHTML = `<div style="margin-bottom:4px; border-bottom:1px solid #444; padding-bottom:2px;"><strong>${d.time}</strong></div><div>Pedra: <span style="color:${colorHex}; font-weight:bold; font-size:1.1rem;">${d.roll}</span></div><div>Cor: ${stoneColor.toUpperCase()}</div>`;

                    // Update OHLC Panel
                    if (ohlcPanel) {
                        ohlcPanel.style.display = 'block';
                        const valColor = isLight ? '#333' : '#fff';
                        const openEl = document.getElementById('ohlc-open'); if(openEl) { openEl.innerText = d.open; openEl.style.color = valColor; }
                        const highEl = document.getElementById('ohlc-high'); if(highEl) { highEl.innerText = d.high; highEl.style.color = valColor; }
                        const lowEl = document.getElementById('ohlc-low'); if(lowEl) { lowEl.innerText = d.low; lowEl.style.color = valColor; }
                        const closeEl = document.getElementById('ohlc-close'); if(closeEl) { closeEl.innerText = d.close; closeEl.style.color = valColor; }
                    }
                });
                hitArea.addEventListener('mouseleave', () => { document.getElementById('chart-tooltip').style.display = 'none'; });
                g.appendChild(hitArea);
            });

            // Draw Fractals and Trend Lines
            const showFractals = document.getElementById('fractalsToggle') && document.getElementById('fractalsToggle').checked;
            const showTrendLines = document.getElementById('trendLineToggle') && document.getElementById('trendLineToggle').checked;
            const topFractals = [];
            const bottomFractals = [];

            if ((showFractals || showTrendLines) && priceData.length >= 5) {
                for (let i = 2; i < priceData.length - 2; i++) {
                    const d = priceData[i];
                    const high = d.high;
                    const low = d.low;
                    
                    // Fractal Top (High)
                    if (high > priceData[i-1].high && high > priceData[i-2].high &&
                        high > priceData[i+1].high && high > priceData[i+2].high) {
                        topFractals.push({ index: i, price: high });
                        if (showFractals) {
                            const x = i * candleSpacing + candleWidth / 2;
                            const yPos = y(high) - 12;
                            const marker = document.createElementNS(svgNS, 'path');
                            marker.setAttribute('d', `M ${x-4} ${yPos+4} L ${x} ${yPos-4} L ${x+4} ${yPos+4} Z`); // Up pointing triangle
                            marker.setAttribute('fill', '#00d2ff');
                            g.appendChild(marker);
                        }
                    }

                    // Fractal Bottom (Low)
                    if (low < priceData[i-1].low && low < priceData[i-2].low &&
                        low < priceData[i+1].low && low < priceData[i+2].low) {
                        bottomFractals.push({ index: i, price: low });
                        if (showFractals) {
                            const x = i * candleSpacing + candleWidth / 2;
                            const yPos = y(low) + 12;
                            const marker = document.createElementNS(svgNS, 'path');
                            marker.setAttribute('d', `M ${x-4} ${yPos-4} L ${x} ${yPos+4} L ${x+4} ${yPos-4} Z`); // Down pointing triangle
                            marker.setAttribute('fill', '#ff0055');
                            g.appendChild(marker);
                        }
                    }
                }
            }

            if (showTrendLines) {
                // Top Trendline
                if (topFractals.length >= 2) {
                    const p1 = topFractals[topFractals.length - 2];
                    const p2 = topFractals[topFractals.length - 1];
                    const x1 = p1.index * candleSpacing + candleWidth / 2;
                    const y1 = y(p1.price);
                    const x2 = p2.index * candleSpacing + candleWidth / 2;
                    const y2 = y(p2.price);
                    
                    const slope = (y2 - y1) / (x2 - x1);
                    const xEnd = width;
                    const yEnd = y1 + slope * (xEnd - x1);
                    
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', xEnd); line.setAttribute('y2', yEnd);
                    line.setAttribute('stroke', '#00d2ff');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,5');
                    g.appendChild(line);
                }
                // Bottom Trendline
                if (bottomFractals.length >= 2) {
                    const p1 = bottomFractals[bottomFractals.length - 2];
                    const p2 = bottomFractals[bottomFractals.length - 1];
                    const x1 = p1.index * candleSpacing + candleWidth / 2;
                    const y1 = y(p1.price);
                    const x2 = p2.index * candleSpacing + candleWidth / 2;
                    const y2 = y(p2.price);
                    
                    const slope = (y2 - y1) / (x2 - x1);
                    const xEnd = width;
                    const yEnd = y1 + slope * (xEnd - x1);
                    
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', xEnd); line.setAttribute('y2', yEnd);
                    line.setAttribute('stroke', '#ff0055');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,5');
                    g.appendChild(line);
                }
            }

            // Support and Resistance Logic
            const showSR = document.getElementById('srToggle') && document.getElementById('srToggle').checked;
            if (showSR && typeof allCandles !== 'undefined' && allCandles.length > 0) {
                const srLookbackInput = document.getElementById('srLookbackInput');
                const srLinesInput = document.getElementById('srLinesInput');
                const lookback = srLookbackInput ? parseInt(srLookbackInput.value) : 200;
                const maxLines = srLinesInput ? parseInt(srLinesInput.value) : 3;
                const endIndex = viewStartIndex + priceData.length;
                const startIndex = Math.max(0, endIndex - lookback);
                const resistances = [];
                const supports = [];

                for (let i = startIndex + 2; i < endIndex - 2; i++) {
                    if (i >= allCandles.length - 2) break;
                    const d = allCandles[i];
                    const prev1 = allCandles[i-1]; const prev2 = allCandles[i-2];
                    const next1 = allCandles[i+1]; const next2 = allCandles[i+2];

                    if (d.high > prev1.high && d.high > prev2.high && d.high > next1.high && d.high > next2.high) {
                        resistances.push(d.high);
                    }
                    if (d.low < prev1.low && d.low < prev2.low && d.low < next1.low && d.low < next2.low) {
                        supports.push(d.low);
                    }
                }

                const uniqueRes = [...new Set(resistances.reverse())].slice(0, maxLines);
                const uniqueSup = [...new Set(supports.reverse())].slice(0, maxLines);

                const currentPrice = priceData.length > 0 ? priceData[priceData.length - 1].close : 0;

                uniqueRes.forEach(price => {
                    const yVal = y(price);
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', 0); line.setAttribute('y1', yVal);
                    line.setAttribute('x2', width); line.setAttribute('y2', yVal);
                    line.setAttribute('stroke', '#ff0055'); line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,2'); line.setAttribute('opacity', '0.8');
                    if (Math.abs(currentPrice - price) <= 2) {
                        line.classList.add('sr-alert-blink');
                    }
                    g.appendChild(line);
                    const label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', width - 5); label.setAttribute('y', yVal - 3);
                    label.setAttribute('text-anchor', 'end'); label.setAttribute('fill', '#ff0055');
                    label.setAttribute('font-size', '9px'); label.textContent = 'RES ' + price;
                    label.setAttribute('font-family', digitalFont);
                    g.appendChild(label);
                });

                uniqueSup.forEach(price => {
                    const yVal = y(price);
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', 0); line.setAttribute('y1', yVal);
                    line.setAttribute('x2', width); line.setAttribute('y2', yVal);
                    line.setAttribute('stroke', '#00ff88'); line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,2'); line.setAttribute('opacity', '0.8');
                    if (Math.abs(currentPrice - price) <= 2) {
                        line.classList.add('sr-alert-blink');
                    }
                    g.appendChild(line);
                    const label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', width - 5); label.setAttribute('y', yVal + 10);
                    label.setAttribute('text-anchor', 'end'); label.setAttribute('fill', '#00ff88');
                    label.setAttribute('font-size', '9px'); label.textContent = 'SUP ' + price;
                    label.setAttribute('font-family', digitalFont);
                    g.appendChild(label);
                });

                // Contador de velas sem tocar S/R
                let srCounter = 0;
                let srFound = false;
                const allLevels = [...uniqueRes, ...uniqueSup];
                const lastVisibleIdx = viewStartIndex + priceData.length - 1;

                if (allLevels.length > 0 && lastVisibleIdx >= 0) {
                    for (let i = lastVisibleIdx; i >= 0; i--) {
                        const c = allCandles[i];
                        // Toler√¢ncia de 2 (mesma usada no blink)
                        const touched = allLevels.some(lvl => c.high >= lvl - 2 && c.low <= lvl + 2);
                        if (touched) { srFound = true; break; }
                        srCounter++;
                    }
                }
                const srText = document.createElementNS(svgNS, 'text');
                srText.setAttribute('x', 10); srText.setAttribute('y', 20);
                srText.setAttribute('fill', isLight ? '#333' : '#ccc'); srText.setAttribute('font-size', '10px');
                srText.setAttribute('font-family', digitalFont);
                srText.textContent = `Velas s/ S/R: ${srFound ? srCounter : (allCandles.length > 0 ? allCandles.length + '+' : '0')}`;
                g.appendChild(srText);
            }

            // --- VISUALIZADOR DE DOUBLET (M√âDIA CURTA) ---
            // Desenha linha onde a m√©dia de repeti√ß√£o curta √© esperada
            if (typeof allCandles !== 'undefined' && allCandles.length > 0) {
                const whiteIndices = [];
                allCandles.forEach((c, i) => { if (c.color === 'branco') whiteIndices.push(i); });
                
                if (whiteIndices.length >= 2) {
                    const intervals = [];
                    for (let i = 1; i < whiteIndices.length; i++) intervals.push(whiteIndices[i] - whiteIndices[i - 1]);
                    
                    const allRecentIntervals = intervals.slice(-50);
                    const shortIntervals = allRecentIntervals.filter(i => i <= 12);
                    
                    if (shortIntervals.length > 0) {
                        const shortFreq = shortIntervals.length / allRecentIntervals.length;
                        const lastWhiteIndex = whiteIndices[whiteIndices.length - 1];
                        const candlesSinceWhite = (allCandles.length - 1) - lastWhiteIndex;
                        
                        // Se o padr√£o for frequente (>15%) e estivermos numa janela relevante (<=20 casas)
                        if (shortFreq >= 0.15 && candlesSinceWhite <= 20) {
                            const avgShort = shortIntervals.reduce((a, b) => a + b, 0) / shortIntervals.length;
                            const targetIndex = lastWhiteIndex + avgShort;
                            const localTargetIndex = targetIndex - viewStartIndex;
                            
                            if (localTargetIndex >= -1 && localTargetIndex <= priceData.length + 1) {
                                const x = localTargetIndex * candleSpacing + candleWidth / 2;
                                
                                const line = document.createElementNS(svgNS, 'line');
                                line.setAttribute('x1', x); line.setAttribute('y1', 0);
                                line.setAttribute('x2', x); line.setAttribute('y2', height);
                                line.setAttribute('stroke', '#00d2ff'); line.setAttribute('stroke-width', '1.5');
                                line.setAttribute('stroke-dasharray', '4,4'); line.setAttribute('opacity', '0.7');
                                g.appendChild(line);
                                
                                const icon = document.createElementNS(svgNS, 'text');
                                icon.setAttribute('x', x); icon.setAttribute('y', 20); icon.setAttribute('text-anchor', 'middle');
                                icon.setAttribute('font-size', '14px'); icon.textContent = '‚ôªÔ∏è';
                                g.appendChild(icon);
                                icon.setAttribute('font-family', digitalFont);

                                const label = document.createElementNS(svgNS, 'text');
                                label.setAttribute('x', x); label.setAttribute('y', 32); label.setAttribute('text-anchor', 'middle');
                                label.setAttribute('fill', '#00d2ff'); label.setAttribute('font-size', '9px'); label.setAttribute('font-weight', 'bold');
                                label.textContent = avgShort.toFixed(1);
                                g.appendChild(label);
                                label.setAttribute('font-family', digitalFont);
                            }
                        }
                    }
                }
            }

            // Draw SMA if enabled
            const showSMA = document.getElementById('smaToggle') && document.getElementById('smaToggle').checked;
            if (showSMA && priceData.length > 0) {
                const smaPeriodInput = document.getElementById('smaPeriodInput');
                const smaPeriod = smaPeriodInput ? parseInt(smaPeriodInput.value) : 14;
                const smaValues = calculateSMA(priceData, smaPeriod);
                
                let smaPath = "";
                smaValues.forEach((val, i) => {
                    if (val !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(val);
                        if (smaPath === "") smaPath = `M ${x} ${yVal}`;
                        else smaPath += ` L ${x} ${yVal}`;
                    }
                });

                if (smaPath !== "") {
                    const smaLine = document.createElementNS(svgNS, 'path');
                    smaLine.setAttribute('d', smaPath);
                    smaLine.setAttribute('stroke', '#ff9800');
                    smaLine.setAttribute('stroke-width', '1.5');
                    smaLine.setAttribute('fill', 'none');
                    smaLine.style.pointerEvents = 'none';
                    g.appendChild(smaLine);
                }
            }

            // Draw EMA if enabled
            const showEMA = document.getElementById('emaToggle') && document.getElementById('emaToggle').checked;
            if (showEMA && priceData.length > 0) {
                const emaPeriodInput = document.getElementById('emaPeriodInput');
                const emaPeriod = emaPeriodInput ? parseInt(emaPeriodInput.value) : 9;
                const emaValues = calculateEMA(priceData, emaPeriod);

                let emaPath = "";
                emaValues.forEach((val, i) => {
                    if (val !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(val);
                        if (emaPath === "") emaPath = `M ${x} ${yVal}`;
                        else emaPath += ` L ${x} ${yVal}`;
                    }
                });

                if (emaPath !== "") {
                    const emaLine = document.createElementNS(svgNS, 'path');
                    emaLine.setAttribute('d', emaPath);
                    emaLine.setAttribute('stroke', '#00ff88'); // Green color for EMA
                    emaLine.setAttribute('stroke-width', '1.5');
                    emaLine.setAttribute('fill', 'none');
                    g.appendChild(emaLine);
                }
            }
            // Redraw persistent lines
            const drawingsGroup = document.createElementNS(svgNS, 'g');
            g.appendChild(drawingsGroup);
            drawnLines.forEach(lineData => {
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', lineData.x1);
                line.setAttribute('y1', lineData.y1);
                line.setAttribute('x2', lineData.x2);
                line.setAttribute('y2', lineData.y2);
                line.setAttribute('stroke', lineData.color || '#00d2ff');
                line.setAttribute('stroke-width', '1.5');
                drawingsGroup.appendChild(line);
            });

            // 4. Draw current price line and label
            if (priceData.length > 0) {
                const lastCandle = priceData[priceData.length - 1];
                const lastClosePrice = lastCandle.close;
                const lastY = y(lastClosePrice);

                // Dashed line across the chart
                const currentPriceLine = document.createElementNS(svgNS, 'line');
                currentPriceLine.setAttribute('x1', 0);
                currentPriceLine.setAttribute('y1', lastY);
                currentPriceLine.setAttribute('x2', width);
                currentPriceLine.setAttribute('y2', lastY);
                currentPriceLine.setAttribute('stroke', '#ffc107');
                currentPriceLine.setAttribute('stroke-width', '1.5');
                currentPriceLine.setAttribute('stroke-dasharray', '4, 4');
                currentPriceLine.classList.add('current-price-line');
                g.appendChild(currentPriceLine);

                // Price label background on the right axis
                const priceLabelBg = document.createElementNS(svgNS, 'rect');
                priceLabelBg.setAttribute('x', width);
                priceLabelBg.setAttribute('y', lastY - 10);
                priceLabelBg.setAttribute('width', margin.right);
                priceLabelBg.setAttribute('height', 20);
                priceLabelBg.setAttribute('fill', '#ffc107');
                g.appendChild(priceLabelBg);

                // Price label text
                const priceLabel = document.createElementNS(svgNS, 'text');
                priceLabel.setAttribute('x', width + 5);
                priceLabel.setAttribute('y', lastY + 4);
                priceLabel.setAttribute('fill', '#000'); // Always black on yellow bg
                priceLabel.setAttribute('font-size', '12px');
                priceLabel.setAttribute('font-family', digitalFont);
                priceLabel.setAttribute('font-weight', 'bold');
                priceLabel.textContent = lastClosePrice.toFixed(0);
                g.appendChild(priceLabel);

                // Vertical dotted line for next candle
                const nextCandleLine = document.createElementNS(svgNS, 'line');
                nextCandleLine.setAttribute('x1', width);
                nextCandleLine.setAttribute('y1', 0);
                nextCandleLine.setAttribute('x2', width);
                nextCandleLine.setAttribute('y2', height);
                nextCandleLine.setAttribute('stroke', isLight ? '#999' : '#555');
                nextCandleLine.setAttribute('stroke-width', '1');
                nextCandleLine.setAttribute('stroke-dasharray', '4, 4');
                g.appendChild(nextCandleLine);

                // Countdown for next candle
                const timeframe = document.getElementById('timeframeSelect').value;
                if (timeframe !== 'tick') {
                    const timerLabel = document.createElementNS(svgNS, 'text');
                    timerLabel.setAttribute('id', 'candle-countdown');
                    timerLabel.setAttribute('x', width - 5);
                    timerLabel.setAttribute('y', lastY - 8);
                    timerLabel.setAttribute('text-anchor', 'end');
                    timerLabel.setAttribute('fill', '#ffc107');
                    timerLabel.setAttribute('font-family', digitalFont);
                    timerLabel.setAttribute('font-size', '11px');
                    timerLabel.setAttribute('font-weight', 'bold');
                    timerLabel.textContent = "--:--";
                    g.appendChild(timerLabel);
                }
            }

            // Draw Average Price of Last 10 White Candles
            if (typeof allCandles !== 'undefined' && allCandles.length > 0) {
                const allWhites = allCandles.filter(c => c.color === 'branco');
                if (allWhites.length > 0) {
                    const last10 = allWhites.slice(-10);
                    const avgPrice = last10.reduce((sum, c) => sum + c.close, 0) / last10.length;
                    const lineY = y(avgPrice);

                    const avgLine = document.createElementNS(svgNS, 'line');
                    avgLine.setAttribute('x1', 0); avgLine.setAttribute('y1', lineY);
                    avgLine.setAttribute('x2', width); avgLine.setAttribute('y2', lineY);
                    avgLine.setAttribute('stroke', '#00d2ff'); avgLine.setAttribute('stroke-width', '1');
                    avgLine.setAttribute('stroke-dasharray', '4, 4'); avgLine.setAttribute('opacity', '0.8');
                    g.appendChild(avgLine);

                    const avgLabel = document.createElementNS(svgNS, 'text');
                    avgLabel.setAttribute('x', 10); avgLabel.setAttribute('y', lineY - 4);
                    avgLabel.setAttribute('fill', '#00d2ff'); avgLabel.setAttribute('font-size', '10px');
                    avgLabel.textContent = `M√©dia Brancos (10): ${avgPrice.toFixed(0)}`;
                    avgLabel.setAttribute('font-family', digitalFont);
                    g.appendChild(avgLabel);
                }
            }

            // --- BARRA LATERAL ESQUERDA (DISTRIBUI√á√ÉO VIS√çVEL) ---
            // Mostra a propor√ß√£o de cores na tela atual para ajudar na an√°lise de tend√™ncia visual
            const leftBarX = -42;
            const leftBarW = 8;
            
            let vRed = 0, vBlack = 0, vWhite = 0;
            priceData.forEach(d => {
                if (d.color === 'vermelho') vRed++;
                else if (d.color === 'preto') vBlack++;
                else if (d.color === 'branco') vWhite++;
            });
            const vTotal = vRed + vBlack + vWhite;

            if (vTotal > 0) {
                const pctRed = vRed / vTotal;
                const pctWhite = vWhite / vTotal;
                const pctBlack = vBlack / vTotal;
                
                const hRed = pctRed * height;
                const hWhite = pctWhite * height;
                const hBlack = pctBlack * height;

                // Fundo da Barra (Track Futurista)
                const track = document.createElementNS(svgNS, 'rect');
                track.setAttribute('x', leftBarX); track.setAttribute('y', 0);
                track.setAttribute('width', leftBarW); track.setAttribute('height', height);
                track.setAttribute('fill', 'rgba(0,0,0,0.3)');
                track.setAttribute('stroke', 'rgba(255,255,255,0.1)');
                track.setAttribute('rx', 4);
                g.appendChild(track);

                let currentY = 0;

                const drawSegment = (h, color, pct, labelColor, glow) => {
                    if (h <= 0) return;
                    // Segmento
                    const r = document.createElementNS(svgNS, 'rect');
                    r.setAttribute('x', leftBarX + 2); 
                    r.setAttribute('y', currentY + 1);
                    r.setAttribute('width', leftBarW - 4); 
                    r.setAttribute('height', Math.max(0, h - 2));
                    r.setAttribute('fill', color);
                    r.setAttribute('rx', 2);
                    // Aplica efeito de pulso se for dominante (>70%), sen√£o aplica brilho normal se 'glow' for true
                    if (pct > 0.7) {
                        r.setAttribute('filter', 'url(#glow-pulse)');
                    } else if (glow) {
                        r.setAttribute('filter', 'url(#glow)');
                    }
                    g.appendChild(r);

                    // Label Futurista
                    if (h > 25) {
                        const centerY = currentY + h / 2;
                        
                        // Linha conectora
                        const line = document.createElementNS(svgNS, 'line');
                        line.setAttribute('x1', leftBarX + leftBarW); line.setAttribute('y1', centerY);
                        line.setAttribute('x2', leftBarX + leftBarW + 6); line.setAttribute('y2', centerY);
                        line.setAttribute('stroke', color); line.setAttribute('stroke-width', '1');
                        g.appendChild(line);

                        // Texto
                        const t = document.createElementNS(svgNS, 'text');
                        t.setAttribute('x', leftBarX + leftBarW + 10); t.setAttribute('y', centerY + 3);
                        t.setAttribute('fill', labelColor); t.setAttribute('font-size', '9px');
                        t.setAttribute('font-family', digitalFont); t.setAttribute('font-weight', 'bold');
                        t.textContent = `${Math.round(pct*100)}%`;
                        g.appendChild(t);
                    }
                    currentY += h;
                };

                // Red (Top)
                drawSegment(hRed, '#ff0055', pctRed, '#ff0055', true);
                
                // White (Middle)
                drawSegment(hWhite, '#ffffff', pctWhite, isLight ? '#333' : '#fff', true);

                // Black (Bottom)
                drawSegment(hBlack, isLight ? '#333' : '#444', pctBlack, isLight ? '#333' : '#888', false);
            }

            // --- INDICADOR DE FOR√áA DA TEND√äNCIA (TOPO) ---
            if (vTotal > 0) {
                const trendStrengthWidth = 200;
                const trendStrengthHeight = 8;
                const trendStrengthX = (width / 2) - (trendStrengthWidth / 2);
                const trendStrengthY = -18; // Posi√ß√£o acima do gr√°fico

                const trendTotal = vRed + vBlack;
                if (trendTotal > 0) {
                    const redStrengthPct = vRed / trendTotal;

                    // T√≠tulo do Indicador
                    const title = document.createElementNS(svgNS, 'text');
                    title.setAttribute('x', width / 2);
                    title.setAttribute('y', trendStrengthY - 4);
                    title.setAttribute('text-anchor', 'middle');
                    title.setAttribute('fill', isLight ? '#666' : '#888');
                    title.setAttribute('font-size', '9px');
                    title.textContent = 'FOR√áA DA TEND√äNCIA (VIS√çVEL)';
                    g.appendChild(title);

                    // Adiciona o clip-path ao defs para bordas arredondadas
                    const clipPath = document.createElementNS(svgNS, 'clipPath');
                    clipPath.id = 'trend-strength-clip';
                    const clipRect = document.createElementNS(svgNS, 'rect');
                    clipRect.setAttribute('x', trendStrengthX);
                    clipRect.setAttribute('y', trendStrengthY);
                    clipRect.setAttribute('width', trendStrengthWidth);
                    clipRect.setAttribute('height', trendStrengthHeight);
                    clipRect.setAttribute('rx', '4');
                    clipPath.appendChild(clipRect);
                    defs.appendChild(clipPath);

                    const clippedGroup = document.createElementNS(svgNS, 'g');
                    clippedGroup.setAttribute('clip-path', 'url(#trend-strength-clip)');
                    g.appendChild(clippedGroup);

                    // Barra de fundo (Preto/Baixa)
                    const blackPart = document.createElementNS(svgNS, 'rect');
                    blackPart.setAttribute('x', trendStrengthX); blackPart.setAttribute('y', trendStrengthY);
                    blackPart.setAttribute('width', trendStrengthWidth); blackPart.setAttribute('height', trendStrengthHeight);
                    blackPart.setAttribute('fill', downColor);
                    clippedGroup.appendChild(blackPart);

                    // Barra sobreposta (Vermelho/Alta)
                    const redPart = document.createElementNS(svgNS, 'rect');
                    redPart.setAttribute('x', trendStrengthX); redPart.setAttribute('y', trendStrengthY);
                    redPart.setAttribute('width', trendStrengthWidth * redStrengthPct); redPart.setAttribute('height', trendStrengthHeight);
                    redPart.setAttribute('fill', upColor);
                    clippedGroup.appendChild(redPart);

                    // √çcone de Dire√ß√£o Dominante e Porcentagem
                    const dominanceValue = Math.max(redStrengthPct, 1 - redStrengthPct);
                    const dominancePctText = `${Math.round(dominanceValue * 100)}%`;
                    const icon = redStrengthPct > 0.5 ? '‚¨ÜÔ∏è' : (redStrengthPct < 0.5 ? '‚¨áÔ∏è' : '‚öñÔ∏è');
                    const dominantColor = redStrengthPct > 0.5 ? upColor : (redStrengthPct < 0.5 ? downColor : '#ffc107');

                    const dirIcon = document.createElementNS(svgNS, 'text');
                    dirIcon.setAttribute('x', trendStrengthX + trendStrengthWidth + 8);
                    dirIcon.setAttribute('y', trendStrengthY + 7);
                    dirIcon.setAttribute('font-size', '10px');
                    dirIcon.innerHTML = `${icon} <tspan font-size="9px" font-weight="bold" fill="${dominantColor}">${dominancePctText}</tspan>`;
                    g.appendChild(dirIcon);
                }
            }

            // --- HIST√ìRICO NO RODAP√â (COR + HORA:MINUTO) ---
            priceData.forEach((d, i) => {
                const x = i * candleSpacing + candleWidth / 2;
                
                // Indicador de Cor (Quadrado)
                let stripColor;
                if (d.color === 'vermelho') stripColor = '#ff0055';
                else if (d.color === 'branco') stripColor = '#ffffff';
                else stripColor = isLight ? '#1a1a1a' : '#666'; // Preto

                const boxSize = 6;
                const rect = document.createElementNS(svgNS, 'rect');
                rect.setAttribute('x', x - boxSize/2);
                rect.setAttribute('y', height + 8);
                rect.setAttribute('width', boxSize);
                rect.setAttribute('height', boxSize);
                rect.setAttribute('fill', stripColor);
                rect.setAttribute('rx', 1);
                g.appendChild(rect);

                // Texto de Hora:Minuto (Espa√ßado)
                const textStep = Math.ceil(45 / candleSpacing); // Evita sobreposi√ß√£o (~45px por label)
                if (i % textStep === 0) {
                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', height + 22);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', isLight ? '#666' : '#888');
                    text.setAttribute('font-size', '9px');
                    text.setAttribute('font-family', digitalFont);
                    // Mostra apenas HH:MM para economizar espa√ßo e atender ao pedido "horario e minuto"
                    text.textContent = d.time.substring(0, 5);
                    g.appendChild(text);
                }
            });

            // Contagem na Linha Amarela (Pre√ßo Atual)
            let countRed = 0, countWhite = 0, countBlack = 0;
            if (priceData.length > 0) {
                const linePrice = priceData[priceData.length - 1].close;
                priceData.forEach(d => {
                    if (d.high >= linePrice && d.low <= linePrice) {
                        if (d.color === 'vermelho') countRed++;
                        else if (d.color === 'branco') countWhite++;
                        else if (d.color === 'preto') countBlack++;
                    }
                });
            }

            const totalCount = countRed + countWhite + countBlack;
            const pctRed = totalCount > 0 ? Math.round((countRed / totalCount) * 100) : 0;
            const pctWhite = totalCount > 0 ? Math.round((countWhite / totalCount) * 100) : 0;
            const pctBlack = totalCount > 0 ? Math.round((countBlack / totalCount) * 100) : 0;

            const statsText = document.createElementNS(svgNS, 'text');
            statsText.setAttribute('x', width / 2);
            statsText.setAttribute('y', height + 45);
            statsText.setAttribute('text-anchor', 'middle');
            statsText.setAttribute('font-size', '12px');
            statsText.setAttribute('font-weight', 'bold');
            statsText.setAttribute('fill', isLight ? '#333' : '#ccc');
            statsText.setAttribute('font-family', digitalFont);
            statsText.innerHTML = `<tspan fill="#ff0055">üî¥ ${countRed} (${pctRed}%)</tspan><tspan dx="20" fill="${isLight ? '#333' : '#fff'}">‚ö™ ${countWhite} (${pctWhite}%)</tspan><tspan dx="20" fill="${isLight ? '#333' : '#aaa'}">‚ö´ ${countBlack} (${pctBlack}%)</tspan>`;
            g.appendChild(statsText);

            // Add drawing overlay and listeners
            const overlay = document.createElementNS(svgNS, 'rect');
            overlay.setAttribute('width', width);
            overlay.setAttribute('height', height);
            overlay.setAttribute('fill', 'transparent');
            g.appendChild(overlay);

            overlay.addEventListener('mousedown', (e) => {
                if (!isDrawMode) return;
                isDrawing = true;
                const rect = overlay.getBoundingClientRect();
                startPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };

                const drawingColor = document.getElementById('drawingColorPicker').value;
                currentLine = document.createElementNS(svgNS, 'line');
                currentLine.setAttribute('x1', startPoint.x);
                currentLine.setAttribute('y1', startPoint.y);
                currentLine.setAttribute('x2', startPoint.x);
                currentLine.setAttribute('y2', startPoint.y);
                currentLine.setAttribute('stroke', drawingColor);
                currentLine.setAttribute('stroke-width', '1.5');
                currentLine.setAttribute('stroke-dasharray', '4,4');
                drawingsGroup.appendChild(currentLine);
            });
            
            // Touch support for drawing
            overlay.addEventListener('touchstart', (e) => {
                if (!isDrawMode) return;
                e.preventDefault();
                const touch = e.touches[0];
                overlay.dispatchEvent(new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY }));
            }, { passive: false });
            overlay.addEventListener('touchmove', (e) => {
                if (!isDrawing) return;
                e.preventDefault();
                const touch = e.touches[0];
                overlay.dispatchEvent(new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY }));
            }, { passive: false });
            overlay.addEventListener('touchend', (e) => {
                if (isDrawing) overlay.dispatchEvent(new MouseEvent('mouseup', {}));
            });

            overlay.addEventListener('mousemove', (e) => {
                if (!isDrawing || !currentLine) return;
                const rect = overlay.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                currentLine.setAttribute('x2', currentX);
                currentLine.setAttribute('y2', currentY);
            });

            overlay.addEventListener('mouseup', () => {
                if (!isDrawing) return;
                
                const drawingColor = document.getElementById('drawingColorPicker').value;
                
                isDrawing = false;
                drawnLines.push({ 
                    x1: parseFloat(currentLine.getAttribute('x1')), 
                    y1: parseFloat(currentLine.getAttribute('y1')), 
                    x2: parseFloat(currentLine.getAttribute('x2')), 
                    y2: parseFloat(currentLine.getAttribute('y2')),
                    color: drawingColor
                });
                currentLine = null;
                updateChart(); // Redraw to make the line permanent
            });

            chartContainer.appendChild(svg);
            
            // Re-append widgets wrapper
            if(historyPanel) chartContainer.appendChild(historyPanel);
            if(ohlcPanel) chartContainer.appendChild(ohlcPanel);
            if(focusBtn) chartContainer.appendChild(focusBtn);
            
            updateMarketStrength(allCandles);
            updateMarketVolatility(allCandles);
            updateMarketTrend(allCandles);
            updateMarketVolatilityRed(allCandles);
            updateMarketVolatilityBlack(allCandles);
            updateSurfProbability(allCandles);

            // Touch support for tooltips (Chart Pan/Scan)
            svg.addEventListener('touchmove', (e) => {
                if (isDrawMode) return; // Let drawing handle it if in draw mode
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.tagName === 'rect' && target.getAttribute('fill') === 'transparent' && target.dataset.roll) {
                    e.preventDefault();
                    const tooltip = document.getElementById('chart-tooltip');
                    tooltip.style.display = 'block';
                    
                    // Position logic
                    let left = touch.clientX + 15;
                    if (left + 120 > window.innerWidth) left = touch.clientX - 135;
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = (touch.clientY + 15) + 'px';

                    const stoneColor = identificarCor(target.dataset.roll);
                    const colorHex = stoneColor === 'vermelho' ? '#ff0055' : (stoneColor === 'preto' ? '#aaa' : '#fff');
                    tooltip.innerHTML = `<div style="margin-bottom:4px; border-bottom:1px solid #444; padding-bottom:2px;"><strong>${target.dataset.time}</strong></div><div>Pedra: <span style="color:${colorHex}; font-weight:bold; font-size:1.1rem;">${target.dataset.roll}</span></div><div>Cor: ${stoneColor.toUpperCase()}</div>`;
                }
            }, { passive: false });
            
            svg.addEventListener('touchend', () => {
                document.getElementById('chart-tooltip').style.display = 'none';
            });
        }

        // Fun√ß√£o auxiliar para disparar a anima√ß√£o de glitch
        function animateValueChange(elementId) {
            const el = document.getElementById(elementId);
            if(el) {
                el.classList.remove('value-update-anim');
                void el.offsetWidth; // for√ßa o reflow para reiniciar a anima√ß√£o
                el.classList.add('value-update-anim');
            }
        }

        function flashWL(elementId, result) { // result can be 'win' or 'loss'
            const el = document.getElementById(elementId);
            if (el) {
                const winClass = 'flash-win-anim';
                const lossClass = 'flash-loss-anim';
                el.classList.remove(winClass, lossClass);
                void el.offsetWidth; // Force reflow
                if (result === 'win') {
                    el.classList.add(winClass);
                } else if (result === 'loss') {
                    el.classList.add(lossClass);
                }
            }
        }

        function updateMarketStrength(data) {
            const widget = document.getElementById('market-strength');
            const showWidgets = document.getElementById('widgetsToggle') ? document.getElementById('widgetsToggle').checked : true;
            
            if (widget) widget.style.display = (showWidgets && data.length >= 5) ? 'flex' : 'none';
            if (data.length < 5) return;

            // Analyze last 20 candles
            const lookback = Math.min(data.length, 20);
            const recent = data.slice(-lookback);
            let redPower = 0, blackPower = 0, whitePower = 0;
            
            recent.forEach(d => {
                if (d.color === 'vermelho') redPower++;
                else if (d.color === 'preto') blackPower++;
                else if (d.color === 'branco') whitePower++;
            });
            
            const total = redPower + blackPower + whitePower;
            if (total === 0) return;

            let strength = 0, color = '#888', icon = '‚ûñ';
            
            if (whitePower > redPower && whitePower > blackPower) {
                strength = (whitePower / total) * 100; color = '#ffffff'; icon = '‚ö™';
            } else if (redPower > blackPower) {
                strength = (redPower / total) * 100; color = '#ff0055'; icon = 'üî¥';
            } else if (blackPower > redPower) {
                strength = (blackPower / total) * 100; color = '#888'; icon = '‚ö´';
            } else {
                strength = 50; color = '#ff9800'; icon = '‚öñÔ∏è';
            }
            
            // Atualiza widget antigo se existir (Preven√ß√£o de Erros)
            if (widget) {
                widget.style.borderColor = color; widget.style.boxShadow = `0 0 15px ${color}33`;
                const fill = document.getElementById('strength-fill');
                const val = document.getElementById('strength-val');
                const iconEl = document.getElementById('strength-icon');
                if(fill) { fill.style.height = `${strength}%`; fill.style.backgroundColor = color; fill.style.boxShadow = `0 0 15px ${color}`; }
                if(val) { val.innerText = `${Math.round(strength)}%`; val.style.color = color; }
                if(iconEl) iconEl.innerText = icon;
            }

            // Update Panel (Nova Aba)
            const pFill = document.getElementById('panel-strength-fill');
            const pVal = document.getElementById('panel-strength-val');
            const pIcon = document.getElementById('panel-strength-icon');
            if(pFill) { pFill.style.width = `${strength}%`; pFill.style.backgroundColor = color; pFill.style.boxShadow = `0 0 10px ${color}`; }
            if(pVal) { 
                pVal.innerText = `${Math.round(strength)}%`; pVal.style.color = color; 
                animateValueChange('panel-strength-val');
            }
            if(pIcon) pIcon.innerText = icon;
        }

        function getTrendSignal(data) {
            if (data.length < 26) return { signal: "NEUTRO", color: "#888", icon: "‚öñÔ∏è" };

            const smaData = calculateSMA(data, 14);
            const lastSMA = smaData[smaData.length - 1];
            const lastClose = data[data.length - 1].close;

            const macdData = calculateMACD(data, 12, 26, 9);
            const lastHist = macdData.histogram[macdData.histogram.length - 1];

            let signal = "NEUTRO";
            let color = "#888";
            let icon = "‚öñÔ∏è";

            if (lastSMA !== null && lastHist !== null) {
                const priceAboveSMA = lastClose > lastSMA;
                const macdBullish = lastHist > 0;

                if (priceAboveSMA && macdBullish) {
                    signal = "VERMELHO"; color = "#ff0055"; icon = "üî¥";
                } else if (!priceAboveSMA && !macdBullish) {
                    signal = "PRETO"; color = "#ffffff"; icon = "‚ö´";
                }
            }
            return { signal, color, icon };
        }

        function triggerTrendAlert(signal) {
            const color = signal === "VERMELHO" ? "rgba(255, 0, 85, 0.3)" : "rgba(255, 255, 255, 0.2)";
            const flash = document.createElement('div');
            Object.assign(flash.style, { position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: color, zIndex: 99999, pointerEvents: 'none', transition: 'opacity 0.5s', opacity: 0 });
            document.body.appendChild(flash);
            requestAnimationFrame(() => { flash.style.opacity = 1; setTimeout(() => { flash.style.opacity = 0; setTimeout(() => flash.remove(), 500); }, 200); });
        }

        function toggleHistory() {
            const panel = document.getElementById('trend-history-panel');
            const checked = document.getElementById('historyToggle').checked;
            if (panel) panel.style.display = checked ? 'flex' : 'none';
        }

        function addToTrendHistory(signal, color, icon) {
            const list = document.getElementById('history-list');
            if (!list) return;

            const now = new Date();
            const timeStr = now.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            // Remove placeholder
            if (list.children.length > 0 && list.children[0].innerText.includes('Aguardando')) list.innerHTML = '';

            const item = document.createElement('li');
            item.className = 'history-item';
            item.innerHTML = `<span class="history-time">${timeStr}</span><span class="history-signal" style="color: ${color}">${icon} ${signal}</span>`;

            list.prepend(item);
            while (list.children.length > 10) list.removeChild(list.lastChild);
        }

        function updateMarketTrend(data) {
            const widget = document.getElementById('market-trend');
            const showWidgets = document.getElementById('widgetsToggle') ? document.getElementById('widgetsToggle').checked : true;
            
            if (widget) widget.style.display = (showWidgets && data.length >= 26) ? 'flex' : 'none';
            if (data.length < 26) return;

            const { signal, color, icon } = getTrendSignal(data);

            // Atualiza widget antigo se existir
            if (widget) {
                const val = document.getElementById('trend-val');
                const iconEl = document.getElementById('trend-icon');
                if(val) { val.innerText = signal; val.style.color = color; }
                if(iconEl) iconEl.innerText = icon;
                widget.style.borderColor = color; widget.style.boxShadow = `0 0 15px ${color}33`;
            }

            // Update Panel (Nova Aba)
            const pVal = document.getElementById('panel-trend-val');
            const pIcon = document.getElementById('panel-trend-icon');
            const pCard = document.getElementById('panel-trend-card');
            if(pVal) { 
                pVal.innerText = signal; pVal.style.color = color; 
                animateValueChange('panel-trend-val');
            }
            if(pIcon) pIcon.innerText = icon;
            if(pCard) pCard.style.borderColor = color;
        }

        function updateMarketVolatility(data) {
            const widget = document.getElementById('market-volatility');
            const showWidgets = document.getElementById('widgetsToggle') ? document.getElementById('widgetsToggle').checked : true;
            
            if (widget) widget.style.display = (showWidgets && data.length >= 20) ? 'flex' : 'none';
            if (data.length < 1) return;

            const lastCandle = data[data.length - 1];
            if (!lastCandle) return;
            const currentTimestamp = lastCandle.timestamp;

            const whiteGaleInput = document.getElementById('whiteGaleAttempts');
            const maxAttempts = whiteGaleInput ? parseInt(whiteGaleInput.value) : 6;
            // Adiciona 1 tentativa extra para a fase de an√°lise
            const totalSequenceSteps = maxAttempts + 1;

            // --- L√ìGICA DE PLACAR ---
            if (predictionState.white.active) {
                if (currentTimestamp > predictionState.white.lastCheckedTimestamp) {
                    predictionState.white.lastCheckedTimestamp = currentTimestamp;
                    if (lastCandle.color === 'branco') {
                        scores.white.wins++;
                        flashWL('wl-counter-white', 'win');
                        predictionState.white.active = false;
                    } else {
                        predictionState.white.attempts++;
                        // Considera derrota apenas ap√≥s passar a fase de an√°lise + tentativas
                        if (predictionState.white.attempts >= totalSequenceSteps) {
                            scores.white.losses++;
                            flashWL('wl-counter-white', 'loss');
                            predictionState.white.active = false;
                        }
                    }
                }
            }
            // --- FIM L√ìGICA DE PLACAR ---

            // --- NOVA L√ìGICA DE AN√ÅLISE DE INTERVALO ---
            const whiteIndices = [];
            data.forEach((candle, index) => {
                if (candle.color === 'branco') {
                    whiteIndices.push(index);
                }
            });

            let volatility = 0;
            let candlesSinceWhite = data.length;
            let avgInterval = 0;
            let isDoubletPattern = false;

            if (whiteIndices.length > 0) {
                candlesSinceWhite = (data.length - 1) - whiteIndices[whiteIndices.length - 1];
            }

            if (whiteIndices.length >= 2) {
                const intervals = [];
                for (let i = 1; i < whiteIndices.length; i++) {
                    intervals.push(whiteIndices[i] - whiteIndices[i - 1]);
                }
                // Pega a m√©dia dos √∫ltimos 5 intervalos para ser mais reativo
                const recentIntervals = intervals.slice(-5);
                avgInterval = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
                
                if (avgInterval > 0) {
                    // A volatilidade agora √© a "proximidade" do pr√≥ximo branco, baseado na m√©dia
                    volatility = (candlesSinceWhite / avgInterval) * 100;
                }

                // --- NOVA L√ìGICA: PROXIMIDADE DO BRANCO ANTERIOR (DOUBLET) ---
                // Analisa se h√° tend√™ncia de brancos saindo pr√≥ximos uns dos outros (<= 12 casas)
                const allRecentIntervals = intervals.slice(-50); // Olha hist√≥rico maior para padr√£o
                const shortIntervals = allRecentIntervals.filter(i => i <= 12);
                
                if (shortIntervals.length > 0) {
                    const shortFreq = shortIntervals.length / allRecentIntervals.length;
                    // Se > 15% dos brancos recentes foram "duplos" ou pr√≥ximos e estamos no in√≠cio
                    if (shortFreq >= 0.15 && candlesSinceWhite <= 15) {
                        const avgShort = shortIntervals.reduce((a, b) => a + b, 0) / shortIntervals.length;
                        
                        // Calcula volatilidade baseada na m√©dia curta
                        let shortVol = (candlesSinceWhite / avgShort) * 100;
                        
                        // Boost baseado na frequ√™ncia (confian√ßa do padr√£o)
                        shortVol *= (0.9 + shortFreq); 

                        // Se ainda estamos numa janela plaus√≠vel para o padr√£o curto (at√© 1.8x a m√©dia curta)
                        if (candlesSinceWhite <= avgShort * 1.8) {
                            if (shortVol > volatility) {
                                volatility = shortVol;
                                isDoubletPattern = true;
                            }
                        }
                    }
                }
            }
            
            // --- NOVA L√ìGICA: SUPORTE E RESIST√äNCIA (S/R) PARA BRANCO ---
            let isSRPattern = false;
            if (data.length > 50) {
                const srLookback = 100; 
                const startIndex = Math.max(0, data.length - srLookback);
                const levels = new Set();
                
                for (let i = startIndex + 2; i < data.length - 2; i++) {
                    const d = data[i];
                    const prev1 = data[i-1]; const prev2 = data[i-2];
                    const next1 = data[i+1]; const next2 = data[i+2];

                    if (d.high > prev1.high && d.high > prev2.high && d.high > next1.high && d.high > next2.high) levels.add(d.high);
                    if (d.low < prev1.low && d.low < prev2.low && d.low < next1.low && d.low < next2.low) levels.add(d.low);
                }
                
                const currentPrice = data[data.length - 1].close;
                for (let level of levels) {
                    if (Math.abs(currentPrice - level) <= 2) {
                        volatility += 30; 
                        isSRPattern = true;
                        break;
                    }
                }
            }

            // Limita a volatilidade para n√£o explodir visualmente
            volatility = Math.min(150, volatility);
            // --- FIM DA NOVA L√ìGICA ---

            // --- WARMUP LOGIC ---
            const warmupInput = document.getElementById('warmupInput');
            const warmupSeconds = warmupInput ? parseInt(warmupInput.value) : 30;
            const warmupDuration = warmupSeconds * 1000;
            const timeSinceLoad = Date.now() - pageLoadTime;
            const isWarmingUp = timeSinceLoad < warmupDuration;
            if (isWarmingUp) {
                volatility = 0;
            }

            const whiteThresholdInput = document.getElementById('volatilityWhiteThreshold');
            const baseThreshold = whiteThresholdInput ? parseInt(whiteThresholdInput.value) : 80;

        // --- NOVA L√ìGICA DE LIMITE DE ALERTA ---

        const alertConditionMet = volatility >= baseThreshold;

        if (currentTimestamp > lastCandleTimestampForWhiteAlert) {
            lastCandleTimestampForWhiteAlert = currentTimestamp;
            if (lastCandle.color === 'branco') {
                whiteAlertConsecutiveCount = 0; // Reseta no branco
            } else if (alertConditionMet) {
                whiteAlertConsecutiveCount++; // Incrementa se a condi√ß√£o for atendida em uma nova vela
            } else {
                whiteAlertConsecutiveCount = 0; // Reseta se a sequ√™ncia de alertas for quebrada
            }
            }

        // Permite contagem at√© maxAttempts + 1 (1 para an√°lise + N tentativas)
        let isWhiteLikely = alertConditionMet && (whiteAlertConsecutiveCount > 0 && whiteAlertConsecutiveCount <= totalSequenceSteps);
        // --- FIM DA NOVA L√ìGICA ---

        // Define a previs√£o para a PR√ìXIMA vela
        if (isWhiteLikely && !predictionState.white.active) {
            predictionState.white.active = true;
            predictionState.white.attempts = 0;
            predictionState.white.lastCheckedTimestamp = currentTimestamp;
        }


        let color = volatility >= 85 ? '#ff0055' : (volatility >= 50 ? '#ff9800' : '#00ff88');
        let icon = volatility >= 85 ? 'üî•' : (volatility >= 50 ? '‚ö†Ô∏è' : '‚ûñ');
        let displayText = `${Math.round(volatility)}%`;
        if (isSRPattern && volatility >= 40) {
             displayText = `üß± ${Math.round(volatility)}%`;
        } else if (isDoubletPattern && volatility >= 40) {
             displayText = `‚ôªÔ∏è ${Math.round(volatility)}%`;
        }
        let displayFontSize = "1.1rem";

        const warmupBarContainer = document.getElementById('warmup-bar-container');
        const warmupBarFill = document.getElementById('warmup-bar-fill');

        if (isWarmingUp) {
            const remaining = Math.ceil((warmupDuration - timeSinceLoad) / 1000);
            displayText = `Calibrando ${remaining}s`;
            color = '#888';
            icon = '‚è≥';
            displayFontSize = "0.7rem";
            
            if (warmupBarContainer && warmupBarFill) {
                warmupBarContainer.style.display = 'block';
                const progress = Math.min(100, (timeSinceLoad / warmupDuration) * 100);
                warmupBarFill.style.width = `${progress}%`;
            }
        } else {
            if (warmupBarContainer) warmupBarContainer.style.display = 'none';
        }

            const alertOverlay = document.getElementById('white-alert-overlay');
            if (isWhiteLikely) {
                color = '#ffffff';
                icon = '‚ö™';
                if (whiteAlertConsecutiveCount === 1) {
                    displayText = "ANALISANDO...";
                    displayFontSize = "0.7rem";
                } else {
                    displayText = `ENTRADA ‚ö™ (${whiteAlertConsecutiveCount - 1}/${maxAttempts})`;
                    displayFontSize = "0.6rem";
                }
            } else {
            // Se o alerta est√° suprimido pelo contador, mostra um status de pausa
            if (alertConditionMet && whiteAlertConsecutiveCount > totalSequenceSteps) {
                color = '#ffc107'; // Amarelo para aviso
                icon = '‚è∏Ô∏è';
                displayText = 'PAUSADO';
                displayFontSize = '0.7rem';
            }
            }

            // Atualiza widget antigo se existir (preven√ß√£o de erros)
            if (widget) {
                const fill = document.getElementById('volatility-fill');
                const val = document.getElementById('volatility-val');
                const iconEl = document.getElementById('volatility-icon');
                if(fill) { fill.style.height = `${Math.min(100, volatility)}%`; fill.style.backgroundColor = color; }
                if(val) { val.innerText = displayText; val.style.color = color; val.style.fontSize = displayFontSize; }
                if(iconEl) iconEl.innerText = icon;
                widget.style.borderColor = color; widget.style.boxShadow = `0 0 15px ${color}33`;
            }

            // Update Panel (Nova Aba)
            const pFill = document.getElementById('panel-volatility-fill');
            const pVal = document.getElementById('panel-volatility-val');
            const pIcon = document.getElementById('panel-volatility-icon');
            if(pFill) { pFill.style.width = `${Math.min(100, volatility)}%`; pFill.style.backgroundColor = color; pFill.style.boxShadow = `0 0 10px ${color}`; }
            if(pVal) { 
                pVal.innerText = displayText; pVal.style.color = color; pVal.style.fontSize = displayFontSize; 
                animateValueChange('panel-volatility-val');
            }
            if(pIcon) pIcon.innerText = icon;

            // Atualiza o contador de velas desde o √∫ltimo branco com a m√©dia
            const counterEl = document.getElementById('last-white-counter');
            if (counterEl) {
                const count = whiteIndices.length > 0 ? candlesSinceWhite : `${data.length}+`;
                let avgText = avgInterval > 0 ? ` / M√©dia: ${avgInterval.toFixed(0)}` : '';
                counterEl.innerHTML = `Velas s/ Branco: <strong style="color: #fff;">${count}</strong><span style="color:#888; font-size:0.9em;">${avgText}</span>`;
            }

            // Atualiza o placar na UI
            const wlCounter = document.getElementById('wl-counter-white');
            if (wlCounter) {
                wlCounter.innerHTML = `<span style="color: #00ff88">W</span>: ${scores.white.wins} - <span style="color: #ff0055">L</span>: ${scores.white.losses}`;
            }

            if (isWhiteLikely && document.getElementById('soundToggle').checked) {
                // Toca som apenas nas entradas reais (pula a fase de an√°lise)
                if (whiteAlertConsecutiveCount > 1) {
                    playWhiteVolatilityAlertSound();
                }
            }
        }

        function updateMarketVolatilityRed(data) {
            if (data.length < 1) return;

            const lastCandle = data[data.length - 1];
            if (!lastCandle) return;
            const currentTimestamp = lastCandle.timestamp;

            // --- L√ìGICA DE PLACAR ---
            if (predictionState.red.wasTriggered) {
                if (currentTimestamp > predictionState.red.triggerTimestamp) {
                    if (lastCandle.color === 'vermelho') {
                        scores.red.wins++;
                        flashWL('wl-counter-red', 'win');
                    } else if (lastCandle.color !== 'branco') { // N√£o conta branco como derrota
                        scores.red.losses++;
                        flashWL('wl-counter-red', 'loss');
                    }
                    predictionState.red.wasTriggered = false; // Consome a previs√£o
                }
            }
            // --- FIM L√ìGICA DE PLACAR ---

            // Conta velas pretas consecutivas a partir do final
            let consecutiveBlacks = 0;
            for (let i = data.length - 1; i >= 0; i--) {
                if (data[i].color === 'preto') {
                    consecutiveBlacks++;
                } else {
                    break; // Para de contar quando encontra uma vela n√£o-preta
                }
            }

            // Normaliza para uma porcentagem (ex: 10 velas = 100%)
            const maxStreak = 6;
            const volatility = Math.min(100, (consecutiveBlacks / maxStreak) * 100);

            // Define a previs√£o para a PR√ìXIMA vela
            if (volatility >= 70 && !predictionState.red.wasTriggered) {
                predictionState.red.wasTriggered = true;
                predictionState.red.triggerTimestamp = currentTimestamp;
            }

            let color = volatility >= 70 ? '#ff0055' : (volatility >= 40 ? '#ff9800' : '#888');
            let icon = volatility >= 70 ? 'üî•' : (volatility >= 40 ? '‚ö†Ô∏è' : '‚ûñ');

            // Atualiza o painel
            const pFill = document.getElementById('panel-volatility-red-fill');
            const pVal = document.getElementById('panel-volatility-red-val');
            const pIcon = document.getElementById('panel-volatility-red-icon');
            const pCounter = document.getElementById('last-red-counter');
            const pWlCounter = document.getElementById('wl-counter-red');

            if(pFill) { pFill.style.width = `${volatility}%`; pFill.style.backgroundColor = color; }
            if(pVal) { 
                pVal.innerText = `${Math.round(volatility)}%`; pVal.style.color = color; 
                animateValueChange('panel-volatility-red-val');
            }
            if(pIcon) pIcon.innerText = icon;
            if(pCounter) {
                pCounter.innerHTML = `Seq. s/ Vermelho: <strong style="color: #fff;">${consecutiveBlacks}</strong>`;
            }
            if(pWlCounter) pWlCounter.innerHTML = `<span style="color: #00ff88">W</span>: ${scores.red.wins} - <span style="color: #ff0055">L</span>: ${scores.red.losses}`;

            if (volatility >= 70 && document.getElementById('soundToggle').checked) {
                playRedVolatilityAlertSound();
            }
        }

        function updateMarketVolatilityBlack(data) {
            if (data.length < 1) return;

            const lastCandle = data[data.length - 1];
            if (!lastCandle) return;
            const currentTimestamp = lastCandle.timestamp;

            // --- L√ìGICA DE PLACAR ---
            if (predictionState.black.wasTriggered) {
                if (currentTimestamp > predictionState.black.triggerTimestamp) {
                    if (lastCandle.color === 'preto') {
                        scores.black.wins++;
                        flashWL('wl-counter-black', 'win');
                    } else if (lastCandle.color !== 'branco') { // N√£o conta branco como derrota
                        scores.black.losses++;
                        flashWL('wl-counter-black', 'loss');
                    }
                    predictionState.black.wasTriggered = false; // Consome a previs√£o
                }
            }
            // --- FIM L√ìGICA DE PLACAR ---

            // Conta velas vermelhas consecutivas a partir do final
            let consecutiveReds = 0;
            for (let i = data.length - 1; i >= 0; i--) {
                if (data[i].color === 'vermelho') {
                    consecutiveReds++;
                } else {
                    break; // Para de contar
                }
            }

            const maxStreak = 6;
            const volatility = Math.min(100, (consecutiveReds / maxStreak) * 100);

            // Define a previs√£o para a PR√ìXIMA vela
            if (volatility >= 70 && !predictionState.black.wasTriggered) {
                predictionState.black.wasTriggered = true;
                predictionState.black.triggerTimestamp = currentTimestamp;
            }

            let color = volatility >= 70 ? '#ccc' : (volatility >= 40 ? '#ff9800' : '#888');
            let icon = volatility >= 70 ? 'üñ§' : (volatility >= 40 ? '‚ö†Ô∏è' : '‚ûñ');

            // Atualiza o painel
            const pFill = document.getElementById('panel-volatility-black-fill');
            const pVal = document.getElementById('panel-volatility-black-val');
            const pIcon = document.getElementById('panel-volatility-black-icon');
            const pCounter = document.getElementById('last-black-counter');
            const pWlCounter = document.getElementById('wl-counter-black');

            if(pFill) { pFill.style.width = `${volatility}%`; pFill.style.backgroundColor = color; }
            if(pVal) { pVal.innerText = `${Math.round(volatility)}%`; pVal.style.color = color; animateValueChange('panel-volatility-black-val'); }
            if(pIcon) pIcon.innerText = icon;
            if(pWlCounter) pWlCounter.innerHTML = `<span style="color: #00ff88">W</span>: ${scores.black.wins} - <span style="color: #ff0055">L</span>: ${scores.black.losses}`;
            if(pCounter) { pCounter.innerHTML = `Seq. s/ Preto: <strong style="color: #fff;">${consecutiveReds}</strong>`; }
            
            if (volatility >= 70 && document.getElementById('soundToggle').checked) {
                playBlackVolatilityAlertSound();
            }
        }

        async function sendTelegramStatusMessage(isActive) {
            const token = localStorage.getItem('telegram_bot_token');
            let chatId = localStorage.getItem('telegram_chat_id_double');
            if (!chatId) chatId = localStorage.getItem('telegram_chat_id');
            
            if (!token || !chatId) {
                console.warn('Token/Chat ID do Telegram n√£o configurado para notifica√ß√£o de status.');
                return;
            }

            let message;
            if (isActive) {
                message = `‚úÖ *ROB√î ATIVADO - OP√á√ïES DOUBLE* ‚úÖ\n\nO envio autom√°tico de sinais foi iniciado.\n\nFique atento √†s pr√≥ximas an√°lises!`;
            } else {
                message = `üõë *ROB√î DESATIVADO - OP√á√ïES DOUBLE* üõë\n\nO envio autom√°tico de sinais foi pausado.`;
            }

            const url = `https://api.telegram.org/bot${token}/sendMessage`;
            
            try {
                const formData = new FormData();
                formData.append('chat_id', chatId);
                formData.append('text', message);
                formData.append('parse_mode', 'Markdown');

                const response = await fetch(url, { method: 'POST', body: formData });
                const data = await response.json();
                if (!data.ok) {
                    console.error('Erro ao enviar mensagem de status:', data.description);
                }
            } catch (e) { console.error("Erro de rede ao enviar mensagem de status:", e); }
        }

        function toggleAutoTg() {
            const btn = document.getElementById('autoTgBtn');
            if (!btn) return;
            const isActive = btn.getAttribute('data-active') === 'true';
            
            if (isActive) {
                btn.setAttribute('data-active', 'false');
                btn.innerText = 'ü§ñ Auto TG: OFF';
                btn.style.borderColor = '#555';
                btn.style.color = '#888';
                btn.style.background = 'rgba(255,255,255,0.05)';
                btn.classList.remove('active');
                localStorage.setItem('auto_tg_state', 'false');
                sendTelegramStatusMessage(false);
            } else {
                btn.setAttribute('data-active', 'true');
                btn.innerText = 'ü§ñ Auto TG: ON';
                btn.style.borderColor = '#00ff88';
                btn.style.color = '#00ff88';
                btn.style.background = 'rgba(0, 255, 136, 0.2)';
                btn.classList.add('active');
                sendTelegramStatusMessage(true);
                localStorage.setItem('auto_tg_state', 'true');
            }
        }

        async function sendTelegramResult(resultType, resultGame) {
            const token = localStorage.getItem('telegram_bot_token');
            let chatId = localStorage.getItem('telegram_chat_id_double');
            if (!chatId) chatId = localStorage.getItem('telegram_chat_id');
            
            if (!token || !chatId) return;

            let text = "";
            if (resultType.startsWith('WIN')) {
                scores.surf.wins++;
                flashWL('wl-counter-surf', 'win');

                if (resultType === 'WIN') text = "‚úÖ‚úÖ‚úÖ GREEN! ‚úÖ‚úÖ‚úÖ";
                else if (resultType === 'WIN_G1') text = "‚úÖ‚úÖ‚úÖ GREEN NO G1! ‚úÖ‚úÖ‚úÖ";
                else if (resultType === 'WIN_G2') text = "‚úÖ‚úÖ‚úÖ GREEN NO G2! ‚úÖ‚úÖ‚úÖ";
                else if (resultType.includes('WHITE')) {
                    text = `‚ö™‚ö™‚ö™ GREEN NO BRANCO! (${resultType.replace('WIN_', '')}) ‚ö™‚ö™‚ö™`;
                    scores.surf.whiteWins++;
                }
            } else if (resultType === 'LOSS') {
                scores.surf.losses++;
                flashWL('wl-counter-surf', 'loss');
                text = "‚ùå‚ùå‚ùå LOSS ‚ùå‚ùå‚ùå";
            }

            const entryTime = new Date(telegramState.originalTriggerTimestamp);
            const timeStr = entryTime.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });

            text += `\n*Hor√°rio da Entrada:* ${timeStr}`;
            
            if (resultGame) {
                const c = identificarCor(resultGame.roll);
                let emoji = '‚ö™';
                if (c === 'vermelho') emoji = 'üî¥';
                if (c === 'preto') emoji = '‚ö´';
                text += `\nüéØ *Pagou:* ${emoji} ${resultGame.roll}`;
            }
            text += `\nüìä *Placar:* ‚úÖ ${scores.surf.wins} vs ${scores.surf.losses} ‚ùå`;
            text += `\nüé≤ *Hist√≥rico:* ${getFormattedHistory()}`;

            if (telegramState.analysisMsg) {
                text += `\n‚ÑπÔ∏è *An√°lise:* ${telegramState.analysisMsg}`;
            }

            const url = `https://api.telegram.org/bot${token}/sendMessage`;
            const formData = new FormData();
            formData.append('chat_id', chatId);
            formData.append('text', text);
            formData.append('parse_mode', 'Markdown');
            try { await fetch(url, { method: 'POST', body: formData }); } catch (e) { console.error("Erro ao enviar resultado:", e); }
        }

        async function sendAutoTelegramSignal(prediction, probability, colorHex, analysisMsg, customTriggerTime) {
            const token = localStorage.getItem('telegram_bot_token');
            let chatId = localStorage.getItem('telegram_chat_id_double');
            if (!chatId) chatId = localStorage.getItem('telegram_chat_id');
            
            if (!token || !chatId) return;

            try {
                const canvas = await generateChartCanvas();
                if (!canvas) return;

                let targetTime;
                if (customTriggerTime) {
                    targetTime = new Date(customTriggerTime);
                } else {
                    // Baseia a hora do sinal no timestamp da vela de an√°lise para sincronia com a apura√ß√£o do resultado.
                    const entryMinuteInput = document.getElementById('autoTelegramEntryMinute');
                    const entryMinute = entryMinuteInput ? parseInt(entryMinuteInput.value) : 1;
                    const analysisTimestamp = allCandles[allCandles.length - 1].timestamp;
                    targetTime = new Date(analysisTimestamp + entryMinute * 60000); // Sinal para N velas (minutos) √† frente da an√°lise.
                }
                const timeStr = targetTime.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                
                let direction = prediction;
                if (prediction.includes('VERMELHO')) direction = "VERMELHO üî¥";
                else if (prediction.includes('PRETO')) direction = "PRETO ‚ö´";
                else if (prediction.includes('‚ö™')) direction = "BRANCO ‚ö™";

                const gestaoText = "At√© G1 (Gale 1)";

                const caption = `
üö® *SINAL DETECTADO - OP√á√ïES DOUBLE* üö®

üìä *Estrat√©gia:* Probabilidade
üïí *Hora:* ${timeStr}

üéØ *Entrada:* ${direction}
üõ°Ô∏è *Prote√ß√£o:* Branco ‚ö™
üìâ *Probabilidade:* ${Math.round(probability)}%
üîÑ *Gest√£o:* ${gestaoText}

üé≤ *Hist√≥rico:* ${getFormattedHistory()}
üìù *An√°lise:* ${analysisMsg}

‚ö†Ô∏è _Gerencie sua banca com responsabilidade._`.trim();

                canvas.toBlob(async function(blob) {
                    const formData = new FormData();
                    formData.append('chat_id', chatId);
                    formData.append('photo', blob, 'sinal_double.png');
                    formData.append('caption', caption);
                    formData.append('parse_mode', 'Markdown');
                    await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, { method: 'POST', body: formData });
                }, 'image/png');
            } catch (e) { console.error("Erro ao enviar sinal auto:", e); }
        }

        function updateSurfProbability(data) {
            if (!data || data.length < 5) return;

            const lastCandle = data[data.length - 1];
            const currentTimestamp = lastCandle.timestamp;

            // --- L√ìGICA DE RESULTADO TELEGRAM ---
            if (telegramState.active && globalGamesData.length > 0) {
                const latestGameTime = new Date(globalGamesData[0].created_at).getTime();

                if (latestGameTime >= telegramState.triggerTimestamp) {
                    // Busca os jogos do minuto alvo
                    const gamesInMinute = globalGamesData.filter(g => {
                        const t = new Date(g.created_at).getTime();
                        return t >= telegramState.triggerTimestamp && t < telegramState.triggerTimestamp + 60000;
                    });

                    if (gamesInMinute.length > 0) {
                        // Ordena do mais antigo para o mais novo: [Pedra 1, Pedra 2]
                        const sortedGames = [...gamesInMinute].sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                        
                        // Pedra 1 (Entrada Principal)
                        const stone1 = sortedGames[0];
                        const color1 = identificarCor(stone1.roll);
                        const isWhite1 = color1 === 'branco';
                        const isWin1 = (color1 === telegramState.predictedColor) || isWhite1;

                        if (isWin1) {
                            // WIN na primeira pedra
                            let type = isWhite1 ? 'WIN_WHITE' : 'WIN';
                            if (telegramState.galeLevel > 0) type += `_G${telegramState.galeLevel}`;
                            
                            sendTelegramResult(type, stone1);
                            
                            predictionState.surf.consecutiveLosses = 0;
                            telegramState.active = false;
                            lastSentSignalTimestamp = latestGameTime + 60000;
                            sendDirectTelegramAnalysis();
                            lastAutoSentTimestamp = Date.now();
                        } else {
                            // LOSS na primeira pedra. Verifica G1 (Pedra 2) se estiver no n√≠vel 0 e maxGales >= 1
                            if (telegramState.galeLevel === 0 && telegramState.maxGales >= 1) {
                                if (sortedGames.length >= 2) {
                                    const stone2 = sortedGames[1];
                                    const color2 = identificarCor(stone2.roll);
                                    const isWhite2 = color2 === 'branco';
                                    const isWin2 = (color2 === telegramState.predictedColor) || isWhite2;

                                    if (isWin2) {
                                        // WIN no G1 (mesmo minuto)
                                        let type = isWhite2 ? 'WIN_WHITE_G1' : 'WIN_G1';
                                        sendTelegramResult(type, stone2);
                                        
                                        predictionState.surf.consecutiveLosses = 0;
                                        telegramState.active = false;
                                        lastSentSignalTimestamp = latestGameTime + 60000;
                                        sendDirectTelegramAnalysis();
                                        lastAutoSentTimestamp = Date.now();
                                    } else {
                                        // LOSS no G1
                                        sendTelegramResult('LOSS', stone2);
                                        predictionState.surf.consecutiveLosses++;
                                        if (predictionState.surf.consecutiveLosses >= 2) {
                                            predictionState.surf.pauseUntil = Date.now() + 20000;
                                            predictionState.surf.consecutiveLosses = 0;
                                        }
                                        telegramState.active = false;
                                        lastSentSignalTimestamp = latestGameTime + 60000;
                                        sendDirectTelegramAnalysis();
                                        lastAutoSentTimestamp = Date.now();
                                    }
                                }
                                // Se n√£o tem 2 pedras ainda, aguarda...
                            } else if (telegramState.galeLevel > 0) {
                                // L√≥gica para G2+ (Minutos seguintes)
                                if (telegramState.galeLevel < telegramState.maxGales) {
                                    telegramState.galeLevel++;
                                    telegramState.triggerTimestamp += 60000;
                                } else {
                                    sendTelegramResult('LOSS', stone1);
                                    predictionState.surf.consecutiveLosses++;
                                    if (predictionState.surf.consecutiveLosses >= 2) {
                                        predictionState.surf.pauseUntil = Date.now() + 20000;
                                        predictionState.surf.consecutiveLosses = 0;
                                    }
                                    telegramState.active = false;
                                    lastSentSignalTimestamp = latestGameTime + 60000;
                                    sendDirectTelegramAnalysis();
                                    lastAutoSentTimestamp = Date.now();
                                }
                            } else {
                                // Sem gale configurado, LOSS na primeira pedra
                                sendTelegramResult('LOSS', stone1);
                                predictionState.surf.consecutiveLosses++;
                                if (predictionState.surf.consecutiveLosses >= 2) {
                                    predictionState.surf.pauseUntil = Date.now() + 20000;
                                    predictionState.surf.consecutiveLosses = 0;
                                }
                                telegramState.active = false;
                                lastSentSignalTimestamp = latestGameTime + 60000;
                                sendDirectTelegramAnalysis();
                                lastAutoSentTimestamp = Date.now();
                            }
                        }
                    }
                }
            }

            // --- L√ìGICA DE PLACAR (UI) ---
            // Esta l√≥gica foi unificada com a L√ìGICA DE RESULTADO TELEGRAM para evitar discrep√¢ncias.
            // O placar da UI (scores.surf) agora √© atualizado dentro da fun√ß√£o sendTelegramResult,
            // que √© chamada apenas quando um resultado final (Win/Loss ap√≥s gales) √© definido.
            // A l√≥gica de pausa por 2 losses seguidos tamb√©m foi movida para o bloco de resultado do Telegram.

            const lastColor = lastCandle.color;
            const isLight = document.body.classList.contains('light-mode');
            
            const pVal = document.getElementById('panel-surf-val');
            const pIcon = document.getElementById('panel-surf-icon');
            const pPct = document.getElementById('panel-surf-pct');
            const pMsg = document.getElementById('surf-message');
            const card = document.getElementById('panel-surf-card');
            const pWlCounter = document.getElementById('wl-counter-surf');

            // --- L√ìGICA DE PAUSA (2 LOSS SEGUIDOS) ---
            if (Date.now() < predictionState.surf.pauseUntil) {
                // Cancela a pausa se sair um branco
                if (lastCandle.color === 'branco') {
                    predictionState.surf.pauseUntil = 0;
                } else {
                    const remaining = Math.ceil((predictionState.surf.pauseUntil - Date.now()) / 1000);
                    if(pVal) { pVal.innerText = "PAUSADO"; pVal.style.color = "#ffc107"; }
                    if(pIcon) pIcon.innerText = "‚è≥";
                    if(pPct) pPct.innerText = "--";
                    if(pMsg) pMsg.innerText = `Recalibrando... ${remaining}s`;
                    if(card) { card.style.borderColor = "#ffc107"; card.style.boxShadow = "none"; }
                    if(pWlCounter) pWlCounter.innerHTML = `<span style="color: #00ff88">W</span>: ${scores.surf.wins} - <span style="color: #ff0055">L</span>: ${scores.surf.losses} <span style="color: #fff; margin-left: 4px;">‚ö™: ${scores.surf.whiteWins}</span>`;
                    return; // Interrompe nova an√°lise
                }
            }
            // --- FIM L√ìGICA DE PAUSA ---

            if (lastColor === 'branco') {
                 if(pVal) { pVal.innerText = "P√ìS-BRANCO"; pVal.style.color = "#00d2ff"; }
                 if(pIcon) pIcon.innerText = "‚ö™";
                 if(pPct) pPct.innerText = "--";
                 if(pMsg) pMsg.innerText = "Aguardando defini√ß√£o...";
                 if(card) { card.style.borderColor = "#00d2ff"; card.style.boxShadow = "none"; }
                 if(pWlCounter) pWlCounter.innerHTML = `<span style="color: #00ff88">W</span>: ${scores.surf.wins} - <span style="color: #ff0055">L</span>: ${scores.surf.losses} <span style="color: #fff; margin-left: 4px;">‚ö™: ${scores.surf.whiteWins}</span>`;
                 return;
            }

            // --- NOVAS ESTRAT√âGIAS (PADR√ïES) ---
            const trendInfo = getTrendSignal(data);
            
            // C√°lculo para Cruzamento SMA (5 e 14)
            const sma5 = calculateSMA(data, 5);
            const sma14 = calculateSMA(data, 14);

            // C√°lculo MACD para confirma√ß√£o
            const macdConf = calculateMACD(data, 12, 26, 9);
            const currentHist = macdConf.histogram.length > 0 ? macdConf.histogram[macdConf.histogram.length - 1] : null;

            // Verifica√ß√£o de Volume (Acima da m√©dia de 20 per√≠odos)
            let isVolumeHigh = false;
            if (data.length >= 20) {
                const avgVol = data.slice(-20).reduce((sum, d) => sum + d.volume, 0) / 20;
                // Se for gr√°fico de tick (volume sempre 1), considera true para n√£o quebrar a estrat√©gia
                if (avgVol === 1 && data[data.length - 1].volume === 1) isVolumeHigh = true;
                else if (data[data.length - 1].volume > avgVol) isVolumeHigh = true;
            }

            // C√°lculo BB para estrat√©gia
            const bbStrat = calculateBollingerBands(data, 20, 2);
            const lastUpper = bbStrat.upper[bbStrat.upper.length - 1];
            const lastLower = bbStrat.lower[bbStrat.lower.length - 1];

            // C√°lculo Stochastic para estrat√©gia
            const stochStrat = calculateStochastic(data, 14, 3, 3);
            let stochPrediction = null;
            if (stochStrat.k.length >= 2 && stochStrat.d.length >= 2) {
                const k = stochStrat.k[stochStrat.k.length - 1];
                const d = stochStrat.d[stochStrat.d.length - 1];
                const pk = stochStrat.k[stochStrat.k.length - 2];
                const pd = stochStrat.d[stochStrat.d.length - 2];
                
                if (k !== null && d !== null && pk !== null && pd !== null) {
                    // Sobrevenda (<20) e Cruzamento de Alta (K cruza D para cima)
                    if (k < 20 && d < 20 && pk <= pd && k > d) stochPrediction = 'VERMELHO';
                    // Sobrecompra (>80) e Cruzamento de Baixa (K cruza D para baixo)
                    else if (k > 80 && d > 80 && pk >= pd && k < d) stochPrediction = 'PRETO';
                }
            }

            let smaCrossPrediction = null;
            if (sma5.length >= 2 && sma14.length >= 2) {
                const lFast = sma5[sma5.length - 1]; const pFast = sma5[sma5.length - 2];
                const lSlow = sma14[sma14.length - 1]; const pSlow = sma14[sma14.length - 2];
                if (lFast !== null && pFast !== null && lSlow !== null && pSlow !== null) {
                    // Confirma√ß√£o com Histograma do MACD (>0 para alta, <0 para baixa) E Volume
                    if (pFast <= pSlow && lFast > lSlow && currentHist !== null && currentHist > 0 && isVolumeHigh) smaCrossPrediction = 'VERMELHO';
                    else if (pFast >= pSlow && lFast < lSlow && currentHist !== null && currentHist < 0 && isVolumeHigh) smaCrossPrediction = 'PRETO';
                }
            }

            let stratPrediction = null;
            let stratProb = 0;
            let stratMsg = "";
            let stratColor = "#888";
            let stratIcon = "‚öñÔ∏è";

            const colors = [];
            for(let i = 0; i < 10; i++) {
                if (data.length - 1 - i >= 0) colors.push(data[data.length - 1 - i].color);
            }

            // 1. Padr√£o Xadrez (Alternado): R B R B -> Predict R (Requer Tend√™ncia Neutra)
            if (colors.length >= 4 && colors[0] !== 'branco' && colors[1] !== 'branco' && colors[2] !== 'branco' && colors[3] !== 'branco' && colors[0] !== colors[1] && colors[1] !== colors[2] && colors[2] !== colors[3] && trendInfo.signal === 'NEUTRO') {
                stratPrediction = colors[0] === 'vermelho' ? 'PRETO' : 'VERMELHO';
                stratProb = 88;
                stratMsg = "Padr√£o Xadrez (Alternado)";
                stratIcon = "‚ôüÔ∏è";
                stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 2. Padr√£o 2x2 (Confirma√ß√£o): R R B -> Predict B
            else if (colors.length >= 3 && colors[0] !== 'branco' && colors[1] !== 'branco' && colors[2] !== 'branco' && colors[0] !== colors[1] && colors[1] === colors[2]) {
                stratPrediction = colors[0] === 'vermelho' ? 'VERMELHO' : 'PRETO';
                stratProb = 85;
                stratMsg = "Padr√£o 2x2 (Confirma√ß√£o)";
                stratIcon = "üë•";
                stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 3. Padr√£o 3x1 (Retorno): R R R B -> Predict R
            else if (colors.length >= 4 && colors[0] !== 'branco' && colors[1] !== 'branco' && colors[2] !== 'branco' && colors[3] !== 'branco' && colors[0] !== colors[1] && colors[1] === colors[2] && colors[2] === colors[3]) {
                stratPrediction = colors[1] === 'vermelho' ? 'VERMELHO' : 'PRETO';
                stratProb = 80;
                stratMsg = "Padr√£o 3x1 (Retorno)";
                stratIcon = "‚Ü©Ô∏è";
                stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 4. Padr√£o Sandu√≠che (1x1x1): R B R -> Predict B
            else if (colors.length >= 3 && colors[0] !== 'branco' && colors[1] !== 'branco' && colors[2] !== 'branco' && colors[0] === colors[2] && colors[0] !== colors[1]) {
                stratPrediction = colors[1] === 'vermelho' ? 'VERMELHO' : 'PRETO';
                stratProb = 82;
                stratMsg = "Padr√£o Sandu√≠che (1x1x1)";
                stratIcon = "ü•™";
                stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 5. Padr√£o Espelho (1x2x1): R B B R -> Predict B
            else if (colors.length >= 4 && colors[0] !== 'branco' && colors[1] !== 'branco' && colors[2] !== 'branco' && colors[3] !== 'branco' && colors[0] === colors[3] && colors[1] === colors[2] && colors[0] !== colors[1]) {
                stratPrediction = colors[1] === 'vermelho' ? 'VERMELHO' : 'PRETO';
                stratProb = 85;
                stratMsg = "Padr√£o Espelho (1x2x1)";
                stratIcon = "ü™û";
                stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 6. Padr√£o 2x2 (Quebra): R R B B -> Predict R
            else if (colors.length >= 4 && colors[0] !== 'branco' && colors[1] !== 'branco' && colors[2] !== 'branco' && colors[3] !== 'branco' && colors[0] === colors[1] && colors[2] === colors[3] && colors[1] !== colors[2]) {
                stratPrediction = colors[2] === 'vermelho' ? 'VERMELHO' : 'PRETO';
                stratProb = 78;
                stratMsg = "Padr√£o 2x2 (Quebra)";
                stratIcon = "‚úÇÔ∏è";
                stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 7. Padr√£o 3x2 (Fluxo): R R R B B -> Predict B (Validar com Tend√™ncia)
            else if (colors.length >= 5 && colors[0] !== 'branco' && colors[1] !== 'branco' && colors[2] !== 'branco' && colors[3] !== 'branco' && colors[4] !== 'branco' && colors[0] === colors[1] && colors[2] === colors[3] && colors[3] === colors[4] && colors[1] !== colors[2]) {
                const potentialPred = colors[0] === 'vermelho' ? 'VERMELHO' : 'PRETO';
                // S√≥ entra se a tend√™ncia n√£o for oposta
                if ((potentialPred === 'VERMELHO' && trendInfo.signal !== 'PRETO') || (potentialPred === 'PRETO' && trendInfo.signal !== 'VERMELHO')) {
                    stratPrediction = potentialPred;
                    stratProb = 76;
                    stratMsg = "Padr√£o 3x2 (Fluxo)";
                    stratIcon = "üåä";
                    stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
                }
            }
            // 8. Padr√£o 5x1 (Retorno): R R R R R B -> Predict R (Validar com Tend√™ncia)
            else if (colors.length >= 6 && colors[0] !== 'branco' && colors[1] !== 'branco' && colors[2] !== 'branco' && colors[3] !== 'branco' && colors[4] !== 'branco' && colors[5] !== 'branco' && colors[0] !== colors[1] && colors[1] === colors[2] && colors[2] === colors[3] && colors[3] === colors[4] && colors[4] === colors[5]) {
                const potentialPred = colors[1] === 'vermelho' ? 'VERMELHO' : 'PRETO';
                if ((potentialPred === 'VERMELHO' && trendInfo.signal !== 'PRETO') || (potentialPred === 'PRETO' && trendInfo.signal !== 'VERMELHO')) {
                    stratPrediction = potentialPred;
                    stratProb = 88;
                    stratMsg = "Padr√£o 5x1 (Retorno)";
                    stratIcon = "üîô";
                    stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
                }
            }
            // 9. Estrat√©gia de Tend√™ncia (Trend Follow): Trend Signal + 2 Candles Confirmation
            else if (colors.length >= 2 && trendInfo.signal !== "NEUTRO" && colors[0] === trendInfo.signal.toLowerCase() && colors[1] === trendInfo.signal.toLowerCase()) {
                stratPrediction = trendInfo.signal;
                stratProb = 92;
                stratMsg = `Tend√™ncia Confirmada ${trendInfo.icon}`;
                stratIcon = "üöÄ";
                stratColor = trendInfo.signal === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 10. Estrat√©gia Cruzamento SMA (5/14)
            else if (smaCrossPrediction) {
                stratPrediction = smaCrossPrediction;
                stratProb = 91;
                stratMsg = `Cruzamento SMA 5/14 + MACD + Vol`;
                stratIcon = smaCrossPrediction === 'VERMELHO' ? "üìà" : "üìâ";
                stratColor = smaCrossPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 13. Estrat√©gia Combinada: BB + Estoc√°stico (Alta Precis√£o)
            else if (stochPrediction === 'VERMELHO' && lastLower !== null && lastCandle.close <= lastLower) {
                stratPrediction = 'VERMELHO'; stratProb = 94; stratMsg = "BB + Estoc√°stico (Super Revers√£o)"; stratIcon = "üíé"; stratColor = '#ff0055';
            }
            else if (stochPrediction === 'PRETO' && lastUpper !== null && lastCandle.close >= lastUpper) {
                stratPrediction = 'PRETO'; stratProb = 94; stratMsg = "BB + Estoc√°stico (Super Revers√£o)"; stratIcon = "üíé"; stratColor = (isLight ? '#333' : '#fff');
            }
            // 11. Estrat√©gia Rompimento BB (Revers√£o)
            else if (lastUpper !== null && lastLower !== null && (lastCandle.close > lastUpper || lastCandle.close < lastLower)) {
                if (lastCandle.close > lastUpper) {
                    stratPrediction = 'PRETO'; stratProb = 87; stratMsg = "Rompimento BB (Revers√£o)"; stratIcon = "üìâ";
                    stratColor = (isLight ? '#333' : '#fff');
                } else {
                    stratPrediction = 'VERMELHO'; stratProb = 87; stratMsg = "Rompimento BB (Revers√£o)"; stratIcon = "üìà";
                    stratColor = '#ff0055';
                }
            }
            // 12. Estrat√©gia Estoc√°stico (Revers√£o)
            else if (stochPrediction) {
                stratPrediction = stochPrediction;
                stratProb = 88;
                stratMsg = "Estoc√°stico (Revers√£o)";
                stratIcon = stochPrediction === 'VERMELHO' ? "üìà" : "üìâ";
                stratColor = stochPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
            }
            // 4. Maioria M5 (For√ßa): 4/5 same color -> Predict Same (Validar com Tend√™ncia)
            else if (colors.length >= 5) {
                let r = 0, b = 0;
                for(let i=0; i<5; i++) { if(colors[i] === 'vermelho') r++; else if(colors[i] === 'preto') b++; }
                if (r >= 4 && colors[0] === 'vermelho' && trendInfo.signal === 'VERMELHO') {
                    stratPrediction = 'VERMELHO'; stratProb = 75; stratMsg = "Maioria M5 (For√ßa)"; stratIcon = "üí™"; stratColor = '#ff0055';
                } else if (b >= 4 && colors[0] === 'preto' && trendInfo.signal === 'PRETO') {
                    stratPrediction = 'PRETO'; stratProb = 75; stratMsg = "Maioria M5 (For√ßa)"; stratIcon = "üí™"; stratColor = (isLight ? '#333' : '#fff');
                }
            }
            // 5. Quebra de Sequ√™ncia (Revers√£o): 6+ same -> Predict Opposite
            if (!stratPrediction) {
                 let streak = 1;
                 for(let i=1; i<colors.length; i++) { if(colors[i] === colors[0]) streak++; else break; }
                 if (streak >= 6 && colors[0] !== 'branco') {
                    stratPrediction = colors[0] === 'vermelho' ? 'PRETO' : 'VERMELHO'; stratProb = Math.min(95, 60 + (streak * 5)); stratMsg = `Revers√£o de Sequ√™ncia (${streak}x)`; stratIcon = "üîÑ"; stratColor = stratPrediction === 'VERMELHO' ? '#ff0055' : (isLight ? '#333' : '#fff');
                 }
            }

            let currentStreak = 0;
            for (let i = data.length - 1; i >= 0; i--) {
                if (data[i].color === lastColor) currentStreak++;
                else break;
            }

            let continueCount = 0;
            let oppositeCount = 0;
            let whiteCount = 0;
            const startIndex = Math.max(0, data.length - 1000);
            
            for (let i = startIndex; i < data.length - 1; i++) {
                if (data[i].color !== lastColor) continue;
                let isStreak = true;
                for (let k = 0; k < currentStreak; k++) {
                    if (i - k < 0 || data[i - k].color !== lastColor) {
                        isStreak = false;
                        break;
                    }
                }
                if (isStreak) {
                    const nextColor = data[i+1].color;
                    if (nextColor === lastColor) continueCount++;
                    else if (nextColor === 'branco') whiteCount++;
                    else oppositeCount++;
                }
            }

            const total = continueCount + oppositeCount + whiteCount;
            let prediction = "NEUTRO";
            let prob = 0;
            let icon = "‚öñÔ∏è";
            let msg = "Dados insuficientes";
            let color = "#888";

            if (stratPrediction) {
                prediction = stratPrediction;
                prob = stratProb;
                msg = stratMsg;
                color = stratColor;
                icon = stratIcon;
            } else if (total > 0 && currentStreak > 4) {
                const continuePct = (continueCount / total) * 100;
                const oppositePct = (oppositeCount / total) * 100;
                const whitePct = (whiteCount / total) * 100;
                
                if (whitePct >= 20) {
                    prediction = "POSS√çVEL ‚ö™";
                    prob = whitePct;
                    icon = "‚ö™";
                    color = "#00d2ff";
                    msg = "Padr√£o de Branco Detectado";
                } else if (continuePct >= oppositePct) {
                    prediction = lastColor === 'vermelho' ? 'VERMELHO' : 'PRETO';
                    prob = continuePct;
                    icon = lastColor === 'vermelho' ? 'üî¥' : '‚ö´';
                    color = lastColor === 'vermelho' ? '#ff0055' : (isLight ? '#333' : '#fff');
                    msg = `Surf: Alta Probabilidade`;
                    if (whitePct >= 10) msg += ` (Proteja ‚ö™)`;
                } else {
                    prediction = lastColor === 'vermelho' ? 'PRETO' : 'VERMELHO';
                    prob = oppositePct;
                    icon = lastColor === 'vermelho' ? '‚ö´' : 'üî¥';
                    color = lastColor === 'vermelho' ? (isLight ? '#333' : '#fff') : '#ff0055';
                    msg = `Revers√£o: Alta Probabilidade`;
                    if (whitePct >= 10) msg += ` (Proteja ‚ö™)`;
                }
            }

            // Filtro de Tend√™ncia para Probabilidade Gen√©rica (Se n√£o for estrat√©gia espec√≠fica)
            if (prediction !== "NEUTRO" && !prediction.includes('‚ö™') && !stratPrediction) {
                if (prediction === 'VERMELHO' && trendInfo.signal === 'PRETO') {
                    prediction = "NEUTRO"; msg = "Filtro de Tend√™ncia (Contra)";
                } else if (prediction === 'PRETO' && trendInfo.signal === 'VERMELHO') {
                    prediction = "NEUTRO"; msg = "Filtro de Tend√™ncia (Contra)";
                }
            }

            // Define a previs√£o para a PR√ìXIMA vela
            if (total > 0) {
                if (prediction.includes('‚ö™')) {
                    predictionState.surf.predictedColor = 'branco';
                } else {
                    predictionState.surf.predictedColor = prediction.toLowerCase();
                }

                // Verifica√ß√£o de RSI Saturado (Filtro de Seguran√ßa)
                const rsiSeries = calculateRSI(data, 14);
                const currentRSI = rsiSeries[rsiSeries.length - 1];
                let isRsiSafe = true;
                if (currentRSI !== null) {
                    if (prediction.includes('VERMELHO') && currentRSI >= 70) isRsiSafe = false; // Evita comprar no topo
                    if (prediction.includes('PRETO') && currentRSI <= 30) isRsiSafe = false; // Evita vender no fundo
                }
                if (!isRsiSafe) msg += " | ‚ö†Ô∏è RSI Saturado";

                const autoTgBtn = document.getElementById('autoTgBtn');
                const isAutoTgOn = autoTgBtn && autoTgBtn.getAttribute('data-active') === 'true';
                const minProbInput = document.getElementById('autoTelegramMinProbability');
                const maxProbInput = document.getElementById('autoTelegramMaxProbability');
                const minProb = minProbInput ? parseInt(minProbInput.value) : 75;
                const maxProb = maxProbInput ? parseInt(maxProbInput.value) : 95;
                const entryMinuteInput = document.getElementById('autoTelegramEntryMinute');
                const entryMinute = entryMinuteInput ? parseInt(entryMinuteInput.value) : 1;

                if (isAutoTgOn && !telegramState.active && prediction !== "NEUTRO" && currentTimestamp > lastSentSignalTimestamp && prob >= minProb && prob <= maxProb && isRsiSafe) {
                    // O sinal √© para N velas √† frente (N min) para dar tempo de entrada.
                    // Garante que o sinal seja para o minuto completo √† frente. Ex: An√°lise √†s 19:00 + 1min -> Sinal para 19:01.
                    const triggerTimestamp = Math.floor((currentTimestamp + (entryMinute * 60000)) / 60000) * 60000;
                    
                    sendAutoTelegramSignal(prediction, prob, color, msg, triggerTimestamp);
                    lastSentSignalTimestamp = currentTimestamp;
                    
                    telegramState.active = true;
                    telegramState.predictedColor = predictionState.surf.predictedColor;
                    telegramState.triggerTimestamp = triggerTimestamp;
                    telegramState.originalTriggerTimestamp = triggerTimestamp;
                    telegramState.galeLevel = 0;
                    telegramState.maxGales = 1;
                    telegramState.analysisMsg = msg;
                }
            }

            if(pVal) { 
                pVal.innerText = prediction; 
                pVal.style.color = color;
                animateValueChange('panel-surf-val');
            }
            if(pIcon) pIcon.innerText = icon;
            if(pPct) pPct.innerText = `${Math.round(prob)}%`;
            if(pMsg) pMsg.innerText = msg;
            if(pWlCounter) pWlCounter.innerHTML = `<span style="color: #00ff88">W</span>: ${scores.surf.wins} - <span style="color: #ff0055">L</span>: ${scores.surf.losses} <span style="color: #fff; margin-left: 4px;">‚ö™: ${scores.surf.whiteWins}</span>`;
            if(card) {
                card.style.borderColor = color;
                card.style.boxShadow = `0 0 10px ${color}33`;
            }
        }

        function drawRSIChart(priceData) {
            const rsiContainer = document.getElementById('rsi-container');
            const showRSI = document.getElementById('rsiToggle').checked;
            
            if (!showRSI) {
                rsiContainer.style.display = 'none';
                return;
            }
            rsiContainer.style.display = 'block';
            rsiContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');

            const rsiPeriodInput = document.getElementById('rsiPeriodInput');
            const rsiPeriod = rsiPeriodInput ? parseInt(rsiPeriodInput.value) : 14;

            const rsiValues = calculateRSI(priceData, rsiPeriod);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = rsiContainer.clientWidth;
            const height = rsiContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Background lines for 30 and 70
            const y70 = plotHeight * (1 - 0.7);
            const y30 = plotHeight * (1 - 0.3);
            
            const line70 = document.createElementNS(svgNS, 'line');
            line70.setAttribute('x1', 0); line70.setAttribute('y1', y70);
            line70.setAttribute('x2', plotWidth); line70.setAttribute('y2', y70);
            line70.setAttribute('stroke', '#ff0055'); line70.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(line70);

            const line30 = document.createElementNS(svgNS, 'line');
            line30.setAttribute('x1', 0); line30.setAttribute('y1', y30);
            line30.setAttribute('x2', plotWidth); line30.setAttribute('y2', y30);
            line30.setAttribute('stroke', '#00ff88'); line30.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(line30);

            // Draw RSI Line
            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);
            
            let pathD = "";
            rsiValues.forEach((val, i) => {
                if (val !== null) {
                    const x = i * candleSpacing + candleWidth / 2;
                    const y = plotHeight * (1 - (val / 100));
                    if (pathD === "") pathD = `M ${x} ${y}`;
                    else pathD += ` L ${x} ${y}`;
                }
            });

            if (pathD !== "") {
                const path = document.createElementNS(svgNS, 'path');
                path.setAttribute('d', pathD);
                path.setAttribute('stroke', '#a100ff'); path.classList.add('indicator-line');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                g.appendChild(path);
            }
            
            // Add label
            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', '#a100ff'); label.setAttribute('font-size', '10px');
            label.textContent = `RSI (${rsiPeriod})`;
            svg.appendChild(label);

            rsiContainer.appendChild(svg);
        }

        function drawMACDChart(priceData) {
            const macdContainer = document.getElementById('macd-container');
            const showMACD = document.getElementById('macdToggle').checked;
            
            if (!showMACD) {
                macdContainer.style.display = 'none';
                return;
            }
            macdContainer.style.display = 'block';
            macdContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');

            const fastInput = document.getElementById('macdFastInput');
            const slowInput = document.getElementById('macdSlowInput');
            const signalInput = document.getElementById('macdSignalInput');
            
            const fastPeriod = fastInput ? parseInt(fastInput.value) : 12;
            const slowPeriod = slowInput ? parseInt(slowInput.value) : 26;
            const signalPeriod = signalInput ? parseInt(signalInput.value) : 9;

            const macdData = calculateMACD(priceData, fastPeriod, slowPeriod, signalPeriod);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = macdContainer.clientWidth;
            const height = macdContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const allValues = [].concat(macdData.macdLine, macdData.signalLine, macdData.histogram).filter(v => v !== null);
            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            const range = maxVal - minVal;

            const y = (val) => plotHeight - ((val - minVal) / range) * plotHeight;

            // Draw zero line
            const zeroY = y(0);
            const zeroLine = document.createElementNS(svgNS, 'line');
            zeroLine.setAttribute('x1', 0); zeroLine.setAttribute('y1', zeroY);
            zeroLine.setAttribute('x2', plotWidth); zeroLine.setAttribute('y2', zeroY);
            zeroLine.setAttribute('stroke', isLight ? '#ccc' : '#555'); zeroLine.setAttribute('stroke-dasharray', '2,2');
            g.appendChild(zeroLine);

            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);

            // Draw Histogram
            macdData.histogram.forEach((val, i) => {
                if (val !== null) {
                    const x = i * candleSpacing;
                    const barHeight = Math.abs(y(val) - zeroY);
                    const barY = val > 0 ? y(val) : zeroY;
                    
                    const bar = document.createElementNS(svgNS, 'rect');
                    bar.setAttribute('x', x); bar.setAttribute('y', barY);
                    bar.setAttribute('width', candleWidth); bar.setAttribute('height', barHeight);
                    bar.setAttribute('fill', val > 0 ? 'rgba(0, 255, 136, 0.5)' : 'rgba(255, 0, 85, 0.5)');
                    g.appendChild(bar);
                }
            });

            // Helper to draw line
            const drawLine = (data, color) => {
                let pathD = "";
                data.forEach((val, i) => { if (val !== null) { const x = i * candleSpacing + candleWidth / 2; const yVal = y(val); if (pathD === "") pathD = `M ${x} ${yVal}`; else pathD += ` L ${x} ${yVal}`; } });
                if (pathD !== "") { const path = document.createElementNS(svgNS, 'path'); path.setAttribute('d', pathD); path.setAttribute('stroke', color); path.setAttribute('stroke-width', '2'); path.setAttribute('fill', 'none'); path.classList.add('indicator-line'); g.appendChild(path); }
            };

            drawLine(macdData.macdLine, '#00d2ff');
            drawLine(macdData.signalLine, '#ff9800');

            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', isLight ? '#666' : '#ccc'); label.setAttribute('font-size', '10px');
            label.innerHTML = `<tspan fill="#00d2ff">MACD(${fastPeriod},${slowPeriod})</tspan> <tspan fill="#ff9800">Signal(${signalPeriod})</tspan>`;
            svg.appendChild(label);

            macdContainer.appendChild(svg);
        }

        function drawMACDChart(priceData) {
            const macdContainer = document.getElementById('macd-container');
            const showMACD = document.getElementById('macdToggle').checked;
            
            if (!showMACD) {
                macdContainer.style.display = 'none';
                return;
            }
            macdContainer.style.display = 'block';
            macdContainer.innerHTML = '';

            const fastInput = document.getElementById('macdFastInput');
            const slowInput = document.getElementById('macdSlowInput');
            const signalInput = document.getElementById('macdSignalInput');
            
            const fastPeriod = fastInput ? parseInt(fastInput.value) : 12;
            const slowPeriod = slowInput ? parseInt(slowInput.value) : 26;
            const signalPeriod = signalInput ? parseInt(signalInput.value) : 9;

            const macdData = calculateMACD(priceData, fastPeriod, slowPeriod, signalPeriod);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = macdContainer.clientWidth;
            const height = macdContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const allValues = [].concat(macdData.macdLine, macdData.signalLine, macdData.histogram).filter(v => v !== null);
            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            const range = maxVal - minVal;

            const y = (val) => plotHeight - ((val - minVal) / range) * plotHeight;

            // Draw zero line
            const zeroY = y(0);
            const zeroLine = document.createElementNS(svgNS, 'line');
            zeroLine.setAttribute('x1', 0); zeroLine.setAttribute('y1', zeroY);
            zeroLine.setAttribute('x2', plotWidth); zeroLine.setAttribute('y2', zeroY);
            zeroLine.setAttribute('stroke', '#555'); zeroLine.setAttribute('stroke-dasharray', '2,2');
            g.appendChild(zeroLine);

            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);

            // Draw Histogram
            macdData.histogram.forEach((val, i) => {
                if (val !== null) {
                    const x = i * candleSpacing;
                    const barHeight = Math.abs(y(val) - zeroY);
                    const barY = val > 0 ? y(val) : zeroY;
                    
                    const bar = document.createElementNS(svgNS, 'rect');
                    bar.setAttribute('x', x); bar.setAttribute('y', barY);
                    bar.setAttribute('width', candleWidth); bar.setAttribute('height', barHeight);
                    bar.setAttribute('fill', val > 0 ? 'rgba(0, 255, 136, 0.5)' : 'rgba(255, 0, 85, 0.5)');
                    g.appendChild(bar);
                }
            });

            // Helper to draw line
            const drawLine = (data, color) => {
                let pathD = "";
                data.forEach((val, i) => { if (val !== null) { const x = i * candleSpacing + candleWidth / 2; const yVal = y(val); if (pathD === "") pathD = `M ${x} ${yVal}`; else pathD += ` L ${x} ${yVal}`; } });
                if (pathD !== "") { const path = document.createElementNS(svgNS, 'path'); path.setAttribute('d', pathD); path.setAttribute('stroke', color); path.setAttribute('stroke-width', '2'); path.setAttribute('fill', 'none'); g.appendChild(path); }
            };

            drawLine(macdData.macdLine, '#00d2ff'); // MACD line in blue
            drawLine(macdData.signalLine, '#ff9800'); // Signal line in orange

            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', '#ccc'); label.setAttribute('font-size', '10px');
            label.innerHTML = `<tspan fill="#00d2ff">MACD(${fastPeriod},${slowPeriod})</tspan> <tspan fill="#ff9800">Signal(${signalPeriod})</tspan>`;
            svg.appendChild(label);

            macdContainer.appendChild(svg);
        }

        function drawVolumeChart(priceData) {
            const volumeContainer = document.getElementById('volume-container');
            const showVolume = document.getElementById('volumeToggle').checked;
            
            if (!showVolume) {
                volumeContainer.style.display = 'none';
                return;
            }
            volumeContainer.style.display = 'block';
            volumeContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');
            
            const upColor = document.getElementById('candleUpColor') ? document.getElementById('candleUpColor').value : '#ff0055';
            const downColor = document.getElementById('candleDownColor') ? document.getElementById('candleDownColor').value : '#343a40';

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = volumeContainer.clientWidth;
            const height = volumeContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 5, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const maxVol = Math.max(...priceData.map(d => d.volume));
            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);

            priceData.forEach((d, i) => {
                const x = i * candleSpacing;
                const barHeight = (d.volume / maxVol) * plotHeight;
                const y = plotHeight - barHeight;
                
                const bar = document.createElementNS(svgNS, 'rect');
                bar.setAttribute('x', x); bar.setAttribute('y', y);
                bar.setAttribute('width', candleWidth); bar.setAttribute('height', barHeight);
                
                let barColor;
                if (d.color === 'vermelho') barColor = upColor;
                else if (d.color === 'preto') barColor = downColor;
                else barColor = '#ffc107';
                
                bar.setAttribute('fill', barColor); bar.setAttribute('fill-opacity', '0.5');
                g.appendChild(bar);
            });
            
            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', isLight ? '#666' : '#ccc'); label.setAttribute('font-size', '10px');
            label.textContent = `Volume (Max: ${maxVol})`;
            svg.appendChild(label);
            volumeContainer.appendChild(svg);
        }

        function drawADXChart(priceData) {
            const adxContainer = document.getElementById('adx-container');
            const showADX = document.getElementById('adxToggle').checked;
            
            if (!showADX) {
                adxContainer.style.display = 'none';
                return;
            }
            adxContainer.style.display = 'block';
            adxContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');

            const adxData = calculateADX(priceData, 14);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = adxContainer.clientWidth;
            const height = adxContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const allValues = [].concat(adxData.adx, adxData.plusDI, adxData.minusDI).filter(v => v !== null && v >= 0 && v <= 100);
            const y = (val) => plotHeight - (val / 100) * plotHeight;

            // Draw reference line at 25
            const line25 = document.createElementNS(svgNS, 'line');
            line25.setAttribute('x1', 0); line25.setAttribute('y1', y(25));
            line25.setAttribute('x2', plotWidth); line25.setAttribute('y2', y(25));
            line25.setAttribute('stroke', isLight ? '#ccc' : '#555'); line25.setAttribute('stroke-dasharray', '2,2');
            g.appendChild(line25);

            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);

            // Helper to draw line
            const drawLine = (data, color) => {
                let pathD = "";
                data.forEach((val, i) => {
                    if (val !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(val);
                        if (pathD === "") pathD = `M ${x} ${yVal}`;
                        else pathD += ` L ${x} ${yVal}`;
                    }
                });
                if (pathD !== "") {
                    const path = document.createElementNS(svgNS, 'path');
                    path.setAttribute('d', pathD); path.classList.add('indicator-line');
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    g.appendChild(path);
                }
            };

            drawLine(adxData.plusDI, '#00ff88');
            drawLine(adxData.minusDI, '#ff0055');
            drawLine(adxData.adx, '#ffc107');

            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', isLight ? '#666' : '#ccc'); label.setAttribute('font-size', '10px');
            label.innerHTML = `<tspan fill="#ffc107">ADX(14)</tspan> <tspan fill="#00ff88">+DI</tspan> <tspan fill="#ff0055">-DI</tspan>`;
            svg.appendChild(label);

            adxContainer.appendChild(svg);
        }

        function drawStochasticChart(priceData) {
            const stochContainer = document.getElementById('stoch-container');
            const showStoch = document.getElementById('stochToggle').checked;
            
            if (!showStoch) { stochContainer.style.display = 'none'; return; }
            stochContainer.style.display = 'block';
            stochContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');

            const kInput = document.getElementById('stochKInput');
            const dInput = document.getElementById('stochDInput');
            const smoothInput = document.getElementById('stochSmoothInput');
            const periodK = kInput ? parseInt(kInput.value) : 14;
            const periodD = dInput ? parseInt(dInput.value) : 3;
            const smooth = smoothInput ? parseInt(smoothInput.value) : 3;

            const stochData = calculateStochastic(priceData, periodK, periodD, smooth);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = stochContainer.clientWidth;
            const height = stochContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width); svg.setAttribute('height', height);
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const y80 = plotHeight * (1 - 0.8);
            const y20 = plotHeight * (1 - 0.2);
            
            const line80 = document.createElementNS(svgNS, 'line');
            line80.setAttribute('x1', 0); line80.setAttribute('y1', y80); line80.setAttribute('x2', plotWidth); line80.setAttribute('y2', y80);
            line80.setAttribute('stroke', '#ff0055'); line80.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(line80);

            const line20 = document.createElementNS(svgNS, 'line');
            line20.setAttribute('x1', 0); line20.setAttribute('y1', y20); line20.setAttribute('x2', plotWidth); line20.setAttribute('y2', y20);
            line20.setAttribute('stroke', '#00ff88'); line20.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(line20);

            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);
            
            const drawLine = (data, color) => {
                let pathD = "";
                data.forEach((val, i) => { if (val !== null) { const x = i * candleSpacing + candleWidth / 2; const y = plotHeight * (1 - (val / 100)); const clampedY = Math.max(0, Math.min(plotHeight, y)); if (pathD === "") pathD = `M ${x} ${clampedY}`; else pathD += ` L ${x} ${clampedY}`; } });
                if (pathD !== "") { const path = document.createElementNS(svgNS, 'path'); path.setAttribute('d', pathD); path.setAttribute('stroke', color); path.setAttribute('stroke-width', '1.5'); path.setAttribute('fill', 'none'); g.appendChild(path); }
            };

            drawLine(stochData.k, '#00d2ff');
            drawLine(stochData.d, '#ff9800');
            
            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15); label.setAttribute('fill', isLight ? '#666' : '#ccc'); label.setAttribute('font-size', '10px');
            label.innerHTML = `<tspan fill="#00d2ff">%K(${periodK},${smooth})</tspan> <tspan fill="#ff9800">%D(${periodD})</tspan>`;
            svg.appendChild(label);
            stochContainer.appendChild(svg);
        }

        async function generateChartCanvas() {
            const mainChartContainer = document.getElementById('chart-container');
            const rsiContainer = document.getElementById('rsi-container');
            const macdContainer = document.getElementById('macd-container');
            const volumeContainer = document.getElementById('volume-container');
            const adxContainer = document.getElementById('adx-container');
            const stochContainer = document.getElementById('stoch-container');

            const mainChartSVG = mainChartContainer.querySelector('svg');
            const rsiSVG = rsiContainer.querySelector('svg');
            const macdSVG = macdContainer.querySelector('svg');
            const volumeSVG = volumeContainer.querySelector('svg');
            const adxSVG = adxContainer.querySelector('svg');
            const stochSVG = stochContainer.querySelector('svg');

            if (!mainChartSVG) {
                return null;
            }

            const isLight = document.body.classList.contains('light-mode');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            let totalHeight = mainChartContainer.offsetHeight;
            if (adxSVG && adxContainer.style.display !== 'none') totalHeight += adxContainer.offsetHeight + 10;
            if (rsiSVG && rsiContainer.style.display !== 'none') totalHeight += rsiContainer.offsetHeight + 10;
            if (macdSVG && macdContainer.style.display !== 'none') totalHeight += macdContainer.offsetHeight + 10;
            if (volumeSVG && volumeContainer.style.display !== 'none') totalHeight += volumeContainer.offsetHeight + 10;
            if (stochSVG && stochContainer.style.display !== 'none') totalHeight += stochContainer.offsetHeight + 10;

            canvas.width = mainChartContainer.offsetWidth;
            canvas.height = totalHeight;

            // Preenche o fundo
            ctx.fillStyle = isLight ? '#ffffff' : '#0c1014'; // Cor de fundo do painel
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const drawSVGToCanvas = (svgElement, yOffset) => {
                return new Promise((resolve) => {
                    const svgString = new XMLSerializer().serializeToString(svgElement);
                    const img = new Image();
                    const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);

                    img.onload = function () {
                        ctx.drawImage(img, 0, yOffset);
                        URL.revokeObjectURL(url);
                        resolve();
                    };
                    img.src = url;
                });
            };

            await drawSVGToCanvas(mainChartSVG, 0);
            let currentYOffset = mainChartContainer.offsetHeight + 10;
            if (volumeSVG && volumeContainer.style.display !== 'none') { await drawSVGToCanvas(volumeSVG, currentYOffset); currentYOffset += volumeContainer.offsetHeight + 10; }
            if (adxSVG && adxContainer.style.display !== 'none') { await drawSVGToCanvas(adxSVG, currentYOffset); currentYOffset += adxContainer.offsetHeight + 10; }
            if (rsiSVG && rsiContainer.style.display !== 'none') { await drawSVGToCanvas(rsiSVG, currentYOffset); currentYOffset += rsiContainer.offsetHeight + 10; }
            if (macdSVG && macdContainer.style.display !== 'none') { await drawSVGToCanvas(macdSVG, currentYOffset); }
            if (stochSVG && stochContainer.style.display !== 'none') { await drawSVGToCanvas(stochSVG, currentYOffset); }

            return canvas;
        }

        function identifyCandlePattern(candles) {
            if (!candles || candles.length < 2) return "N/A";
            const last = candles[candles.length - 1];
            const prev = candles[candles.length - 2];

            const body = Math.abs(last.close - last.open);
            const total = last.high - last.low;
            const wickUpper = last.high - Math.max(last.open, last.close);
            const wickLower = Math.min(last.open, last.close) - last.low;

            if (total === 0 || body <= total * 0.1) return "Doji (Indecis√£o) ‚öñÔ∏è";

            // Engulfing
            const prevBody = Math.abs(prev.close - prev.open);
            if (last.color === 'vermelho' && prev.color === 'preto' && body > prevBody) return "Engolfo de Alta üü¢";
            if (last.color === 'preto' && prev.color === 'vermelho' && body > prevBody) return "Engolfo de Baixa üî¥";

            // Pinbars
            if (wickLower >= body * 2 && wickUpper <= body * 0.5) return "Martelo / Pinbar Alta üî®";
            if (wickUpper >= body * 2 && wickLower <= body * 0.5) return "Estrela Cadente / Pinbar Baixa üå†";

            if (body >= total * 0.8) return last.color === 'vermelho' ? "Vela de For√ßa (Alta) üöÄ" : "Vela de For√ßa (Baixa) üîª";
            return "Normal";
        }

        function generateAnalysisCaption() {
            if (!allCandles || allCandles.length === 0) return 'üìä *An√°lise Gr√°fica - Op√ß√µes Double*\n\nGerado pelo Cortex Virtual';

            const lastCandle = allCandles[allCandles.length - 1];
            const price = lastCandle.close;
            
            // Trend
            const { signal, icon } = getTrendSignal(allCandles);
            
            // Strength
            const lookback = Math.min(allCandles.length, 20);
            const recent = allCandles.slice(-lookback);
            let redPower = 0, blackPower = 0, whitePower = 0;
            recent.forEach(d => {
                if (d.color === 'vermelho') redPower++;
                else if (d.color === 'preto') blackPower++;
                else if (d.color === 'branco') whitePower++;
            });
            const total = redPower + blackPower + whitePower;
            const redPct = total > 0 ? Math.round((redPower / total) * 100) : 0;
            const blackPct = total > 0 ? Math.round((blackPower / total) * 100) : 0;
            
            // Volatility
            let volatilityText = "";
            const atrData = calculateATR(allCandles, 14);
            
            // Check if ATR is dynamic enough (in Tick mode it's constant)
            let metricData = atrData;
            let isFlat = false;
            
            const validATRs = atrData.filter(v => v !== null);
            if (validATRs.length > 0) {
                const recentATRs = validATRs.slice(-20);
                const minA = Math.min(...recentATRs);
                const maxA = Math.max(...recentATRs);
                if (maxA === minA) isFlat = true;
            }

            // If ATR is flat, calculate Standard Deviation of Price
            if (isFlat) {
                const period = 20;
                const stdDevData = [];
                for (let i = 0; i < allCandles.length; i++) {
                    if (i < period - 1) { stdDevData.push(null); continue; }
                    let sum = 0;
                    for (let j = 0; j < period; j++) sum += allCandles[i - j].close;
                    const mean = sum / period;
                    let sumSq = 0;
                    for (let j = 0; j < period; j++) sumSq += Math.pow(allCandles[i - j].close - mean, 2);
                    stdDevData.push(Math.sqrt(sumSq / period));
                }
                metricData = stdDevData;
            }

            const currentMetric = metricData[metricData.length - 1];
            if (currentMetric !== null && currentMetric !== undefined) {
                const volLookbackInput = document.getElementById('volatilityLookback');
                const volLookbackValue = volLookbackInput ? parseInt(volLookbackInput.value) : 50;
                const volLookback = Math.min(allCandles.length, volLookbackValue);
                const recentMetrics = [];
                for(let i = allCandles.length - volLookback; i < allCandles.length; i++) {
                    if(metricData[i] !== null) recentMetrics.push(metricData[i]);
                }
                if (recentMetrics.length > 0) {
                    let minM = Math.min(...recentMetrics);
                    let maxM = Math.max(...recentMetrics);
                    if (maxM === minM) maxM = minM + 0.001;
                    const volatility = Math.max(0, Math.min(100, ((currentMetric - minM) / (maxM - minM)) * 100));
                    volatilityText = `‚ö° *Volatilidade:* ${Math.round(volatility)}%`;
                }
            }

            let indicatorsText = "";
            
            // RSI
            if (document.getElementById('rsiToggle').checked) {
                const rsiPeriod = parseInt(document.getElementById('rsiPeriodInput').value) || 14;
                const rsiValues = calculateRSI(allCandles, rsiPeriod);
                const lastRSI = rsiValues[rsiValues.length - 1];
                if (lastRSI !== null) {
                    let rsiStatus = "Neutro";
                    if (lastRSI >= 70) rsiStatus = "Sobrecompra üî¥";
                    else if (lastRSI <= 30) rsiStatus = "Sobrevenda üü¢";
                    indicatorsText += `\nüìâ *RSI(${rsiPeriod}):* ${lastRSI.toFixed(1)} - ${rsiStatus}`;
                }
            }

            // Bollinger Bands
            if (document.getElementById('bbToggle').checked) {
                const bbPeriod = parseInt(document.getElementById('bbPeriodInput').value) || 20;
                const bbStdDev = parseFloat(document.getElementById('bbStdDevInput').value) || 2;
                const bbData = calculateBollingerBands(allCandles, bbPeriod, bbStdDev);
                const lastUpper = bbData.upper[bbData.upper.length - 1];
                const lastLower = bbData.lower[bbData.lower.length - 1];
                
                if (lastUpper !== null && lastLower !== null) {
                    if (price >= lastUpper) indicatorsText += `\nüåä *Bollinger:* Rompendo Topo üî¥`;
                    else if (price <= lastLower) indicatorsText += `\nüåä *Bollinger:* Rompendo Fundo üü¢`;
                    else indicatorsText += `\nüåä *Bollinger:* Dentro das Bandas`;
                }
            }

            // MACD
            if (document.getElementById('macdToggle').checked) {
                const fast = parseInt(document.getElementById('macdFastInput').value) || 12;
                const slow = parseInt(document.getElementById('macdSlowInput').value) || 26;
                const sig = parseInt(document.getElementById('macdSignalInput').value) || 9;
                const macdData = calculateMACD(allCandles, fast, slow, sig);
                const lastHist = macdData.histogram[macdData.histogram.length - 1];
                if (lastHist !== null) {
                    const macdStatus = lastHist > 0 ? "Alta üü¢" : "Baixa üî¥";
                    indicatorsText += `\nüìä *MACD:* Tend√™ncia de ${macdStatus}`;
                }
            }

            const pattern = identifyCandlePattern(allCandles);

            const now = new Date();
            const dateTimeStr = `${now.toLocaleDateString('pt-BR')} ${now.toLocaleTimeString('pt-BR')}`;

            let caption = `üìä *AN√ÅLISE T√âCNICA - OP√á√ïES DOUBLE*\n`;
            caption += `üìÖ *Data:* ${dateTimeStr}\n\n`;
            caption += `üß≠ *Tend√™ncia:* ${icon} ${signal}\n`;
            caption += `üïØÔ∏è *Padr√£o:* ${pattern}\n`;
            caption += `üé≤ *Hist√≥rico:* ${getFormattedHistory()}\n`;
            caption += `üí™ *For√ßa (20):* üî¥ ${redPct}% | ‚ö´ ${blackPct}%\n`;
            if (volatilityText) caption += `${volatilityText}\n`;
            if (indicatorsText) caption += `--------------------------${indicatorsText}\n`;
            caption += `--------------------------\n`;
            caption += `ü§ñ *Gerado pelo Cortex Virtual*`;

            return caption;
        }

        function updateDoubleNews() {
            const newsTextEl = document.getElementById('double-news-text');
            if (!newsTextEl || !allCandles || allCandles.length < 5) return;

            const { signal } = getTrendSignal(allCandles);
            const pattern = identifyCandlePattern(allCandles);
            
            // Dominance Analysis (Last 20)
            const recent = allCandles.slice(-20);
            let red = 0, black = 0;
            recent.forEach(c => { if(c.color === 'vermelho') red++; else if(c.color === 'preto') black++; });
            const domColor = red > black ? 'Vermelho' : (black > red ? 'Preto' : 'Equilibrado');
            const domPct = Math.round((Math.max(red, black) / recent.length) * 100);

            // RSI Status
            let rsiMsg = "";
            const rsiToggle = document.getElementById('rsiToggle');
            if (rsiToggle && rsiToggle.checked) {
                const rsiVals = calculateRSI(allCandles, 14);
                const lastRSI = rsiVals[rsiVals.length - 1];
                if (lastRSI > 70) rsiMsg = " | ‚ö†Ô∏è RSI Sobrecompra";
                else if (lastRSI < 30) rsiMsg = " | ‚ö†Ô∏è RSI Sobrevenda";
            }

            // Construct Message
            let msg = `TEND√äNCIA: ${signal} | DOMIN√ÇNCIA: ${domColor} (${domPct}%)`;
            if (pattern !== "Normal" && pattern !== "N/A") msg += ` | PADR√ÉO: ${pattern}`;
            msg += rsiMsg;
            
            const surfVal = document.getElementById('panel-surf-val');
            if (surfVal && surfVal.innerText !== '--') msg += ` | üéØ PREVIS√ÉO: ${surfVal.innerText}`;

            if (newsTextEl.innerText !== msg) newsTextEl.innerText = msg;
        }

        async function checkAndSendAutoTelegram() {
            const isAutoOn = localStorage.getItem('auto_tg_state') === 'true';
            if (!isAutoOn) return;

            const now = Date.now();
            // Evita spam: limita a um envio a cada 5 minutos
            if (now - lastAutoSentTimestamp < 5 * 60 * 1000) return;

            if (!allCandles || allCandles.length < 20) return;

            // Calcula a For√ßa da Tend√™ncia (Baseado na l√≥gica do widget)
            const lookback = 20;
            const recent = allCandles.slice(-lookback);
            let redPower = 0, blackPower = 0, whitePower = 0;
            recent.forEach(d => {
                if (d.color === 'vermelho') redPower++;
                else if (d.color === 'preto') blackPower++;
                else if (d.color === 'branco') whitePower++;
            });
            const total = redPower + blackPower + whitePower;
            if (total === 0) return;

            let strength = 0;
            if (redPower > blackPower) strength = (redPower / total) * 100;
            else if (blackPower > redPower) strength = (blackPower / total) * 100;
            
            const minProbInput = document.getElementById('autoTelegramMinProbability');
            const maxProbInput = document.getElementById('autoTelegramMaxProbability');
            const minProb = minProbInput ? parseInt(minProbInput.value) : 75;
            const maxProb = maxProbInput ? parseInt(maxProbInput.value) : 95;

            if (strength >= minProb && strength <= maxProb) {
                await sendDirectTelegramAnalysis();
                lastAutoSentTimestamp = Date.now();
            }
        }

        async function sendDirectTelegramAnalysis() {
            const token = localStorage.getItem('telegram_bot_token');
            let chatId = sessionStorage.getItem('telegram_chat_id_double') || localStorage.getItem('telegram_chat_id_double');
            if (!chatId) chatId = sessionStorage.getItem('telegram_chat_id') || localStorage.getItem('telegram_chat_id');

            if (!token || !chatId) return;

            try {
                const analysisCaption = generateAnalysisCaption();
                const canvas = await generateChartCanvas();
                if (!canvas) return;

                canvas.toBlob(async function(blob) {
                    const formData = new FormData();
                    formData.append('chat_id', chatId);
                    formData.append('photo', blob, 'chart.png');
                    formData.append('caption', analysisCaption);
                    formData.append('parse_mode', 'Markdown');
                    
                    await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, { method: 'POST', body: formData });
                    console.log("Auto TG: An√°lise enviada com sucesso.");
                }, 'image/png');
            } catch (e) {
                console.error("Auto TG Erro:", e);
            }
        }

        function playAlertSound() {
            const soundToggle = document.getElementById('soundToggle');
            if (soundToggle && !soundToggle.checked) return;
            
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, ctx.currentTime); // A5
                osc.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.15); // Drop
                
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                
                osc.start();
                osc.stop(ctx.currentTime + 0.3);
            } catch (e) {
                console.error("Audio error:", e);
            }
        }

        function playWhiteVolatilityAlertSound() {
            const soundToggle = document.getElementById('soundToggle');
            if (soundToggle && !soundToggle.checked) return;
            
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1000, ctx.currentTime); // High pitch
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                
                osc.start();
                osc.stop(ctx.currentTime + 0.4);
            } catch (e) { console.error("Audio error (White Volatility):", e); }
        }

        function playRedVolatilityAlertSound() {
            const soundToggle = document.getElementById('soundToggle');
            if (soundToggle && !soundToggle.checked) return;
            
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                osc.type = 'triangle'; // Different waveform
                osc.frequency.setValueAtTime(440, ctx.currentTime); // A4
                osc.frequency.exponentialRampToValueAtTime(330, ctx.currentTime + 0.3); // Descending tone
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                osc.start(); osc.stop(ctx.currentTime + 0.3);
            } catch (e) { console.error("Audio error (Red Volatility):", e); }
        }

        function playBlackVolatilityAlertSound() {
            const soundToggle = document.getElementById('soundToggle');
            if (soundToggle && !soundToggle.checked) return;
            
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                osc.type = 'sawtooth'; // Different waveform
                osc.frequency.setValueAtTime(330, ctx.currentTime); // E4
                osc.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.3); // Ascending tone
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                osc.start(); osc.stop(ctx.currentTime + 0.3);
            } catch (e) { console.error("Audio error (Black Volatility):", e); }
        }

        function saveWarmupConfig() {
            const val = document.getElementById('warmupInput').value;
            localStorage.setItem('warmup_seconds', val);
        }

        function saveWhiteGaleConfig() {
            const val = document.getElementById('whiteGaleAttempts').value;
            localStorage.setItem('white_gale_attempts', val);
        }

        function saveAutoTgConfig() {
            const minVal = document.getElementById('autoTelegramMinProbability').value;
            const maxVal = document.getElementById('autoTelegramMaxProbability').value;
            localStorage.setItem('auto_tg_min_probability', minVal);
            localStorage.setItem('auto_tg_max_probability', maxVal);
            const entryMinute = document.getElementById('autoTelegramEntryMinute').value;
            localStorage.setItem('auto_tg_entry_minute', entryMinute);
            const galesSelect = document.getElementById('autoTelegramGales');
            if (galesSelect) {
                localStorage.setItem('auto_tg_gales', galesSelect.value);
            }
        }

        function resetAllConfigs() {
            if (!confirm('Tem certeza que deseja resetar todas as configura√ß√µes para o padr√£o? Isso ir√° recarregar a p√°gina.')) {
                return;
            }

            // Limpa as configura√ß√µes salvas no navegador
            localStorage.removeItem('warmup_seconds');
            localStorage.removeItem('white_gale_attempts');
            localStorage.removeItem('auto_tg_min_probability');
            localStorage.removeItem('auto_tg_max_probability');
            localStorage.removeItem('auto_tg_entry_minute');
            localStorage.removeItem('auto_tg_gales');
            localStorage.removeItem('auto_tg_state');

            alert('Configura√ß√µes resetadas. A p√°gina ser√° recarregada.');
            window.location.reload();
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                const btn = document.getElementById('themeToggleBtn');
                if(btn) btn.innerText = 'üåô Tema';
            }

            const savedWarmup = localStorage.getItem('warmup_seconds');
            if (savedWarmup !== null) {
                const input = document.getElementById('warmupInput');
                if (input) input.value = savedWarmup;
            }

            const savedGale = localStorage.getItem('white_gale_attempts');
            if (savedGale !== null) {
                const input = document.getElementById('whiteGaleAttempts');
                if (input) input.value = savedGale;
            }

            const savedAutoTgMinProb = localStorage.getItem('auto_tg_min_probability');
            if (savedAutoTgMinProb !== null) {
                const input = document.getElementById('autoTelegramMinProbability');
                if (input) input.value = savedAutoTgMinProb;
            }

            const savedAutoTgMaxProb = localStorage.getItem('auto_tg_max_probability');
            if (savedAutoTgMaxProb !== null) {
                const input = document.getElementById('autoTelegramMaxProbability');
                if (input) input.value = savedAutoTgMaxProb;
            }

            const savedAutoTgEntryMinute = localStorage.getItem('auto_tg_entry_minute');
            if (savedAutoTgEntryMinute !== null) {
                const input = document.getElementById('autoTelegramEntryMinute');
                if (input) input.value = savedAutoTgEntryMinute;
            }

            const savedAutoTgGales = localStorage.getItem('auto_tg_gales');
            if (savedAutoTgGales !== null) {
                const select = document.getElementById('autoTelegramGales');
                if (select) select.value = savedAutoTgGales;
            }

            const savedAutoTgState = localStorage.getItem('auto_tg_state');
            if (savedAutoTgState === 'true') {
                const btn = document.getElementById('autoTgBtn');
                if (btn) {
                    // Seta o estado para ON sem disparar a mensagem de ativa√ß√£o no recarregamento da p√°gina
                    btn.setAttribute('data-active', 'true');
                    btn.innerText = 'ü§ñ Auto TG: ON';
                    btn.style.borderColor = '#00ff88';
                    btn.style.color = '#00ff88';
                    btn.style.background = 'rgba(0, 255, 136, 0.2)';
                    btn.classList.add('active');
                }
            }

            const autoFetchToggle = document.getElementById('autoFetchToggle');
            if (autoFetchToggle) {
                autoFetchToggle.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        fetchData(); // Fetch immediately
                        if (autoFetchInterval) clearInterval(autoFetchInterval);
                        autoFetchInterval = setInterval(fetchData, 15000); // Check for updates every 15s
                    } else {
                        clearInterval(autoFetchInterval);
                    }
                });
                autoFetchToggle.checked = true;
                autoFetchToggle.dispatchEvent(new Event('change'));
            } else {
                fetchData(); 
                setInterval(fetchData, 15000);
            }

            // Panning functionality (Mouse and Touch)
            const chartContainer = document.getElementById('chart-container');

            const startPan = (clientX) => {
                if (isDrawMode) return;
                isPanning = true;
                panStartX = clientX;
                panStartViewIndex = viewStartIndex;
                chartContainer.style.cursor = 'grabbing';
            };

            const movePan = (clientX) => {
                if (!isPanning) return;
                const dx = clientX - panStartX;
                const candlePixelWidth = chartContainer.clientWidth / visibleCandleCount; // Based on visible candle count
                const candleShift = Math.round(dx / candlePixelWidth);
                
                const newIndex = panStartViewIndex - candleShift;
                if (newIndex !== viewStartIndex) {
                    viewStartIndex = newIndex;
                    renderVisibleCharts();
                }
            };

            const stopPan = () => {
                if (!isPanning) return;
                isPanning = false;
                chartContainer.style.cursor = isDrawMode ? 'crosshair' : 'default';
            };

            chartContainer.addEventListener('mousedown', (e) => { e.preventDefault(); startPan(e.clientX); });
            chartContainer.addEventListener('mousemove', (e) => { e.preventDefault(); movePan(e.clientX); });
            chartContainer.addEventListener('mouseup', stopPan);
            chartContainer.addEventListener('mouseleave', stopPan);
            chartContainer.addEventListener('touchstart', (e) => { e.preventDefault(); startPan(e.touches[0].clientX); }, { passive: false });
            chartContainer.addEventListener('touchmove', (e) => { e.preventDefault(); movePan(e.touches[0].clientX); }, { passive: false });
            chartContainer.addEventListener('touchend', stopPan);

            // Start Countdown Timer
            setInterval(() => {
                const timerEl = document.getElementById('candle-countdown');
                if (timerEl) {
                    const timeframe = document.getElementById('timeframeSelect').value;
                    if (timeframe !== 'tick') {
                        const now = new Date();
                        const tfMinutes = parseInt(timeframe);
                        const msPerCandle = tfMinutes * 60 * 1000;
                        const nextCandleTime = Math.ceil(now.getTime() / msPerCandle) * msPerCandle;
                        let diff = Math.ceil((nextCandleTime - now.getTime()) / 1000);
                        if (diff <= 0) diff = tfMinutes * 60;
                        const minutes = Math.floor(diff / 60);
                        const seconds = diff % 60;
                        timerEl.textContent = `‚è≥ ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            }, 1000);
        });
    </script>
</body>
</html>