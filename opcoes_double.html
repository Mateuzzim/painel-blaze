<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Op√ß√µes Double - Gr√°fico</title>
    <style>
        /* Basic styles from other pages */
        :root {
            --bg-color: #0f0f13; --panel-bg: #1a1a1a; --text-color: #fff; --border-color: #333; --input-bg: #0f0f13;
            --accent: #00d2ff; --accent-blaze: #ff0055; --accent-jonbet: #00ff88; --text-muted: #888;
        }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; }
        .main-container { max-width: 98%; margin: 0 auto; }
        .layout-panel { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .main-header { display: flex; justify-content: center; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
        h1 { margin: 0; }
        .cortex-text-anim { background: linear-gradient(90deg, #00d2ff, #ff0055, #ff9800, #00d2ff); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: cortex-gradient 3s linear infinite; font-weight: bold; }
        @keyframes cortex-gradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        .btn-back { display: inline-flex; align-items: center; gap: 5px; padding: 8px 15px; background: rgba(255,255,255,0.05); color: #aaa; text-decoration: none; border-radius: 6px; margin-bottom: 15px; font-size: 0.9rem; border: 1px solid #333; transition: all 0.3s; }
        .btn-back:hover { background: rgba(0, 210, 255, 0.1); border-color: #00d2ff; color: #00d2ff; box-shadow: 0 0 10px rgba(0, 210, 255, 0.2); }
        
        /* Chart specific styles */
        #chart-container, #adx-container, #volume-container, #macd-container, #rsi-container {
            width: 100%;
            background-color: #0c1014; /* Darker blueish background */
            background-image: 
                linear-gradient(rgba(0, 210, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 210, 255, 0.05) 1px, transparent 1px);
            background-size: 25px 25px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.7);
            border-radius: 8px;
            border: 1px solid #333;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }
        #chart-container { height: 650px; }
        #adx-container { height: 150px; margin-top: 10px; display: none; }
        #volume-container {
            height: 100px;
            margin-top: 10px;
            display: none;
        }
        #macd-container { height: 150px; margin-top: 10px; display: none; }
        #rsi-container { height: 150px; margin-top: 10px; display: none; }
        #stoch-container { height: 150px; margin-top: 10px; display: none; }

        #chart-container svg, #rsi-container svg, #macd-container svg, #volume-container svg, #adx-container svg, #stoch-container svg {
            background-color: transparent; /* Make SVG background transparent to see the container's grid */
        }
        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 1.2rem;
        }
        .controls-panel {
            background: rgba(0,0,0,0.2);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            animation: card-pulse 4s infinite;
        }
        
        @keyframes card-pulse {
            0% { border-color: rgba(255,255,255,0.05); box-shadow: 0 0 0 rgba(0,0,0,0); }
            50% { border-color: rgba(0, 210, 255, 0.3); box-shadow: 0 0 15px rgba(0, 210, 255, 0.1); }
            100% { border-color: rgba(255,255,255,0.05); box-shadow: 0 0 0 rgba(0,0,0,0); }
        }

        .draw-mode-btn {
            background: rgba(0, 210, 255, 0.05) !important;
            border: 1px solid rgba(0, 210, 255, 0.2) !important;
            color: #00d2ff !important;
            padding: 10px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 5px rgba(0, 210, 255, 0.1);
        }
        .draw-mode-btn:hover {
            background: rgba(0, 210, 255, 0.2) !important;
            color: #fff !important;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.4);
            border-color: #00d2ff !important;
            transform: translateY(-2px) scale(1.02);
        }
        .draw-mode-btn:active { transform: translateY(0) scale(0.98); }
        .draw-mode-btn.active {
            background: #00d2ff !important;
            color: #000 !important;
            border-color: #00d2ff !important;
            box-shadow: 0 0 25px rgba(0, 210, 255, 0.5);
        }

        .tool-group {
            display: flex; align-items: center; gap: 8px;
            background: rgba(255,255,255,0.03);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
        }
        .tool-group:hover {
            border-color: rgba(0, 210, 255, 0.3);
            background: rgba(0, 210, 255, 0.05);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.1);
        }
        .tool-group span { font-size: 0.8rem; color: #aaa; font-weight: bold; text-transform: uppercase; }
        .tool-group input[type="number"] {
            background: rgba(0,0,0,0.3) !important;
            border: 1px solid rgba(255,255,255,0.2) !important;
            color: #fff !important;
            border-radius: 4px !important;
            padding: 4px !important;
            text-align: center;
        }
        
        #timeframeSelect {
            background: rgba(0, 210, 255, 0.05) !important;
            border: 1px solid rgba(0, 210, 255, 0.2) !important;
            color: #00d2ff !important;
            border-radius: 20px !important;
            padding: 8px 15px !important;
            font-weight: bold;
            cursor: pointer;
        }
        #timeframeSelect:hover { background: rgba(0, 210, 255, 0.1) !important; }

        .current-price-line {
            animation: pulse-line 1.5s infinite alternate;
        }
        .indicator-line {
            filter: url(#glow);
        }
        .candle-wick {
            stroke-linecap: round;
        }

        @keyframes pulse-line { from { opacity: 0.4; } to { opacity: 0.9; } }
        .bb-alert-marker { animation: pulse-alert 1s infinite; }
        @keyframes pulse-alert {
            0% { r: 2.5; opacity: 1; stroke-width: 0.5; }
            50% { r: 5; opacity: 0.8; stroke-width: 2; }
            100% { r: 2.5; opacity: 1; stroke-width: 0.5; }
        }

        .chart-tooltip {
            position: fixed;
            background: rgba(10, 15, 25, 0.95);
            border: 1px solid #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 9999;
            display: none;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        /* Market Strength Widget */
        #widgets-wrapper {
            position: absolute; top: 20px; left: 20px; z-index: 20;
            display: flex; flex-direction: column; gap: 15px;
            pointer-events: none;
        }
        .market-strength-widget {
            position: relative;
            top: auto;
            left: auto;
            pointer-events: auto;
            width: 70px;
            padding: 10px;
            background: rgba(12, 16, 20, 0.85);
            border: 1px solid #333;
            border-radius: 8px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: border-color 0.5s, box-shadow 0.5s;
        }
        .market-strength-widget::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, transparent, rgba(255,255,255,0.05), transparent);
            pointer-events: none; animation: scan-strength 3s infinite linear;
        }
        @keyframes scan-strength { 0% { transform: translateY(-100%); } 100% { transform: translateY(100%); } }
        .strength-title { font-size: 0.6rem; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; text-align: center; font-weight: bold; }
        .strength-meter-bg { width: 8px; height: 100px; background: #222; border-radius: 4px; position: relative; overflow: hidden; border: 1px solid #444; }
        .strength-meter-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; background: #555;
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.5s;
            border-radius: 4px; box-shadow: 0 0 10px currentColor;
        }
        .strength-value { font-size: 1.1rem; font-weight: 900; margin-top: 8px; font-family: 'Courier New', monospace; text-shadow: 0 0 5px currentColor; }
        .strength-trend-icon { font-size: 1.2rem; margin-top: 2px; }

        /* Trend History Panel */
        #trend-history-panel {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 200px;
            background: rgba(12, 16, 20, 0.5);
            border: 1px solid rgba(0, 210, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            z-index: 90;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.1);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }
        .history-title { font-size: 0.8rem; color: #00d2ff; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 5px rgba(0, 210, 255, 0.5); }
        .history-list { list-style: none; padding: 0; margin: 0; overflow: hidden; }
        .history-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 0.75rem; animation: slideInRight 0.4s ease-out;
        }
        .history-time { color: #888; font-family: monospace; }
        .history-signal { font-weight: bold; display: flex; align-items: center; gap: 5px; }
        @keyframes slideInRight { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }

        @media (max-width: 768px) {
            body { padding: 10px; }
            .main-container { width: 100%; padding: 0; }
            .layout-panel { padding: 10px; border-radius: 8px; }
            #chart-container { height: 600px; }
            #adx-container, #macd-container, #rsi-container, #stoch-container { height: 120px; }
            #volume-container { height: 80px; }
            .controls-panel { padding: 10px; gap: 5px; justify-content: space-between; }
            .controls-panel > * { flex: 1 1 auto; text-align: center; justify-content: center; font-size: 0.75rem; }
            .draw-mode-btn { padding: 8px; }
            h1 { font-size: 1.5rem; }
            .btn-back { width: 100%; justify-content: center; box-sizing: border-box; }
            .chart-tooltip { font-size: 0.7rem; padding: 5px 8px; }
            #trend-history-panel { display: none; } /* Hide on mobile to save space */

            /* Responsive Widgets */
            #widgets-wrapper {
                flex-direction: row;
                top: 10px; left: 0; width: 100%;
                justify-content: center; gap: 8px;
            }
            .market-strength-widget { width: 55px; padding: 5px; }
            .strength-meter-bg { height: 50px; }
        }

        /* Light Mode Styles */
        body.light-mode {
            --bg-color: #f0f2f5; --panel-bg: #ffffff; --text-color: #1a1a1a; --border-color: #ddd; --input-bg: #fff;
            --text-muted: #666;
        }
        body.light-mode .layout-panel { box-shadow: 0 0 20px rgba(0,0,0,0.1); }
        body.light-mode #chart-container, body.light-mode #adx-container, body.light-mode #volume-container, 
        body.light-mode #macd-container, body.light-mode #rsi-container, body.light-mode #stoch-container {
            background-color: #ffffff;
            background-image: linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.02); border-color: #ddd;
        }
        body.light-mode .controls-panel { background: rgba(0,0,0,0.05); border-color: #ddd; }
        body.light-mode .draw-mode-btn { background: #e0e0e0; color: #333; border-color: #ccc; }
        body.light-mode .draw-mode-btn:hover { background: #d0d0d0; }
        body.light-mode select, body.light-mode input { background: #fff !important; color: #333 !important; border-color: #ccc !important; }
        body.light-mode .market-strength-widget { background: rgba(255, 255, 255, 0.9); border-color: #ddd; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        body.light-mode .strength-meter-bg { background: #e0e0e0; border-color: #ccc; }
        body.light-mode #trend-history-panel { background: rgba(255, 255, 255, 0.8); border-color: rgba(0, 210, 255, 0.5); box-shadow: 0 0 15px rgba(0,0,0,0.05); }
        body.light-mode .history-item { border-bottom-color: rgba(0,0,0,0.05); }
        body.light-mode .history-time { color: #666; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="layout-panel">
            <a href="index.html" class="btn-back" style="display: none;">‚¨Ö Voltar ao Menu</a>
            <div class="main-header">
                <h1 class="cortex-text-anim">OP√á√ïES DOUBLE</h1>
            </div>
            <div id="chart-container">
                <div class="loading-text">Carregando dados do gr√°fico...</div>
                <div id="widgets-wrapper">
                    <div id="market-strength" class="market-strength-widget" style="display: none;">
                        <div class="strength-title">FOR√áA</div>
                        <div class="strength-meter-bg"><div id="strength-fill" class="strength-meter-fill" style="height: 0%;"></div></div>
                        <div id="strength-val" class="strength-value">0%</div>
                        <div id="strength-icon" class="strength-trend-icon">‚ûñ</div>
                    </div>
                    <div id="market-trend" class="market-strength-widget" style="display: none;">
                        <div class="strength-title">TEND√äNCIA</div>
                        <div id="trend-val" class="strength-value" style="font-size: 0.8rem; margin-top: 20px;">NEUTRO</div>
                        <div id="trend-icon" class="strength-trend-icon" style="margin-top: 10px;">‚öñÔ∏è</div>
                    </div>
                    <div id="market-volatility" class="market-strength-widget" style="display: none;">
                        <div class="strength-title">VOLAT.</div>
                        <div class="strength-meter-bg"><div id="volatility-fill" class="strength-meter-fill" style="height: 0%;"></div></div>
                        <div id="volatility-val" class="strength-value">0%</div>
                        <div id="volatility-icon" class="strength-trend-icon">„Ä∞Ô∏è</div>
                    </div>
                </div>
                <!-- Painel Lateral de Hist√≥rico -->
                <div id="trend-history-panel" style="display: none;">
                    <div class="history-header"><span class="history-title">Hist√≥rico</span><span style="font-size:0.8rem">‚è≥</span></div>
                    <ul id="history-list" class="history-list">
                        <li style="text-align: center; color: #555; padding: 10px; font-size: 0.7rem;">Aguardando sinais...</li>
                    </ul>
                </div>
            </div>
            <div id="adx-container"></div>
            <div id="volume-container"></div>
            <div id="macd-container"></div>
            <div id="rsi-container"></div>
            <div id="stoch-container"></div>
            <div class="controls-panel">
                <select id="timeframeSelect" onchange="updateChart()">
                    <option value="tick">Tick</option>
                    <option value="1">1 Min</option>
                    <option value="5">5 Min</option>
                </select>
                <button id="themeToggleBtn" class="draw-mode-btn" onclick="toggleTheme()">‚òÄÔ∏è Tema</button>
                <button id="drawModeBtn" class="draw-mode-btn" onclick="toggleDrawMode(this)">‚úèÔ∏è Desenhar</button>
                <button id="screenshotBtn" class="draw-mode-btn" onclick="takeScreenshot()">üì∏ Capturar</button>
                <button id="telegramBtn" class="draw-mode-btn" onclick="sendScreenshotToTelegram(this)">‚úàÔ∏è Telegram</button>
                <button id="resetViewBtn" class="draw-mode-btn" onclick="resetView()">üîÑ Resetar Posi√ß√£o</button>
                <button id="fullscreenBtn" class="draw-mode-btn" onclick="toggleFullscreen()">üñºÔ∏è Tela Cheia</button>
                <button id="clearDrawingsBtn" class="draw-mode-btn" onclick="clearDrawings()">üóëÔ∏è Limpar</button>
                <div class="tool-group">
                    <span style="font-size: 0.8rem; color: #fff;">üîç Zoom</span>
                    <button onclick="zoomIn()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; padding: 2px 8px; cursor: pointer;" title="Aumentar Zoom">+</button>
                    <button onclick="resetZoom()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; padding: 2px 8px; cursor: pointer;" title="Resetar Zoom">R</button>
                    <button onclick="zoomOut()" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; padding: 2px 8px; cursor: pointer;" title="Diminuir Zoom">-</button>
                </div>
                <input type="color" id="drawingColorPicker" value="#00d2ff" title="Cor do Desenho" style="background: #222; border: 1px solid #444; border-radius: 4px; cursor: pointer; height: 35px; padding: 2px;">
                <div class="tool-group">
                    <span style="font-size: 0.8rem; color: #fff;">Velas:</span>
                    <input type="color" id="candleUpColor" value="#ff0055" title="Cor de Alta" onchange="updateChart()" style="width: 25px; height: 25px; padding: 0; border: none; background: none; cursor: pointer;">
                    <input type="color" id="candleDownColor" value="#343a40" title="Cor de Baixa" onchange="updateChart()" style="width: 25px; height: 25px; padding: 0; border: none; background: none; cursor: pointer;">
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="autoFetchToggle" checked title="Atualiza√ß√£o Autom√°tica">
                    <span style="font-size: 0.8rem; color: #fff;">Auto</span>
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="widgetsToggle" checked onchange="updateChart()" title="Mostrar/Ocultar Widgets">
                    <span style="font-size: 0.8rem; color: #fff;">Widgets</span>
                    <input type="number" id="volatilityLookback" value="50" min="10" max="200" step="10" onchange="updateChart()" style="width: 40px;" title="Sensibilidade (Per√≠odo de An√°lise)">
                    <input type="number" id="volatilityWhiteThreshold" value="90" min="50" max="99" step="1" onchange="updateChart()" style="width: 35px;" title="Limiar Alerta Branco (%)">
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="historyToggle" onchange="toggleHistory()" title="Mostrar/Ocultar Hist√≥rico">
                    <span style="font-size: 0.8rem; color: #fff;">Hist√≥rico</span>
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="smaToggle" checked onchange="updateChart()" title="Ativar SMA">
                    <span style="font-size: 0.8rem; color: #fff;">SMA</span>
                    <input type="number" id="smaPeriodInput" value="14" min="2" max="200" onchange="updateChart()" style="width: 50px;">
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="bbToggle" onchange="updateChart()" title="Ativar Bandas de Bollinger">
                    <span style="font-size: 0.8rem; color: #fff;">BB</span>
                    <input type="number" id="bbPeriodInput" value="20" min="2" max="50" onchange="updateChart()" style="width: 40px;" title="Per√≠odo">
                    <input type="number" id="bbStdDevInput" value="2" min="1" max="5" step="0.1" onchange="updateChart()" style="width: 30px;" title="Desvio Padr√£o">
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="volumeToggle" onchange="updateChart()" title="Ativar Volume">
                    <span style="font-size: 0.8rem; color: #fff;">VOL</span>
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="fractalsToggle" checked onchange="updateChart()" title="Ativar Fractais">
                    <span style="font-size: 0.8rem; color: #fff;">Fractais</span>
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="trendLineToggle" checked onchange="updateChart()" title="Ativar Linhas de Tend√™ncia">
                    <span style="font-size: 0.8rem; color: #fff;">L. Tend.</span>
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="srToggle" checked onchange="updateChart()" title="Ativar Suporte e Resist√™ncia">
                    <span style="font-size: 0.8rem; color: #fff;">Sup/Res</span>
                    <input type="number" id="srLookbackInput" value="200" min="50" max="500" step="10" onchange="updateChart()" style="width: 45px;" title="Per√≠odo de An√°lise">
                    <input type="number" id="srLinesInput" value="3" min="1" max="10" onchange="updateChart()" style="width: 30px;" title="M√°ximo de Linhas">
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="emaToggle" onchange="updateChart()" title="Ativar EMA">
                    <span style="font-size: 0.8rem; color: #fff;">EMA</span>
                    <input type="number" id="emaPeriodInput" value="9" min="2" max="200" onchange="updateChart()" style="width: 50px;">
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="adxToggle" onchange="updateChart()" title="Ativar ADX">
                    <span style="font-size: 0.8rem; color: #fff;">ADX</span>
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="soundToggle" checked title="Ativar Alertas Sonoros">
                    <span style="font-size: 0.8rem; color: #fff;">üîä</span>
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="rsiToggle" onchange="updateChart()" title="Ativar RSI (√çndice de For√ßa Relativa)">
                    <span style="font-size: 0.8rem; color: #fff;">RSI</span>
                    <input type="number" id="rsiPeriodInput" value="14" min="2" max="100" onchange="updateChart()" style="width: 40px;" title="Per√≠odo">
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="macdToggle" onchange="updateChart()" title="Ativar MACD">
                    <span style="font-size: 0.8rem; color: #fff;">MACD</span>
                    <input type="number" id="macdFastInput" value="12" min="2" max="50" onchange="updateChart()" style="width: 35px;" title="R√°pida">
                    <input type="number" id="macdSlowInput" value="26" min="2" max="100" onchange="updateChart()" style="width: 35px;" title="Lenta">
                    <input type="number" id="macdSignalInput" value="9" min="2" max="50" onchange="updateChart()" style="width: 30px;" title="Sinal">
                </div>
                <div class="tool-group">
                    <input type="checkbox" id="stochToggle" onchange="updateChart()" title="Ativar Estoc√°stico">
                    <span style="font-size: 0.8rem; color: #fff;">Stoch</span>
                    <input type="number" id="stochKInput" value="14" min="2" max="100" onchange="updateChart()" style="width: 35px;" title="%K">
                    <input type="number" id="stochDInput" value="3" min="1" max="50" onchange="updateChart()" style="width: 30px;" title="%D">
                    <input type="number" id="stochSmoothInput" value="3" min="1" max="50" onchange="updateChart()" style="width: 30px;" title="Smooth">
                </div>
            </div>
            <div id="chart-tooltip" class="chart-tooltip"></div>
        </div>
    </div>

    <script>
        let globalGamesData = [];
        let isDrawMode = false;
        let isDrawing = false;
        let startPoint = null;
        let currentLine = null;
        let drawnLines = [];
        let allCandles = [];
        let isPanning = false;
        let panStartX = 0;
        let viewStartIndex = 0;
        let panStartViewIndex = 0;
        let autoFetchInterval = null;
        let lastDataSignature = '';
        let lastLiveTrend = null;
        let visibleCandleCount = 100;

        // Helper function to identify color
        function identificarCor(numero) {
            numero = parseInt(numero);
            if (numero === 0) return 'branco';
            if (numero >= 1 && numero <= 7) return 'vermelho';
            if (numero >= 8 && numero <= 14) return 'preto';
            return 'desconhecido';
        }

        function calculateSMA(data, period) {
            const smaData = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    smaData.push(null);
                    continue;
                }
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += data[i - j].close;
                }
                smaData.push(sum / period);
            }
            return smaData;
        }

        function calculateBollingerBands(data, period = 20, multiplier = 2) {
            const upper = [];
            const lower = [];
            const middle = [];

            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    upper.push(null); lower.push(null); middle.push(null);
                    continue;
                }
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += data[i - j].close;
                }
                const sma = sum / period;
                middle.push(sma);
                let sumSqDiff = 0;
                for (let j = 0; j < period; j++) {
                    sumSqDiff += Math.pow(data[i - j].close - sma, 2);
                }
                const stdDev = Math.sqrt(sumSqDiff / period);
                upper.push(sma + (stdDev * multiplier));
                lower.push(sma - (stdDev * multiplier));
            }
            return { upper, middle, lower };
        }

        function calculateADX(data, period = 14) {
            const tr = new Array(data.length).fill(null);
            const plusDM = new Array(data.length).fill(null);
            const minusDM = new Array(data.length).fill(null);

            for (let i = 1; i < data.length; i++) {
                const current = data[i];
                const prev = data[i - 1];
                tr[i] = Math.max(current.high - current.low, Math.abs(current.high - prev.close), Math.abs(current.low - prev.close));
                const upMove = current.high - prev.high;
                const downMove = prev.low - current.low;
                plusDM[i] = (upMove > downMove && upMove > 0) ? upMove : 0;
                minusDM[i] = (downMove > upMove && downMove > 0) ? downMove : 0;
            }

            const wilderSmooth = (arr, period) => {
                const smoothed = new Array(arr.length).fill(null);
                if (arr.length < period) return smoothed;
                let firstValidIndex = -1;
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i] !== null) { firstValidIndex = i; break; }
                }
                if (firstValidIndex === -1 || firstValidIndex + period > arr.length) return smoothed;
                let sum = 0;
                for (let i = firstValidIndex; i < firstValidIndex + period; i++) {
                    sum += arr[i];
                }
                smoothed[firstValidIndex + period - 1] = sum / period;
                for (let i = firstValidIndex + period; i < arr.length; i++) {
                    if (arr[i] !== null && smoothed[i-1] !== null) {
                        smoothed[i] = (smoothed[i - 1] * (period - 1) + arr[i]) / period;
                    }
                }
                return smoothed;
            };

            const smoothedTR = wilderSmooth(tr, period);
            const smoothedPlusDM = wilderSmooth(plusDM, period);
            const smoothedMinusDM = wilderSmooth(minusDM, period);

            const plusDI = new Array(data.length).fill(null);
            const minusDI = new Array(data.length).fill(null);
            const dx = new Array(data.length).fill(null);

            for (let i = period; i < data.length; i++) {
                if (smoothedTR[i] > 0) {
                    plusDI[i] = 100 * (smoothedPlusDM[i] / smoothedTR[i]);
                    minusDI[i] = 100 * (smoothedMinusDM[i] / smoothedTR[i]);
                    const diSum = plusDI[i] + minusDI[i];
                    if (diSum > 0) {
                        dx[i] = 100 * (Math.abs(plusDI[i] - minusDI[i]) / diSum);
                    }
                }
            }

            const adx = wilderSmooth(dx, period);

            return { adx, plusDI, minusDI };
        }

        function calculateATR(data, period = 14) {
            const tr = new Array(data.length).fill(0);
            for (let i = 0; i < data.length; i++) {
                if (i === 0) {
                    tr[i] = data[i].high - data[i].low;
                } else {
                    tr[i] = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i - 1].close), Math.abs(data[i].low - data[i - 1].close));
                }
            }
            const atr = new Array(data.length).fill(null);
            if (data.length < period) return atr;
            let sum = 0;
            for (let i = 0; i < period; i++) sum += tr[i];
            atr[period - 1] = sum / period;
            for (let i = period; i < data.length; i++) {
                atr[i] = ((atr[i - 1] * (period - 1)) + tr[i]) / period;
            }
            return atr;
        }

        function calculateEMA(data, period) {
            const emaArray = new Array(data.length).fill(null);
            if (data.length < period) return emaArray;

            const k = 2 / (period + 1);
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += data[i].close;
            }
            emaArray[period - 1] = sum / period;

            for (let i = period; i < data.length; i++) {
                emaArray[i] = (data[i].close * k) + (emaArray[i - 1] * (1 - k));
            }
            return emaArray;
        }

        function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const emaFast = calculateEMA(data, fastPeriod);
            const emaSlow = calculateEMA(data, slowPeriod);
            const macdLine = [];
            const signalLine = [];
            const histogram = [];

            // Calculate MACD line
            for (let i = 0; i < data.length; i++) {
                if (emaFast[i] !== null && emaSlow[i] !== null) {
                    macdLine.push(emaFast[i] - emaSlow[i]);
                } else {
                    macdLine.push(null);
                }
            }

            // Calculate Signal line (EMA of MACD line)
            const macdValuesOnly = macdLine.map(v => ({ close: v })); // Adapt for EMA function
            const signalLineRaw = calculateEMA(macdValuesOnly, signalPeriod);
            for(let i=0; i<signalLineRaw.length; i++) {
                signalLine.push(signalLineRaw[i]);
            }

            // Calculate Histogram
            for (let i = 0; i < data.length; i++) {
                if (macdLine[i] !== null && signalLine[i] !== null) {
                    histogram.push(macdLine[i] - signalLine[i]);
                } else {
                    histogram.push(null);
                }
            }

            return { macdLine, signalLine, histogram };
        }

        function calculateEMA(data, period) {
            const emaArray = new Array(data.length).fill(null);
            if (data.length < period) return emaArray;

            const k = 2 / (period + 1);
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += data[i].close;
            }
            emaArray[period - 1] = sum / period;

            for (let i = period; i < data.length; i++) {
                emaArray[i] = (data[i].close * k) + (emaArray[i - 1] * (1 - k));
            }
            return emaArray;
        }

        function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const emaFast = calculateEMA(data, fastPeriod);
            const emaSlow = calculateEMA(data, slowPeriod);
            const macdLine = [];
            const signalLine = [];
            const histogram = [];

            // Calculate MACD line
            for (let i = 0; i < data.length; i++) {
                if (emaFast[i] !== null && emaSlow[i] !== null) {
                    macdLine.push(emaFast[i] - emaSlow[i]);
                } else {
                    macdLine.push(null);
                }
            }

            // Calculate Signal line (EMA of MACD line)
            const macdValuesOnly = macdLine.map(v => ({ close: v })); // Adapt for EMA function
            const signalLineRaw = calculateEMA(macdValuesOnly, signalPeriod);
            for(let i=0; i<signalLineRaw.length; i++) {
                signalLine.push(signalLineRaw[i]);
            }

            // Calculate Histogram
            for (let i = 0; i < data.length; i++) {
                if (macdLine[i] !== null && signalLine[i] !== null) {
                    histogram.push(macdLine[i] - signalLine[i]);
                } else {
                    histogram.push(null);
                }
            }

            return { macdLine, signalLine, histogram };
        }

        function calculateStochastic(data, periodK = 14, periodD = 3, smooth = 3) {
            const stochK = [];
            const stochD = [];

            // Calculate Fast %K first
            const fastK = [];
            for (let i = 0; i < data.length; i++) {
                if (i < periodK - 1) {
                    fastK.push(null);
                    continue;
                }
                
                let lowestLow = Infinity;
                let highestHigh = -Infinity;
                
                for (let j = 0; j < periodK; j++) {
                    lowestLow = Math.min(lowestLow, data[i - j].low);
                    highestHigh = Math.max(highestHigh, data[i - j].high);
                }
                
                const currentClose = data[i].close;
                let kValue = 50; // Default if high == low
                if (highestHigh - lowestLow !== 0) {
                    kValue = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
                }
                fastK.push(kValue);
            }

            // Smooth %K (Slow %K)
            for (let i = 0; i < fastK.length; i++) {
                if (i < periodK - 1 + smooth - 1) {
                    stochK.push(null);
                    continue;
                }
                let sum = 0; let count = 0;
                for (let j = 0; j < smooth; j++) { if (fastK[i - j] !== null) { sum += fastK[i - j]; count++; } }
                stochK.push(count > 0 ? sum / count : null);
            }

            // Calculate %D (SMA of %K)
            for (let i = 0; i < stochK.length; i++) {
                if (i < periodK - 1 + smooth - 1 + periodD - 1) {
                    stochD.push(null);
                    continue;
                }
                let sum = 0; let count = 0;
                for (let j = 0; j < periodD; j++) { if (stochK[i - j] !== null) { sum += stochK[i - j]; count++; } }
                stochD.push(count > 0 ? sum / count : null);
            }
            return { k: stochK, d: stochD };
        }

        function renderVisibleCharts(shouldPlaySound = false) {
            const chartContainer = document.getElementById('chart-container');
            // Se o container n√£o estiver vis√≠vel, n√£o desenha nada para evitar erros.
            if (!chartContainer || chartContainer.clientWidth === 0) {
                return;
            }

            if (!allCandles || allCandles.length === 0) return;
            // Garante que o √≠ndice de in√≠cio n√£o saia dos limites do array
            viewStartIndex = Math.max(0, Math.min(allCandles.length - visibleCandleCount, viewStartIndex));
            const visibleData = allCandles.slice(viewStartIndex, viewStartIndex + visibleCandleCount);
            
            drawChart(visibleData, shouldPlaySound);
            drawRSIChart(visibleData);
            drawMACDChart(visibleData);
            drawVolumeChart(visibleData);
            drawADXChart(visibleData);
            drawStochasticChart(visibleData);
        }

        function zoomIn() {
            if (visibleCandleCount > 20) {
                const center = viewStartIndex + visibleCandleCount / 2;
                visibleCandleCount -= 10;
                viewStartIndex = Math.max(0, Math.round(center - visibleCandleCount / 2));
                renderVisibleCharts();
            }
        }

        function zoomOut() {
            if (visibleCandleCount < 500 && visibleCandleCount < allCandles.length) {
                const center = viewStartIndex + visibleCandleCount / 2;
                visibleCandleCount += 10;
                viewStartIndex = Math.max(0, Math.round(center - visibleCandleCount / 2));
                renderVisibleCharts();
            }
        }

        function resetZoom() {
            visibleCandleCount = 100;
            resetView();
        }

        function resetView() {
            // Define o √≠ndice para mostrar as √∫ltimas 100 velas
            viewStartIndex = Math.max(0, allCandles.length - visibleCandleCount);
            renderVisibleCharts();
        }

        function toggleFullscreen() {
            const elem = document.querySelector('.layout-panel');
            if (!document.fullscreenElement) {
                elem.requestFullscreen().catch(err => {
                    alert(`N√£o foi poss√≠vel entrar em tela cheia: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('fullscreenBtn');
            if (btn) {
                btn.innerHTML = document.fullscreenElement ? 'üñºÔ∏è Sair' : 'üñºÔ∏è Tela Cheia';
            }
            setTimeout(() => renderVisibleCharts(), 200); // Redesenha ao mudar de tela
        });

        function calculateRSI(data, period = 14) {
            const rsi = new Array(data.length).fill(null);
            if (data.length <= period) return rsi;

            let avgGain = 0;
            let avgLoss = 0;

            // First period
            for (let i = 1; i <= period; i++) {
                const change = data[i].close - data[i - 1].close;
                if (change > 0) avgGain += change;
                else avgLoss += Math.abs(change);
            }
            avgGain /= period;
            avgLoss /= period;

            rsi[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));

            // Subsequent
            for (let i = period + 1; i < data.length; i++) {
                const change = data[i].close - data[i - 1].close;
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? Math.abs(change) : 0;

                avgGain = ((avgGain * (period - 1)) + gain) / period;
                avgLoss = ((avgLoss * (period - 1)) + loss) / period;

                rsi[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
            }
            return rsi;
        }

        function toggleDrawMode(btn) {
            isDrawMode = !isDrawMode;
            btn.classList.toggle('active', isDrawMode);
            const chartContainer = document.getElementById('chart-container');
            chartContainer.style.cursor = isDrawMode ? 'crosshair' : 'default';

            // Disable tooltips when drawing mode is active
            const hitAreas = document.querySelectorAll('#chart-container svg rect[fill="transparent"]');
            hitAreas.forEach(area => {
                area.style.pointerEvents = isDrawMode ? 'none' : 'all';
            });
        }

        function clearDrawings() {
            if (drawnLines.length > 0 && confirm('Limpar todos os desenhos?')) {
                drawnLines = [];
                updateChart(); // Redraw chart without the lines
            }
        }

        function updateChart(shouldPlaySound = false) {
            const timeframe = document.getElementById('timeframeSelect').value;
            allCandles = generateCandles(globalGamesData, timeframe);

            // Check Trend Alert (Live Data)
            if (allCandles.length > 0) {
                const { signal, color, icon } = getTrendSignal(allCandles);
                
                // Se a tend√™ncia mudou (ou √© a primeira execu√ß√£o)
                if (lastLiveTrend !== signal) {
                    addToTrendHistory(signal, color, icon);
                    if (lastLiveTrend !== null && lastLiveTrend === "NEUTRO" && (signal === "COMPRA" || signal === "VENDA")) {
                        triggerTrendAlert(signal);
                    }
                    lastLiveTrend = signal;
                }
            }
            
            // Ao atualizar os dados, sempre volta para as velas mais recentes
            resetView();
        }

        async function fetchData(shouldPlaySound = false) {
            const loadingText = document.querySelector('#chart-container .loading-text');
            try {
                if(loadingText) loadingText.innerText = 'Buscando dados da API...';

                let SEU_TOKEN_BLAZE = localStorage.getItem('blaze_token');
                 if (!SEU_TOKEN_BLAZE) {
                    try {
                        if (window.parent && window.parent.localStorage) {
                            SEU_TOKEN_BLAZE = window.parent.localStorage.getItem('blaze_token');
                        }
                    } catch (e) { /* cross-origin error */ }
                }

                const agora = new Date();
                const ontem = new Date();
                ontem.setHours(ontem.getHours() - 24);
                const endDate = agora.toISOString();
                const startDate = ontem.toISOString();
                const headers = {};
                if (SEU_TOKEN_BLAZE) {
                    headers['Authorization'] = `Bearer ${SEU_TOKEN_BLAZE}`;
                    headers['x-access-token'] = SEU_TOKEN_BLAZE;
                }

                const pages = [1, 2, 3, 4, 5];
                let allGamesApi = [];
                for (const page of pages) {
                    const baseUrl = `https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/history/${page}`;
                    const params = `?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}&page=${page}&_nc=${Date.now()}`;
                    const targetUrl = `${baseUrl}${params}`;
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                    
                    const response = await fetch(proxyUrl, { method: 'GET', headers: headers });
                    if (response.ok) {
                        const data = await response.json();
                        if (data) {
                            const records = Array.isArray(data) ? data : (data.records || []);
                            allGamesApi = allGamesApi.concat(records);
                            if (records.length === 0) break;
                        }
                    } else {
                        if (response.status === 401) throw new Error("Token inv√°lido (401).");
                        console.warn(`Falha ao buscar p√°gina ${page}: Status ${response.status}`);
                    }
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                const seenIds = new Set();
                const uniqueGames = allGamesApi.filter(game => {
                    if (game.id && !seenIds.has(game.id)) { seenIds.add(game.id); return true; }
                    return false;
                }).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                if (uniqueGames.length === 0) { throw new Error("A API n√£o retornou jogos."); }

                const newSignature = uniqueGames[0]?.id || '';
                if (newSignature === lastDataSignature) { if(loadingText && loadingText.innerText.includes('Buscando')) loadingText.style.display = 'none'; return; }
                lastDataSignature = newSignature;

                globalGamesData = uniqueGames.map(g => ({ created_at: g.created_at, roll: g.roll }));
                updateChart(shouldPlaySound);

            } catch (e) {
                console.error("Erro ao buscar dados para o gr√°fico:", e);
                if(loadingText) loadingText.innerText = `Erro: ${e.message}`;
            }
        }

        function generateCandles(data, timeframe) {
            let priceData = [];
            let lastClose = 100;
            
            // Ordena do mais antigo para o mais novo para processamento sequencial
            const sortedData = [...data].sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

            if (timeframe === 'tick') {
                sortedData.forEach(game => {
                    const open = lastClose;
                    let high, low, close;
                    const color = identificarCor(game.roll);

                    if (color === 'vermelho') { // Up
                        close = open + 10; high = close; low = open;
                    } else if (color === 'preto') { // Down
                        close = open - 10; high = open; low = close;
                    } else { // Branco (Doji)
                        close = open; high = open + 5; low = open - 5;
                    }
                    const timeStr = new Date(game.created_at).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    priceData.push({ open, high, low, close, color, roll: game.roll, time: timeStr, volume: 1 });
                    lastClose = close;
                });
                return priceData;
            } else {
                // Agrega√ß√£o por Tempo (1m, 5m)
                const tfMs = parseInt(timeframe) * 60 * 1000;
                let currentBucketStart = null;
                let bucketCandle = null;

                sortedData.forEach(game => {
                    const gameTime = new Date(game.created_at).getTime();
                    const bucketStart = Math.floor(gameTime / tfMs) * tfMs;

                    const open = lastClose;
                    let close;
                    const color = identificarCor(game.roll);
                    
                    if (color === 'vermelho') close = open + 10;
                    else if (color === 'preto') close = open - 10;
                    else close = open;
                    
                    lastClose = close;

                    if (currentBucketStart === null || bucketStart !== currentBucketStart) {
                        if (bucketCandle) priceData.push(bucketCandle);
                        currentBucketStart = bucketStart;
                        bucketCandle = {
                            open: open,
                            high: Math.max(open, close),
                            low: Math.min(open, close),
                            close: close,
                            time: new Date(bucketStart).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),
                            timestamp: bucketStart,
                            roll: game.roll,
                            volume: 1
                        };
                    } else {
                        bucketCandle.high = Math.max(bucketCandle.high, close);
                        bucketCandle.low = Math.min(bucketCandle.low, close);
                        bucketCandle.close = close;
                        bucketCandle.roll = game.roll;
                        bucketCandle.volume++;
                    }
                });
                if (bucketCandle) priceData.push(bucketCandle);

                // Define cor da vela agregada
                priceData.forEach(c => {
                    if (c.close > c.open) c.color = 'vermelho';
                    else if (c.close < c.open) c.color = 'preto';
                    else c.color = 'branco';
                });
                return priceData;
            }
        }

        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            const btn = document.getElementById('themeToggleBtn');
            if(btn) btn.innerText = isLight ? 'üåô Tema' : '‚òÄÔ∏è Tema';
            updateChart();
        }

        // Function to render the candlestick chart
        function drawChart(priceData, shouldPlaySound = false) {
            const chartContainer = document.getElementById('chart-container');
            const widgetsWrapper = document.getElementById('widgets-wrapper'); // Preserve wrapper
            const historyPanel = document.getElementById('trend-history-panel'); // Preserve history panel
            chartContainer.innerHTML = ''; // Clear previous chart or loading text

            const isLight = document.body.classList.contains('light-mode');
            
            const upColor = document.getElementById('candleUpColor') ? document.getElementById('candleUpColor').value : '#ff0055';
            const downColor = document.getElementById('candleDownColor') ? document.getElementById('candleDownColor').value : '#343a40';

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            
            const containerWidth = chartContainer.clientWidth;
            const containerHeight = chartContainer.clientHeight;
            const margin = { top: 20, right: 50, bottom: 30, left: 50 };
            const width = containerWidth - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;

            svg.setAttribute('width', containerWidth);
            svg.setAttribute('height', containerHeight);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Add SVG filter for glow effect
            const defs = document.createElementNS(svgNS, 'defs');
            defs.innerHTML = `
                <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="1.5" result="coloredBlur"></feGaussianBlur>
                    <feMerge>
                        <feMergeNode in="coloredBlur"></feMergeNode>
                        <feMergeNode in="SourceGraphic"></feMergeNode>
                    </feMerge>
                </filter>`;
            svg.appendChild(defs);

            // priceData is already prepared by generateCandles

            // 2. Find min/max price for scaling
            const minPrice = Math.min(...priceData.map(p => p.low));
            const maxPrice = Math.max(...priceData.map(p => p.high));
            const priceRange = maxPrice - minPrice;

            const y = (price) => height - ((price - minPrice) / priceRange) * height;

            // 2.1 Draw Y-Axis Grid and Labels
            const tickCount = 7; // Number of grid lines/labels
            const tickValues = [];
            const tickSize = priceRange / (tickCount - 1);

            for (let i = 0; i < tickCount; i++) {
                const tickValue = minPrice + (i * tickSize);
                const tickY = y(tickValue);

                // Grid line
                const gridLine = document.createElementNS(svgNS, 'line');
                gridLine.setAttribute('x1', 0);
                gridLine.setAttribute('y1', tickY);
                gridLine.setAttribute('x2', width);
                gridLine.setAttribute('y2', tickY);
                gridLine.setAttribute('stroke', isLight ? '#e0e0e0' : '#2a2a2a'); // Grid line color
                gridLine.setAttribute('stroke-dasharray', '2,3');
                g.appendChild(gridLine);

                // Axis label
                const axisLabel = document.createElementNS(svgNS, 'text');
                axisLabel.setAttribute('x', width + 5);
                axisLabel.setAttribute('y', tickY + 4);
                axisLabel.setAttribute('fill', isLight ? '#666' : '#888');
                axisLabel.setAttribute('font-size', '10px');
                axisLabel.textContent = tickValue.toFixed(0);
                g.appendChild(axisLabel);
            }

            // Define dimensions for candles and indicators
            const candleWidth = Math.max(1, width / priceData.length * 0.5); 
            const candleSpacing = width / priceData.length;

            // Draw Bollinger Bands if enabled (Before candles to be in background)
            const showBB = document.getElementById('bbToggle') && document.getElementById('bbToggle').checked;

            if (showBB && priceData.length > 0) {
                const bbPeriodInput = document.getElementById('bbPeriodInput');
                const bbPeriod = bbPeriodInput ? parseInt(bbPeriodInput.value) : 20;
                const bbStdDevInput = document.getElementById('bbStdDevInput');
                const bbStdDev = bbStdDevInput ? parseFloat(bbStdDevInput.value) : 2;

                const bbData = calculateBollingerBands(priceData, bbPeriod, bbStdDev);
                
                // Draw Area
                let areaPath = "";
                let firstPoint = true;
                for(let i=0; i<bbData.upper.length; i++) {
                    if(bbData.upper[i] !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(bbData.upper[i]);
                        if(firstPoint) { areaPath = `M ${x} ${yVal}`; firstPoint = false; }
                        else areaPath += ` L ${x} ${yVal}`;
                    }
                }
                for(let i=bbData.lower.length-1; i>=0; i--) {
                    if(bbData.lower[i] !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(bbData.lower[i]);
                        areaPath += ` L ${x} ${yVal}`;
                    }
                }
                areaPath += " Z";
                if (areaPath !== "") {
                    const area = document.createElementNS(svgNS, 'path');
                    area.setAttribute('d', areaPath);
                    area.setAttribute('fill', 'rgba(0, 210, 255, 0.15)');
                    area.setAttribute('stroke', 'none');
                    g.appendChild(area);
                }

                // Helper to draw line
                const drawLine = (data, color, dash) => {
                    let path = "";
                    data.forEach((val, i) => {
                        if (val !== null) {
                            const x = i * candleSpacing + candleWidth / 2;
                            const yVal = y(val);
                            if (path === "") path = `M ${x} ${yVal}`;
                            else path += ` L ${x} ${yVal}`;
                        }
                    });
                    if (path !== "") {
                        const line = document.createElementNS(svgNS, 'path');
                        line.setAttribute('d', path);
                        line.setAttribute('stroke', color);
                        line.setAttribute('stroke-width', '1.5');
                        line.setAttribute('fill', 'none');
                        if(dash) line.setAttribute('stroke-dasharray', dash);
                        g.appendChild(line);
                    }
                };
                drawLine(bbData.upper, '#00d2ff');
                drawLine(bbData.lower, '#00d2ff');
                drawLine(bbData.middle, '#00d2ff', '4,4');

                // Draw Alerts for BB Touches
                let alertTriggered = false;

                priceData.forEach((d, i) => {
                    if (bbData.upper[i] !== null && bbData.lower[i] !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const isLast = i === priceData.length - 1;
                        
                        // Touch Upper Band
                        if (d.high >= bbData.upper[i]) {
                            const yVal = y(d.high) - 10; 
                            const marker = document.createElementNS(svgNS, 'circle');
                            marker.setAttribute('cx', x); marker.setAttribute('cy', yVal); marker.setAttribute('r', 3);
                            marker.setAttribute('fill', '#ff0055'); marker.setAttribute('stroke', '#fff'); marker.setAttribute('stroke-width', '1');
                            if (isLast) {
                                marker.classList.add('bb-alert-marker');
                                alertTriggered = true;
                            }
                            g.appendChild(marker);
                        }
                        // Touch Lower Band
                        if (d.low <= bbData.lower[i]) {
                            const yVal = y(d.low) + 10; 
                            const marker = document.createElementNS(svgNS, 'circle');
                            marker.setAttribute('cx', x); marker.setAttribute('cy', yVal); marker.setAttribute('r', 3);
                            marker.setAttribute('fill', '#00ff88'); marker.setAttribute('stroke', '#fff'); marker.setAttribute('stroke-width', '1');
                            if (isLast) {
                                marker.classList.add('bb-alert-marker');
                                alertTriggered = true;
                            }
                            g.appendChild(marker);
                        }
                    }
                });

                if (alertTriggered && shouldPlaySound) playAlertSound();
            }

            // 3. Draw candles
            priceData.forEach((d, i) => {
                const x = i * candleSpacing;
                
                // Wick
                const wick = document.createElementNS(svgNS, 'line');
                wick.setAttribute('x1', x + candleWidth / 2);
                wick.setAttribute('y1', y(d.high));
                wick.setAttribute('x2', x + candleWidth / 2);
                wick.setAttribute('y2', y(d.low));
                
                wick.classList.add('candle-wick');
                // Body
                const body = document.createElementNS(svgNS, 'rect');
                body.setAttribute('x', x);
                body.setAttribute('y', y(Math.max(d.open, d.close)));
                body.setAttribute('width', candleWidth);
                body.setAttribute('height', Math.max(1, Math.abs(y(d.open) - y(d.close)))); // Min height of 1 for dojis

                let candleColor;
                if (d.color === 'vermelho') {
                    candleColor = upColor; // Custom Up Color
                } else if (d.color === 'preto') {
                    candleColor = downColor; // Custom Down Color
                } else { // branco
                    candleColor = isLight ? '#cccccc' : '#ffffff'; // White/Gray for doji
                }
                
                wick.setAttribute('stroke', candleColor);
                wick.setAttribute('stroke-width', '1.5');
                body.setAttribute('fill', candleColor);
                
                g.appendChild(wick);
                g.appendChild(body);

                // Highlight White (Branco) results
                if (d.color === 'branco') {
                    const markerX = x + candleWidth / 2;
                    const markerY = y(d.high) - 12;
                    const size = 4;
                    
                    const diamond = document.createElementNS(svgNS, 'polygon');
                    diamond.setAttribute('points', `${markerX},${markerY-size} ${markerX+size},${markerY} ${markerX},${markerY+size} ${markerX-size},${markerY}`);
                    diamond.setAttribute('fill', '#ffffff');
                    diamond.setAttribute('stroke', '#00d2ff');
                    diamond.setAttribute('stroke-width', '1');
                    g.appendChild(diamond);

                    const label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', markerX);
                    label.setAttribute('y', markerY - 8);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', isLight ? '#333' : '#fff');
                    label.setAttribute('font-size', '9px');
                    label.setAttribute('font-weight', 'bold');
                    label.textContent = '14x';
                    g.appendChild(label);
                }

                // Hit area for tooltip
                const hitArea = document.createElementNS(svgNS, 'rect');
                hitArea.setAttribute('x', x);
                hitArea.setAttribute('y', 0);
                hitArea.setAttribute('width', candleSpacing);
                hitArea.setAttribute('height', height);
                hitArea.setAttribute('fill', 'transparent');
                // Store data for touch interaction
                hitArea.dataset.time = d.time;
                hitArea.dataset.roll = d.roll;
                hitArea.style.cursor = 'crosshair';

                hitArea.addEventListener('mousemove', (e) => {
                    const tooltip = document.getElementById('chart-tooltip');
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';
                    const stoneColor = identificarCor(d.roll);
                    const colorHex = stoneColor === 'vermelho' ? '#ff0055' : (stoneColor === 'preto' ? '#aaa' : '#fff');
                    tooltip.innerHTML = `<div style="margin-bottom:4px; border-bottom:1px solid #444; padding-bottom:2px;"><strong>${d.time}</strong></div><div>Pedra: <span style="color:${colorHex}; font-weight:bold; font-size:1.1rem;">${d.roll}</span></div><div>Cor: ${stoneColor.toUpperCase()}</div>`;
                });
                hitArea.addEventListener('mouseleave', () => { document.getElementById('chart-tooltip').style.display = 'none'; });
                g.appendChild(hitArea);
            });

            // Draw Fractals and Trend Lines
            const showFractals = document.getElementById('fractalsToggle') && document.getElementById('fractalsToggle').checked;
            const showTrendLines = document.getElementById('trendLineToggle') && document.getElementById('trendLineToggle').checked;
            const topFractals = [];
            const bottomFractals = [];

            if ((showFractals || showTrendLines) && priceData.length >= 5) {
                for (let i = 2; i < priceData.length - 2; i++) {
                    const d = priceData[i];
                    const high = d.high;
                    const low = d.low;
                    
                    // Fractal Top (High)
                    if (high > priceData[i-1].high && high > priceData[i-2].high &&
                        high > priceData[i+1].high && high > priceData[i+2].high) {
                        topFractals.push({ index: i, price: high });
                        if (showFractals) {
                            const x = i * candleSpacing + candleWidth / 2;
                            const yPos = y(high) - 12;
                            const marker = document.createElementNS(svgNS, 'path');
                            marker.setAttribute('d', `M ${x-4} ${yPos+4} L ${x} ${yPos-4} L ${x+4} ${yPos+4} Z`); // Up pointing triangle
                            marker.setAttribute('fill', '#00d2ff');
                            g.appendChild(marker);
                        }
                    }

                    // Fractal Bottom (Low)
                    if (low < priceData[i-1].low && low < priceData[i-2].low &&
                        low < priceData[i+1].low && low < priceData[i+2].low) {
                        bottomFractals.push({ index: i, price: low });
                        if (showFractals) {
                            const x = i * candleSpacing + candleWidth / 2;
                            const yPos = y(low) + 12;
                            const marker = document.createElementNS(svgNS, 'path');
                            marker.setAttribute('d', `M ${x-4} ${yPos-4} L ${x} ${yPos+4} L ${x+4} ${yPos-4} Z`); // Down pointing triangle
                            marker.setAttribute('fill', '#ff0055');
                            g.appendChild(marker);
                        }
                    }
                }
            }

            if (showTrendLines) {
                // Top Trendline
                if (topFractals.length >= 2) {
                    const p1 = topFractals[topFractals.length - 2];
                    const p2 = topFractals[topFractals.length - 1];
                    const x1 = p1.index * candleSpacing + candleWidth / 2;
                    const y1 = y(p1.price);
                    const x2 = p2.index * candleSpacing + candleWidth / 2;
                    const y2 = y(p2.price);
                    
                    const slope = (y2 - y1) / (x2 - x1);
                    const xEnd = width;
                    const yEnd = y1 + slope * (xEnd - x1);
                    
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', xEnd); line.setAttribute('y2', yEnd);
                    line.setAttribute('stroke', '#00d2ff');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,5');
                    g.appendChild(line);
                }
                // Bottom Trendline
                if (bottomFractals.length >= 2) {
                    const p1 = bottomFractals[bottomFractals.length - 2];
                    const p2 = bottomFractals[bottomFractals.length - 1];
                    const x1 = p1.index * candleSpacing + candleWidth / 2;
                    const y1 = y(p1.price);
                    const x2 = p2.index * candleSpacing + candleWidth / 2;
                    const y2 = y(p2.price);
                    
                    const slope = (y2 - y1) / (x2 - x1);
                    const xEnd = width;
                    const yEnd = y1 + slope * (xEnd - x1);
                    
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', xEnd); line.setAttribute('y2', yEnd);
                    line.setAttribute('stroke', '#ff0055');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,5');
                    g.appendChild(line);
                }
            }

            // Support and Resistance Logic
            const showSR = document.getElementById('srToggle') && document.getElementById('srToggle').checked;
            if (showSR && typeof allCandles !== 'undefined' && allCandles.length > 0) {
                const srLookbackInput = document.getElementById('srLookbackInput');
                const srLinesInput = document.getElementById('srLinesInput');
                const lookback = srLookbackInput ? parseInt(srLookbackInput.value) : 200;
                const maxLines = srLinesInput ? parseInt(srLinesInput.value) : 3;
                const endIndex = viewStartIndex + priceData.length;
                const startIndex = Math.max(0, endIndex - lookback);
                const resistances = [];
                const supports = [];

                for (let i = startIndex + 2; i < endIndex - 2; i++) {
                    if (i >= allCandles.length - 2) break;
                    const d = allCandles[i];
                    const prev1 = allCandles[i-1]; const prev2 = allCandles[i-2];
                    const next1 = allCandles[i+1]; const next2 = allCandles[i+2];

                    if (d.high > prev1.high && d.high > prev2.high && d.high > next1.high && d.high > next2.high) {
                        resistances.push(d.high);
                    }
                    if (d.low < prev1.low && d.low < prev2.low && d.low < next1.low && d.low < next2.low) {
                        supports.push(d.low);
                    }
                }

                const uniqueRes = [...new Set(resistances.reverse())].slice(0, maxLines);
                const uniqueSup = [...new Set(supports.reverse())].slice(0, maxLines);

                uniqueRes.forEach(price => {
                    const yVal = y(price);
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', 0); line.setAttribute('y1', yVal);
                    line.setAttribute('x2', width); line.setAttribute('y2', yVal);
                    line.setAttribute('stroke', '#ff0055'); line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,2'); line.setAttribute('opacity', '0.8');
                    g.appendChild(line);
                    const label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', width - 5); label.setAttribute('y', yVal - 3);
                    label.setAttribute('text-anchor', 'end'); label.setAttribute('fill', '#ff0055');
                    label.setAttribute('font-size', '9px'); label.textContent = 'RES ' + price;
                    g.appendChild(label);
                });

                uniqueSup.forEach(price => {
                    const yVal = y(price);
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', 0); line.setAttribute('y1', yVal);
                    line.setAttribute('x2', width); line.setAttribute('y2', yVal);
                    line.setAttribute('stroke', '#00ff88'); line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,2'); line.setAttribute('opacity', '0.8');
                    g.appendChild(line);
                    const label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', width - 5); label.setAttribute('y', yVal + 10);
                    label.setAttribute('text-anchor', 'end'); label.setAttribute('fill', '#00ff88');
                    label.setAttribute('font-size', '9px'); label.textContent = 'SUP ' + price;
                    g.appendChild(label);
                });
            }

            // Draw SMA if enabled
            const showSMA = document.getElementById('smaToggle') && document.getElementById('smaToggle').checked;
            if (showSMA && priceData.length > 0) {
                const smaPeriodInput = document.getElementById('smaPeriodInput');
                const smaPeriod = smaPeriodInput ? parseInt(smaPeriodInput.value) : 14;
                const smaValues = calculateSMA(priceData, smaPeriod);
                
                let smaPath = "";
                smaValues.forEach((val, i) => {
                    if (val !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(val);
                        if (smaPath === "") smaPath = `M ${x} ${yVal}`;
                        else smaPath += ` L ${x} ${yVal}`;
                    }
                });

                if (smaPath !== "") {
                    const smaLine = document.createElementNS(svgNS, 'path');
                    smaLine.setAttribute('d', smaPath);
                    smaLine.setAttribute('stroke', '#ff9800');
                    smaLine.setAttribute('stroke-width', '1.5');
                    smaLine.setAttribute('fill', 'none');
                    smaLine.style.pointerEvents = 'none';
                    g.appendChild(smaLine);
                }
            }

            // Draw EMA if enabled
            const showEMA = document.getElementById('emaToggle') && document.getElementById('emaToggle').checked;
            if (showEMA && priceData.length > 0) {
                const emaPeriodInput = document.getElementById('emaPeriodInput');
                const emaPeriod = emaPeriodInput ? parseInt(emaPeriodInput.value) : 9;
                const emaValues = calculateEMA(priceData, emaPeriod);

                let emaPath = "";
                emaValues.forEach((val, i) => {
                    if (val !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(val);
                        if (emaPath === "") emaPath = `M ${x} ${yVal}`;
                        else emaPath += ` L ${x} ${yVal}`;
                    }
                });

                if (emaPath !== "") {
                    const emaLine = document.createElementNS(svgNS, 'path');
                    emaLine.setAttribute('d', emaPath);
                    emaLine.setAttribute('stroke', '#00ff88'); // Green color for EMA
                    emaLine.setAttribute('stroke-width', '1.5');
                    emaLine.setAttribute('fill', 'none');
                    g.appendChild(emaLine);
                }
            }
            // Redraw persistent lines
            const drawingsGroup = document.createElementNS(svgNS, 'g');
            g.appendChild(drawingsGroup);
            drawnLines.forEach(lineData => {
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', lineData.x1);
                line.setAttribute('y1', lineData.y1);
                line.setAttribute('x2', lineData.x2);
                line.setAttribute('y2', lineData.y2);
                line.setAttribute('stroke', lineData.color || '#00d2ff');
                line.setAttribute('stroke-width', '1.5');
                drawingsGroup.appendChild(line);
            });

            // 4. Draw current price line and label
            if (priceData.length > 0) {
                const lastCandle = priceData[priceData.length - 1];
                const lastClosePrice = lastCandle.close;
                const lastY = y(lastClosePrice);

                // Dashed line across the chart
                const currentPriceLine = document.createElementNS(svgNS, 'line');
                currentPriceLine.setAttribute('x1', 0);
                currentPriceLine.setAttribute('y1', lastY);
                currentPriceLine.setAttribute('x2', width);
                currentPriceLine.setAttribute('y2', lastY);
                currentPriceLine.setAttribute('stroke', '#ffc107');
                currentPriceLine.setAttribute('stroke-width', '1.5');
                currentPriceLine.setAttribute('stroke-dasharray', '4, 4');
                currentPriceLine.classList.add('current-price-line');
                g.appendChild(currentPriceLine);

                // Price label background on the right axis
                const priceLabelBg = document.createElementNS(svgNS, 'rect');
                priceLabelBg.setAttribute('x', width);
                priceLabelBg.setAttribute('y', lastY - 10);
                priceLabelBg.setAttribute('width', margin.right);
                priceLabelBg.setAttribute('height', 20);
                priceLabelBg.setAttribute('fill', '#ffc107');
                g.appendChild(priceLabelBg);

                // Price label text
                const priceLabel = document.createElementNS(svgNS, 'text');
                priceLabel.setAttribute('x', width + 5);
                priceLabel.setAttribute('y', lastY + 4);
                priceLabel.setAttribute('fill', '#000'); // Always black on yellow bg
                priceLabel.setAttribute('font-size', '12px');
                priceLabel.setAttribute('font-weight', 'bold');
                priceLabel.textContent = lastClosePrice.toFixed(0);
                g.appendChild(priceLabel);

                // Vertical dotted line for next candle
                const nextCandleLine = document.createElementNS(svgNS, 'line');
                nextCandleLine.setAttribute('x1', width);
                nextCandleLine.setAttribute('y1', 0);
                nextCandleLine.setAttribute('x2', width);
                nextCandleLine.setAttribute('y2', height);
                nextCandleLine.setAttribute('stroke', isLight ? '#999' : '#555');
                nextCandleLine.setAttribute('stroke-width', '1');
                nextCandleLine.setAttribute('stroke-dasharray', '4, 4');
                g.appendChild(nextCandleLine);

                // Countdown for next candle
                const timeframe = document.getElementById('timeframeSelect').value;
                if (timeframe !== 'tick') {
                    const timerLabel = document.createElementNS(svgNS, 'text');
                    timerLabel.setAttribute('id', 'candle-countdown');
                    timerLabel.setAttribute('x', width - 5);
                    timerLabel.setAttribute('y', lastY - 8);
                    timerLabel.setAttribute('text-anchor', 'end');
                    timerLabel.setAttribute('fill', '#ffc107');
                    timerLabel.setAttribute('font-size', '11px');
                    timerLabel.setAttribute('font-weight', 'bold');
                    timerLabel.textContent = "--:--";
                    g.appendChild(timerLabel);
                }
            }

            // Draw Average Price of Last 10 White Candles
            if (typeof allCandles !== 'undefined' && allCandles.length > 0) {
                const allWhites = allCandles.filter(c => c.color === 'branco');
                if (allWhites.length > 0) {
                    const last10 = allWhites.slice(-10);
                    const avgPrice = last10.reduce((sum, c) => sum + c.close, 0) / last10.length;
                    const lineY = y(avgPrice);

                    const avgLine = document.createElementNS(svgNS, 'line');
                    avgLine.setAttribute('x1', 0); avgLine.setAttribute('y1', lineY);
                    avgLine.setAttribute('x2', width); avgLine.setAttribute('y2', lineY);
                    avgLine.setAttribute('stroke', '#00d2ff'); avgLine.setAttribute('stroke-width', '1');
                    avgLine.setAttribute('stroke-dasharray', '4, 4'); avgLine.setAttribute('opacity', '0.8');
                    g.appendChild(avgLine);

                    const avgLabel = document.createElementNS(svgNS, 'text');
                    avgLabel.setAttribute('x', 10); avgLabel.setAttribute('y', lineY - 4);
                    avgLabel.setAttribute('fill', '#00d2ff'); avgLabel.setAttribute('font-size', '10px');
                    avgLabel.textContent = `M√©dia Brancos (10): ${avgPrice.toFixed(0)}`;
                    g.appendChild(avgLabel);
                }
            }

            // Add drawing overlay and listeners
            const overlay = document.createElementNS(svgNS, 'rect');
            overlay.setAttribute('width', width);
            overlay.setAttribute('height', height);
            overlay.setAttribute('fill', 'transparent');
            g.appendChild(overlay);

            overlay.addEventListener('mousedown', (e) => {
                if (!isDrawMode) return;
                isDrawing = true;
                const rect = overlay.getBoundingClientRect();
                startPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };

                const drawingColor = document.getElementById('drawingColorPicker').value;
                currentLine = document.createElementNS(svgNS, 'line');
                currentLine.setAttribute('x1', startPoint.x);
                currentLine.setAttribute('y1', startPoint.y);
                currentLine.setAttribute('x2', startPoint.x);
                currentLine.setAttribute('y2', startPoint.y);
                currentLine.setAttribute('stroke', drawingColor);
                currentLine.setAttribute('stroke-width', '1.5');
                currentLine.setAttribute('stroke-dasharray', '4,4');
                drawingsGroup.appendChild(currentLine);
            });
            
            // Touch support for drawing
            overlay.addEventListener('touchstart', (e) => {
                if (!isDrawMode) return;
                e.preventDefault();
                const touch = e.touches[0];
                overlay.dispatchEvent(new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY }));
            }, { passive: false });
            overlay.addEventListener('touchmove', (e) => {
                if (!isDrawing) return;
                e.preventDefault();
                const touch = e.touches[0];
                overlay.dispatchEvent(new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY }));
            }, { passive: false });
            overlay.addEventListener('touchend', (e) => {
                if (isDrawing) overlay.dispatchEvent(new MouseEvent('mouseup', {}));
            });

            overlay.addEventListener('mousemove', (e) => {
                if (!isDrawing || !currentLine) return;
                const rect = overlay.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                currentLine.setAttribute('x2', currentX);
                currentLine.setAttribute('y2', currentY);
            });

            overlay.addEventListener('mouseup', () => {
                if (!isDrawing) return;
                
                const drawingColor = document.getElementById('drawingColorPicker').value;
                
                isDrawing = false;
                drawnLines.push({ 
                    x1: parseFloat(currentLine.getAttribute('x1')), 
                    y1: parseFloat(currentLine.getAttribute('y1')), 
                    x2: parseFloat(currentLine.getAttribute('x2')), 
                    y2: parseFloat(currentLine.getAttribute('y2')),
                    color: drawingColor
                });
                currentLine = null;
                updateChart(); // Redraw to make the line permanent
            });

            chartContainer.appendChild(svg);
            
            // Re-append widgets wrapper
            if(widgetsWrapper) chartContainer.appendChild(widgetsWrapper);
            if(historyPanel) chartContainer.appendChild(historyPanel);
            
            updateMarketStrength(priceData);
            updateMarketVolatility(priceData);
            updateMarketTrend(priceData);

            // Touch support for tooltips (Chart Pan/Scan)
            svg.addEventListener('touchmove', (e) => {
                if (isDrawMode) return; // Let drawing handle it if in draw mode
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.tagName === 'rect' && target.getAttribute('fill') === 'transparent' && target.dataset.roll) {
                    e.preventDefault();
                    const tooltip = document.getElementById('chart-tooltip');
                    tooltip.style.display = 'block';
                    
                    // Position logic
                    let left = touch.clientX + 15;
                    if (left + 120 > window.innerWidth) left = touch.clientX - 135;
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = (touch.clientY + 15) + 'px';

                    const stoneColor = identificarCor(target.dataset.roll);
                    const colorHex = stoneColor === 'vermelho' ? '#ff0055' : (stoneColor === 'preto' ? '#aaa' : '#fff');
                    tooltip.innerHTML = `<div style="margin-bottom:4px; border-bottom:1px solid #444; padding-bottom:2px;"><strong>${target.dataset.time}</strong></div><div>Pedra: <span style="color:${colorHex}; font-weight:bold; font-size:1.1rem;">${target.dataset.roll}</span></div><div>Cor: ${stoneColor.toUpperCase()}</div>`;
                }
            }, { passive: false });
            
            svg.addEventListener('touchend', () => {
                document.getElementById('chart-tooltip').style.display = 'none';
            });
        }

        function updateMarketStrength(data) {
            const widget = document.getElementById('market-strength');
            const showWidgets = document.getElementById('widgetsToggle') ? document.getElementById('widgetsToggle').checked : true;
            if (!widget || data.length < 5 || !showWidgets) { if(widget) widget.style.display = 'none'; return; }
            widget.style.display = 'flex';

            // Analyze last 20 candles
            const lookback = Math.min(data.length, 20);
            const recent = data.slice(-lookback);
            let redPower = 0, blackPower = 0, whitePower = 0;
            
            recent.forEach(d => {
                if (d.color === 'vermelho') redPower++;
                else if (d.color === 'preto') blackPower++;
                else if (d.color === 'branco') whitePower++;
            });
            
            const total = redPower + blackPower + whitePower;
            if (total === 0) return;

            let strength = 0, color = '#888', icon = '‚ûñ';
            
            if (whitePower > redPower && whitePower > blackPower) {
                strength = (whitePower / total) * 100; color = '#ffffff'; icon = '‚ö™';
                widget.style.borderColor = '#ffffff'; widget.style.boxShadow = '0 0 15px rgba(255, 255, 255, 0.5)';
            } else if (redPower > blackPower) {
                strength = (redPower / total) * 100; color = '#ff0055'; icon = 'üî¥';
                widget.style.borderColor = '#ff0055'; widget.style.boxShadow = '0 0 15px rgba(255, 0, 85, 0.2)';
            } else if (blackPower > redPower) {
                strength = (blackPower / total) * 100; color = '#888'; icon = '‚ö´';
                widget.style.borderColor = '#888'; widget.style.boxShadow = '0 0 15px rgba(136, 136, 136, 0.2)';
            } else {
                strength = 50; color = '#ff9800'; icon = '‚öñÔ∏è';
                widget.style.borderColor = '#ff9800'; widget.style.boxShadow = '0 0 15px rgba(255, 152, 0, 0.2)';
            }
            
            const fill = document.getElementById('strength-fill');
            const val = document.getElementById('strength-val');
            const iconEl = document.getElementById('strength-icon');

            fill.style.height = `${strength}%`; fill.style.backgroundColor = color; fill.style.boxShadow = `0 0 15px ${color}`;
            val.innerText = `${Math.round(strength)}%`; val.style.color = color;
            iconEl.innerText = icon;
        }

        function getTrendSignal(data) {
            if (data.length < 26) return { signal: "NEUTRO", color: "#888", icon: "‚öñÔ∏è" };

            const smaData = calculateSMA(data, 14);
            const lastSMA = smaData[smaData.length - 1];
            const lastClose = data[data.length - 1].close;

            const macdData = calculateMACD(data, 12, 26, 9);
            const lastHist = macdData.histogram[macdData.histogram.length - 1];

            let signal = "NEUTRO";
            let color = "#888";
            let icon = "‚öñÔ∏è";

            if (lastSMA !== null && lastHist !== null) {
                const priceAboveSMA = lastClose > lastSMA;
                const macdBullish = lastHist > 0;

                if (priceAboveSMA && macdBullish) {
                    signal = "COMPRA"; color = "#ff0055"; icon = "üî¥";
                } else if (!priceAboveSMA && !macdBullish) {
                    signal = "VENDA"; color = "#ffffff"; icon = "‚ö´";
                }
            }
            return { signal, color, icon };
        }

        function triggerTrendAlert(signal) {
            const color = signal === "COMPRA" ? "rgba(255, 0, 85, 0.3)" : "rgba(255, 255, 255, 0.2)";
            const flash = document.createElement('div');
            Object.assign(flash.style, { position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: color, zIndex: 99999, pointerEvents: 'none', transition: 'opacity 0.5s', opacity: 0 });
            document.body.appendChild(flash);
            requestAnimationFrame(() => { flash.style.opacity = 1; setTimeout(() => { flash.style.opacity = 0; setTimeout(() => flash.remove(), 500); }, 200); });
        }

        function toggleHistory() {
            const panel = document.getElementById('trend-history-panel');
            const checked = document.getElementById('historyToggle').checked;
            if (panel) panel.style.display = checked ? 'flex' : 'none';
        }

        function addToTrendHistory(signal, color, icon) {
            const list = document.getElementById('history-list');
            if (!list) return;

            const now = new Date();
            const timeStr = now.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            // Remove placeholder
            if (list.children.length > 0 && list.children[0].innerText.includes('Aguardando')) list.innerHTML = '';

            const item = document.createElement('li');
            item.className = 'history-item';
            item.innerHTML = `<span class="history-time">${timeStr}</span><span class="history-signal" style="color: ${color}">${icon} ${signal}</span>`;

            list.prepend(item);
            while (list.children.length > 10) list.removeChild(list.lastChild);
        }

        function updateMarketTrend(data) {
            const widget = document.getElementById('market-trend');
            const showWidgets = document.getElementById('widgetsToggle') ? document.getElementById('widgetsToggle').checked : true;
            if (!widget || data.length < 26 || !showWidgets) { if(widget) widget.style.display = 'none'; return; }
            widget.style.display = 'flex';

            const { signal, color, icon } = getTrendSignal(data);

            const val = document.getElementById('trend-val');
            const iconEl = document.getElementById('trend-icon');
            
            val.innerText = signal; val.style.color = color; iconEl.innerText = icon;
            widget.style.borderColor = color; widget.style.boxShadow = `0 0 15px ${color}33`;
        }

        function updateMarketVolatility(data) {
            const widget = document.getElementById('market-volatility');
            const showWidgets = document.getElementById('widgetsToggle') ? document.getElementById('widgetsToggle').checked : true;
            if (!widget || data.length < 20 || !showWidgets) { if(widget) widget.style.display = 'none'; return; }
            widget.style.display = 'flex';

            // Calculate ATR first
            const atrData = calculateATR(data, 14);
            
            // Check if ATR is dynamic enough (in Tick mode it's constant)
            let metricData = atrData;
            let isFlat = false;
            
            const validATRs = atrData.filter(v => v !== null);
            if (validATRs.length > 0) {
                const recentATRs = validATRs.slice(-20);
                const minA = Math.min(...recentATRs);
                const maxA = Math.max(...recentATRs);
                if (maxA === minA) isFlat = true;
            }

            // If ATR is flat, calculate Standard Deviation of Price
            if (isFlat) {
                const period = 20;
                const stdDevData = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) { stdDevData.push(null); continue; }
                    let sum = 0;
                    for (let j = 0; j < period; j++) sum += data[i - j].close;
                    const mean = sum / period;
                    let sumSq = 0;
                    for (let j = 0; j < period; j++) sumSq += Math.pow(data[i - j].close - mean, 2);
                    stdDevData.push(Math.sqrt(sumSq / period));
                }
                metricData = stdDevData;
            }

            const currentMetric = metricData[metricData.length - 1];
            if (currentMetric === null || currentMetric === undefined) return;

            // Normalize ATR relative to recent history (last 50 candles)
            const lookbackInput = document.getElementById('volatilityLookback');
            const lookbackValue = lookbackInput ? parseInt(lookbackInput.value) : 50;
            const lookback = Math.min(data.length, lookbackValue);
            const recentMetrics = [];
            
            for(let i = data.length - lookback; i < data.length; i++) {
                if(metricData[i] !== null) recentMetrics.push(metricData[i]);
            }
            if (recentMetrics.length === 0) return;

            let minM = Math.min(...recentMetrics);
            let maxM = Math.max(...recentMetrics);
            if (maxM === minM) maxM = minM + 0.001;

            const volatility = Math.max(0, Math.min(100, ((currentMetric - minM) / (maxM - minM)) * 100));
            
            const fill = document.getElementById('volatility-fill');
            const val = document.getElementById('volatility-val');
            const iconEl = document.getElementById('volatility-icon');

            let color = volatility >= 60 ? '#ff0055' : (volatility >= 30 ? '#ff9800' : '#00ff88');
            let icon = volatility >= 60 ? '‚ö°' : (volatility >= 30 ? '„Ä∞Ô∏è' : 'üí§');

            // Sugest√£o de Branco em Alta Volatilidade
            const whiteThresholdInput = document.getElementById('volatilityWhiteThreshold');
            const whiteThreshold = whiteThresholdInput ? parseInt(whiteThresholdInput.value) : 90;

            if (volatility >= whiteThreshold) {
                color = '#ffffff';
                icon = '‚ö™';
                val.innerText = "POSS√çVEL ‚ö™";
                val.style.fontSize = "0.6rem";
            } else {
                val.innerText = `${Math.round(volatility)}%`;
                val.style.fontSize = "1.1rem";
            }

            fill.style.height = `${volatility}%`; fill.style.backgroundColor = color; fill.style.boxShadow = `0 0 15px ${color}`;
            val.style.color = color;
            iconEl.innerText = icon;
            
            widget.style.borderColor = color; widget.style.boxShadow = `0 0 15px ${color}33`;
        }

        function drawRSIChart(priceData) {
            const rsiContainer = document.getElementById('rsi-container');
            const showRSI = document.getElementById('rsiToggle').checked;
            
            if (!showRSI) {
                rsiContainer.style.display = 'none';
                return;
            }
            rsiContainer.style.display = 'block';
            rsiContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');

            const rsiPeriodInput = document.getElementById('rsiPeriodInput');
            const rsiPeriod = rsiPeriodInput ? parseInt(rsiPeriodInput.value) : 14;

            const rsiValues = calculateRSI(priceData, rsiPeriod);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = rsiContainer.clientWidth;
            const height = rsiContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Background lines for 30 and 70
            const y70 = plotHeight * (1 - 0.7);
            const y30 = plotHeight * (1 - 0.3);
            
            const line70 = document.createElementNS(svgNS, 'line');
            line70.setAttribute('x1', 0); line70.setAttribute('y1', y70);
            line70.setAttribute('x2', plotWidth); line70.setAttribute('y2', y70);
            line70.setAttribute('stroke', '#ff0055'); line70.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(line70);

            const line30 = document.createElementNS(svgNS, 'line');
            line30.setAttribute('x1', 0); line30.setAttribute('y1', y30);
            line30.setAttribute('x2', plotWidth); line30.setAttribute('y2', y30);
            line30.setAttribute('stroke', '#00ff88'); line30.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(line30);

            // Draw RSI Line
            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);
            
            let pathD = "";
            rsiValues.forEach((val, i) => {
                if (val !== null) {
                    const x = i * candleSpacing + candleWidth / 2;
                    const y = plotHeight * (1 - (val / 100));
                    if (pathD === "") pathD = `M ${x} ${y}`;
                    else pathD += ` L ${x} ${y}`;
                }
            });

            if (pathD !== "") {
                const path = document.createElementNS(svgNS, 'path');
                path.setAttribute('d', pathD);
                path.setAttribute('stroke', '#a100ff'); path.classList.add('indicator-line');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                g.appendChild(path);
            }
            
            // Add label
            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', '#a100ff'); label.setAttribute('font-size', '10px');
            label.textContent = `RSI (${rsiPeriod})`;
            svg.appendChild(label);

            rsiContainer.appendChild(svg);
        }

        function drawMACDChart(priceData) {
            const macdContainer = document.getElementById('macd-container');
            const showMACD = document.getElementById('macdToggle').checked;
            
            if (!showMACD) {
                macdContainer.style.display = 'none';
                return;
            }
            macdContainer.style.display = 'block';
            macdContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');

            const fastInput = document.getElementById('macdFastInput');
            const slowInput = document.getElementById('macdSlowInput');
            const signalInput = document.getElementById('macdSignalInput');
            
            const fastPeriod = fastInput ? parseInt(fastInput.value) : 12;
            const slowPeriod = slowInput ? parseInt(slowInput.value) : 26;
            const signalPeriod = signalInput ? parseInt(signalInput.value) : 9;

            const macdData = calculateMACD(priceData, fastPeriod, slowPeriod, signalPeriod);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = macdContainer.clientWidth;
            const height = macdContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const allValues = [].concat(macdData.macdLine, macdData.signalLine, macdData.histogram).filter(v => v !== null);
            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            const range = maxVal - minVal;

            const y = (val) => plotHeight - ((val - minVal) / range) * plotHeight;

            // Draw zero line
            const zeroY = y(0);
            const zeroLine = document.createElementNS(svgNS, 'line');
            zeroLine.setAttribute('x1', 0); zeroLine.setAttribute('y1', zeroY);
            zeroLine.setAttribute('x2', plotWidth); zeroLine.setAttribute('y2', zeroY);
            zeroLine.setAttribute('stroke', isLight ? '#ccc' : '#555'); zeroLine.setAttribute('stroke-dasharray', '2,2');
            g.appendChild(zeroLine);

            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);

            // Draw Histogram
            macdData.histogram.forEach((val, i) => {
                if (val !== null) {
                    const x = i * candleSpacing;
                    const barHeight = Math.abs(y(val) - zeroY);
                    const barY = val > 0 ? y(val) : zeroY;
                    
                    const bar = document.createElementNS(svgNS, 'rect');
                    bar.setAttribute('x', x); bar.setAttribute('y', barY);
                    bar.setAttribute('width', candleWidth); bar.setAttribute('height', barHeight);
                    bar.setAttribute('fill', val > 0 ? 'rgba(0, 255, 136, 0.5)' : 'rgba(255, 0, 85, 0.5)');
                    g.appendChild(bar);
                }
            });

            // Helper to draw line
            const drawLine = (data, color) => {
                let pathD = "";
                data.forEach((val, i) => { if (val !== null) { const x = i * candleSpacing + candleWidth / 2; const yVal = y(val); if (pathD === "") pathD = `M ${x} ${yVal}`; else pathD += ` L ${x} ${yVal}`; } });
                if (pathD !== "") { const path = document.createElementNS(svgNS, 'path'); path.setAttribute('d', pathD); path.setAttribute('stroke', color); path.setAttribute('stroke-width', '2'); path.setAttribute('fill', 'none'); path.classList.add('indicator-line'); g.appendChild(path); }
            };

            drawLine(macdData.macdLine, '#00d2ff');
            drawLine(macdData.signalLine, '#ff9800');

            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', isLight ? '#666' : '#ccc'); label.setAttribute('font-size', '10px');
            label.innerHTML = `<tspan fill="#00d2ff">MACD(${fastPeriod},${slowPeriod})</tspan> <tspan fill="#ff9800">Signal(${signalPeriod})</tspan>`;
            svg.appendChild(label);

            macdContainer.appendChild(svg);
        }

        function drawMACDChart(priceData) {
            const macdContainer = document.getElementById('macd-container');
            const showMACD = document.getElementById('macdToggle').checked;
            
            if (!showMACD) {
                macdContainer.style.display = 'none';
                return;
            }
            macdContainer.style.display = 'block';
            macdContainer.innerHTML = '';

            const fastInput = document.getElementById('macdFastInput');
            const slowInput = document.getElementById('macdSlowInput');
            const signalInput = document.getElementById('macdSignalInput');
            
            const fastPeriod = fastInput ? parseInt(fastInput.value) : 12;
            const slowPeriod = slowInput ? parseInt(slowInput.value) : 26;
            const signalPeriod = signalInput ? parseInt(signalInput.value) : 9;

            const macdData = calculateMACD(priceData, fastPeriod, slowPeriod, signalPeriod);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = macdContainer.clientWidth;
            const height = macdContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const allValues = [].concat(macdData.macdLine, macdData.signalLine, macdData.histogram).filter(v => v !== null);
            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            const range = maxVal - minVal;

            const y = (val) => plotHeight - ((val - minVal) / range) * plotHeight;

            // Draw zero line
            const zeroY = y(0);
            const zeroLine = document.createElementNS(svgNS, 'line');
            zeroLine.setAttribute('x1', 0); zeroLine.setAttribute('y1', zeroY);
            zeroLine.setAttribute('x2', plotWidth); zeroLine.setAttribute('y2', zeroY);
            zeroLine.setAttribute('stroke', '#555'); zeroLine.setAttribute('stroke-dasharray', '2,2');
            g.appendChild(zeroLine);

            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);

            // Draw Histogram
            macdData.histogram.forEach((val, i) => {
                if (val !== null) {
                    const x = i * candleSpacing;
                    const barHeight = Math.abs(y(val) - zeroY);
                    const barY = val > 0 ? y(val) : zeroY;
                    
                    const bar = document.createElementNS(svgNS, 'rect');
                    bar.setAttribute('x', x); bar.setAttribute('y', barY);
                    bar.setAttribute('width', candleWidth); bar.setAttribute('height', barHeight);
                    bar.setAttribute('fill', val > 0 ? 'rgba(0, 255, 136, 0.5)' : 'rgba(255, 0, 85, 0.5)');
                    g.appendChild(bar);
                }
            });

            // Helper to draw line
            const drawLine = (data, color) => {
                let pathD = "";
                data.forEach((val, i) => { if (val !== null) { const x = i * candleSpacing + candleWidth / 2; const yVal = y(val); if (pathD === "") pathD = `M ${x} ${yVal}`; else pathD += ` L ${x} ${yVal}`; } });
                if (pathD !== "") { const path = document.createElementNS(svgNS, 'path'); path.setAttribute('d', pathD); path.setAttribute('stroke', color); path.setAttribute('stroke-width', '2'); path.setAttribute('fill', 'none'); g.appendChild(path); }
            };

            drawLine(macdData.macdLine, '#00d2ff'); // MACD line in blue
            drawLine(macdData.signalLine, '#ff9800'); // Signal line in orange

            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', '#ccc'); label.setAttribute('font-size', '10px');
            label.innerHTML = `<tspan fill="#00d2ff">MACD(${fastPeriod},${slowPeriod})</tspan> <tspan fill="#ff9800">Signal(${signalPeriod})</tspan>`;
            svg.appendChild(label);

            macdContainer.appendChild(svg);
        }

        function drawVolumeChart(priceData) {
            const volumeContainer = document.getElementById('volume-container');
            const showVolume = document.getElementById('volumeToggle').checked;
            
            if (!showVolume) {
                volumeContainer.style.display = 'none';
                return;
            }
            volumeContainer.style.display = 'block';
            volumeContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');
            
            const upColor = document.getElementById('candleUpColor') ? document.getElementById('candleUpColor').value : '#ff0055';
            const downColor = document.getElementById('candleDownColor') ? document.getElementById('candleDownColor').value : '#343a40';

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = volumeContainer.clientWidth;
            const height = volumeContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 5, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const maxVol = Math.max(...priceData.map(d => d.volume));
            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);

            priceData.forEach((d, i) => {
                const x = i * candleSpacing;
                const barHeight = (d.volume / maxVol) * plotHeight;
                const y = plotHeight - barHeight;
                
                const bar = document.createElementNS(svgNS, 'rect');
                bar.setAttribute('x', x); bar.setAttribute('y', y);
                bar.setAttribute('width', candleWidth); bar.setAttribute('height', barHeight);
                
                let barColor;
                if (d.color === 'vermelho') barColor = upColor;
                else if (d.color === 'preto') barColor = downColor;
                else barColor = '#ffc107';
                
                bar.setAttribute('fill', barColor); bar.setAttribute('fill-opacity', '0.5');
                g.appendChild(bar);
            });
            
            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', isLight ? '#666' : '#ccc'); label.setAttribute('font-size', '10px');
            label.textContent = `Volume (Max: ${maxVol})`;
            svg.appendChild(label);
            volumeContainer.appendChild(svg);
        }

        function drawADXChart(priceData) {
            const adxContainer = document.getElementById('adx-container');
            const showADX = document.getElementById('adxToggle').checked;
            
            if (!showADX) {
                adxContainer.style.display = 'none';
                return;
            }
            adxContainer.style.display = 'block';
            adxContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');

            const adxData = calculateADX(priceData, 14);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = adxContainer.clientWidth;
            const height = adxContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const allValues = [].concat(adxData.adx, adxData.plusDI, adxData.minusDI).filter(v => v !== null && v >= 0 && v <= 100);
            const y = (val) => plotHeight - (val / 100) * plotHeight;

            // Draw reference line at 25
            const line25 = document.createElementNS(svgNS, 'line');
            line25.setAttribute('x1', 0); line25.setAttribute('y1', y(25));
            line25.setAttribute('x2', plotWidth); line25.setAttribute('y2', y(25));
            line25.setAttribute('stroke', isLight ? '#ccc' : '#555'); line25.setAttribute('stroke-dasharray', '2,2');
            g.appendChild(line25);

            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);

            // Helper to draw line
            const drawLine = (data, color) => {
                let pathD = "";
                data.forEach((val, i) => {
                    if (val !== null) {
                        const x = i * candleSpacing + candleWidth / 2;
                        const yVal = y(val);
                        if (pathD === "") pathD = `M ${x} ${yVal}`;
                        else pathD += ` L ${x} ${yVal}`;
                    }
                });
                if (pathD !== "") {
                    const path = document.createElementNS(svgNS, 'path');
                    path.setAttribute('d', pathD); path.classList.add('indicator-line');
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    g.appendChild(path);
                }
            };

            drawLine(adxData.plusDI, '#00ff88');
            drawLine(adxData.minusDI, '#ff0055');
            drawLine(adxData.adx, '#ffc107');

            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15);
            label.setAttribute('fill', isLight ? '#666' : '#ccc'); label.setAttribute('font-size', '10px');
            label.innerHTML = `<tspan fill="#ffc107">ADX(14)</tspan> <tspan fill="#00ff88">+DI</tspan> <tspan fill="#ff0055">-DI</tspan>`;
            svg.appendChild(label);

            adxContainer.appendChild(svg);
        }

        function drawStochasticChart(priceData) {
            const stochContainer = document.getElementById('stoch-container');
            const showStoch = document.getElementById('stochToggle').checked;
            
            if (!showStoch) { stochContainer.style.display = 'none'; return; }
            stochContainer.style.display = 'block';
            stochContainer.innerHTML = '';
            const isLight = document.body.classList.contains('light-mode');

            const kInput = document.getElementById('stochKInput');
            const dInput = document.getElementById('stochDInput');
            const smoothInput = document.getElementById('stochSmoothInput');
            const periodK = kInput ? parseInt(kInput.value) : 14;
            const periodD = dInput ? parseInt(dInput.value) : 3;
            const smooth = smoothInput ? parseInt(smoothInput.value) : 3;

            const stochData = calculateStochastic(priceData, periodK, periodD, smooth);
            
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            const width = stochContainer.clientWidth;
            const height = stochContainer.clientHeight;
            const margin = { top: 10, right: 50, bottom: 20, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width); svg.setAttribute('height', height);
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            const y80 = plotHeight * (1 - 0.8);
            const y20 = plotHeight * (1 - 0.2);
            
            const line80 = document.createElementNS(svgNS, 'line');
            line80.setAttribute('x1', 0); line80.setAttribute('y1', y80); line80.setAttribute('x2', plotWidth); line80.setAttribute('y2', y80);
            line80.setAttribute('stroke', '#ff0055'); line80.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(line80);

            const line20 = document.createElementNS(svgNS, 'line');
            line20.setAttribute('x1', 0); line20.setAttribute('y1', y20); line20.setAttribute('x2', plotWidth); line20.setAttribute('y2', y20);
            line20.setAttribute('stroke', '#00ff88'); line20.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(line20);

            const candleSpacing = plotWidth / priceData.length;
            const candleWidth = Math.max(1, plotWidth / priceData.length * 0.5);
            
            const drawLine = (data, color) => {
                let pathD = "";
                data.forEach((val, i) => { if (val !== null) { const x = i * candleSpacing + candleWidth / 2; const y = plotHeight * (1 - (val / 100)); const clampedY = Math.max(0, Math.min(plotHeight, y)); if (pathD === "") pathD = `M ${x} ${clampedY}`; else pathD += ` L ${x} ${clampedY}`; } });
                if (pathD !== "") { const path = document.createElementNS(svgNS, 'path'); path.setAttribute('d', pathD); path.setAttribute('stroke', color); path.setAttribute('stroke-width', '1.5'); path.setAttribute('fill', 'none'); g.appendChild(path); }
            };

            drawLine(stochData.k, '#00d2ff');
            drawLine(stochData.d, '#ff9800');
            
            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('x', 5); label.setAttribute('y', 15); label.setAttribute('fill', isLight ? '#666' : '#ccc'); label.setAttribute('font-size', '10px');
            label.innerHTML = `<tspan fill="#00d2ff">%K(${periodK},${smooth})</tspan> <tspan fill="#ff9800">%D(${periodD})</tspan>`;
            svg.appendChild(label);
            stochContainer.appendChild(svg);
        }

        async function generateChartCanvas() {
            const mainChartContainer = document.getElementById('chart-container');
            const rsiContainer = document.getElementById('rsi-container');
            const macdContainer = document.getElementById('macd-container');
            const volumeContainer = document.getElementById('volume-container');
            const adxContainer = document.getElementById('adx-container');
            const stochContainer = document.getElementById('stoch-container');

            const mainChartSVG = mainChartContainer.querySelector('svg');
            const rsiSVG = rsiContainer.querySelector('svg');
            const macdSVG = macdContainer.querySelector('svg');
            const volumeSVG = volumeContainer.querySelector('svg');
            const adxSVG = adxContainer.querySelector('svg');
            const stochSVG = stochContainer.querySelector('svg');

            if (!mainChartSVG) {
                return null;
            }

            const isLight = document.body.classList.contains('light-mode');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            let totalHeight = mainChartContainer.offsetHeight;
            if (adxSVG && adxContainer.style.display !== 'none') totalHeight += adxContainer.offsetHeight + 10;
            if (rsiSVG && rsiContainer.style.display !== 'none') totalHeight += rsiContainer.offsetHeight + 10;
            if (macdSVG && macdContainer.style.display !== 'none') totalHeight += macdContainer.offsetHeight + 10;
            if (volumeSVG && volumeContainer.style.display !== 'none') totalHeight += volumeContainer.offsetHeight + 10;
            if (stochSVG && stochContainer.style.display !== 'none') totalHeight += stochContainer.offsetHeight + 10;

            canvas.width = mainChartContainer.offsetWidth;
            canvas.height = totalHeight;

            // Preenche o fundo
            ctx.fillStyle = isLight ? '#ffffff' : '#0c1014'; // Cor de fundo do painel
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const drawSVGToCanvas = (svgElement, yOffset) => {
                return new Promise((resolve) => {
                    const svgString = new XMLSerializer().serializeToString(svgElement);
                    const img = new Image();
                    const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);

                    img.onload = function () {
                        ctx.drawImage(img, 0, yOffset);
                        URL.revokeObjectURL(url);
                        resolve();
                    };
                    img.src = url;
                });
            };

            await drawSVGToCanvas(mainChartSVG, 0);
            let currentYOffset = mainChartContainer.offsetHeight + 10;
            if (volumeSVG && volumeContainer.style.display !== 'none') { await drawSVGToCanvas(volumeSVG, currentYOffset); currentYOffset += volumeContainer.offsetHeight + 10; }
            if (adxSVG && adxContainer.style.display !== 'none') { await drawSVGToCanvas(adxSVG, currentYOffset); currentYOffset += adxContainer.offsetHeight + 10; }
            if (rsiSVG && rsiContainer.style.display !== 'none') { await drawSVGToCanvas(rsiSVG, currentYOffset); currentYOffset += rsiContainer.offsetHeight + 10; }
            if (macdSVG && macdContainer.style.display !== 'none') { await drawSVGToCanvas(macdSVG, currentYOffset); }
            if (stochSVG && stochContainer.style.display !== 'none') { await drawSVGToCanvas(stochSVG, currentYOffset); }

            return canvas;
        }

        function generateAnalysisCaption() {
            if (!allCandles || allCandles.length === 0) return 'üìä *An√°lise Gr√°fica - Op√ß√µes Double*\n\nGerado pelo Cortex Virtual';

            const lastCandle = allCandles[allCandles.length - 1];
            const price = lastCandle.close;
            
            // Trend
            const { signal, icon } = getTrendSignal(allCandles);
            
            // Strength
            const lookback = Math.min(allCandles.length, 20);
            const recent = allCandles.slice(-lookback);
            let redPower = 0, blackPower = 0, whitePower = 0;
            recent.forEach(d => {
                if (d.color === 'vermelho') redPower++;
                else if (d.color === 'preto') blackPower++;
                else if (d.color === 'branco') whitePower++;
            });
            const total = redPower + blackPower + whitePower;
            const redPct = total > 0 ? Math.round((redPower / total) * 100) : 0;
            const blackPct = total > 0 ? Math.round((blackPower / total) * 100) : 0;
            
            // Volatility
            let volatilityText = "";
            const atrData = calculateATR(allCandles, 14);
            
            // Check if ATR is dynamic enough (in Tick mode it's constant)
            let metricData = atrData;
            let isFlat = false;
            
            const validATRs = atrData.filter(v => v !== null);
            if (validATRs.length > 0) {
                const recentATRs = validATRs.slice(-20);
                const minA = Math.min(...recentATRs);
                const maxA = Math.max(...recentATRs);
                if (maxA === minA) isFlat = true;
            }

            // If ATR is flat, calculate Standard Deviation of Price
            if (isFlat) {
                const period = 20;
                const stdDevData = [];
                for (let i = 0; i < allCandles.length; i++) {
                    if (i < period - 1) { stdDevData.push(null); continue; }
                    let sum = 0;
                    for (let j = 0; j < period; j++) sum += allCandles[i - j].close;
                    const mean = sum / period;
                    let sumSq = 0;
                    for (let j = 0; j < period; j++) sumSq += Math.pow(allCandles[i - j].close - mean, 2);
                    stdDevData.push(Math.sqrt(sumSq / period));
                }
                metricData = stdDevData;
            }

            const currentMetric = metricData[metricData.length - 1];
            if (currentMetric !== null && currentMetric !== undefined) {
                const volLookbackInput = document.getElementById('volatilityLookback');
                const volLookbackValue = volLookbackInput ? parseInt(volLookbackInput.value) : 50;
                const volLookback = Math.min(allCandles.length, volLookbackValue);
                const recentMetrics = [];
                for(let i = allCandles.length - volLookback; i < allCandles.length; i++) {
                    if(metricData[i] !== null) recentMetrics.push(metricData[i]);
                }
                if (recentMetrics.length > 0) {
                    let minM = Math.min(...recentMetrics);
                    let maxM = Math.max(...recentMetrics);
                    if (maxM === minM) maxM = minM + 0.001;
                    const volatility = Math.max(0, Math.min(100, ((currentMetric - minM) / (maxM - minM)) * 100));
                    volatilityText = `‚ö° *Volatilidade:* ${Math.round(volatility)}%`;
                }
            }

            let indicatorsText = "";
            
            // RSI
            if (document.getElementById('rsiToggle').checked) {
                const rsiPeriod = parseInt(document.getElementById('rsiPeriodInput').value) || 14;
                const rsiValues = calculateRSI(allCandles, rsiPeriod);
                const lastRSI = rsiValues[rsiValues.length - 1];
                if (lastRSI !== null) {
                    let rsiStatus = "Neutro";
                    if (lastRSI >= 70) rsiStatus = "Sobrecompra üî¥";
                    else if (lastRSI <= 30) rsiStatus = "Sobrevenda üü¢";
                    indicatorsText += `\nüìâ *RSI(${rsiPeriod}):* ${lastRSI.toFixed(1)} - ${rsiStatus}`;
                }
            }

            // Bollinger Bands
            if (document.getElementById('bbToggle').checked) {
                const bbPeriod = parseInt(document.getElementById('bbPeriodInput').value) || 20;
                const bbStdDev = parseFloat(document.getElementById('bbStdDevInput').value) || 2;
                const bbData = calculateBollingerBands(allCandles, bbPeriod, bbStdDev);
                const lastUpper = bbData.upper[bbData.upper.length - 1];
                const lastLower = bbData.lower[bbData.lower.length - 1];
                
                if (lastUpper !== null && lastLower !== null) {
                    if (price >= lastUpper) indicatorsText += `\nüåä *Bollinger:* Rompendo Topo üî¥`;
                    else if (price <= lastLower) indicatorsText += `\nüåä *Bollinger:* Rompendo Fundo üü¢`;
                    else indicatorsText += `\nüåä *Bollinger:* Dentro das Bandas`;
                }
            }

            // MACD
            if (document.getElementById('macdToggle').checked) {
                const fast = parseInt(document.getElementById('macdFastInput').value) || 12;
                const slow = parseInt(document.getElementById('macdSlowInput').value) || 26;
                const sig = parseInt(document.getElementById('macdSignalInput').value) || 9;
                const macdData = calculateMACD(allCandles, fast, slow, sig);
                const lastHist = macdData.histogram[macdData.histogram.length - 1];
                if (lastHist !== null) {
                    const macdStatus = lastHist > 0 ? "Alta üü¢" : "Baixa üî¥";
                    indicatorsText += `\nüìä *MACD:* Tend√™ncia de ${macdStatus}`;
                }
            }

            const now = new Date();
            const dateTimeStr = `${now.toLocaleDateString('pt-BR')} ${now.toLocaleTimeString('pt-BR')}`;

            let caption = `üìä *AN√ÅLISE T√âCNICA - OP√á√ïES DOUBLE*\n`;
            caption += `üìÖ *Data:* ${dateTimeStr}\n\n`;
            caption += `üß≠ *Tend√™ncia:* ${icon} ${signal}\n`;
            caption += `üí™ *For√ßa (20):* üî¥ ${redPct}% | ‚ö´ ${blackPct}%\n`;
            if (volatilityText) caption += `${volatilityText}\n`;
            if (indicatorsText) caption += `--------------------------${indicatorsText}\n`;
            caption += `--------------------------\n`;
            caption += `ü§ñ *Gerado pelo Cortex Virtual*`;

            return caption;
        }

        async function takeScreenshot() {
            const canvas = await generateChartCanvas();
            if (!canvas) {
                alert('Gr√°fico principal n√£o encontrado para capturar.');
                return;
            }

            const link = document.createElement('a');
            link.download = `grafico_opcoes_double_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        async function sendScreenshotToTelegram(btn) {
            const token = localStorage.getItem('telegram_bot_token');
            let chatId = localStorage.getItem('telegram_chat_id'); 
            
            if (!token || !chatId) {
                alert('‚ö†Ô∏è Configure o Token e o Chat ID do Telegram primeiro (Menu > Telegram).');
                return;
            }

            const originalText = btn.innerText;
            btn.innerText = '‚è≥ Gerando...';
            btn.disabled = true;

            try {
                const canvas = await generateChartCanvas();
                if (!canvas) throw new Error("Falha ao gerar imagem do gr√°fico.");

                btn.innerText = 'üì§ Enviando...';

                const captionText = generateAnalysisCaption();

                canvas.toBlob(async function(blob) {
                    const formData = new FormData();
                    formData.append('chat_id', chatId);
                    formData.append('photo', blob, 'grafico.png');
                    formData.append('caption', captionText);
                    formData.append('parse_mode', 'Markdown');

                    const response = await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
                        method: 'POST',
                        body: formData
                    });

                    const data = await response.json();
                    if (data.ok) {
                        alert('‚úÖ Gr√°fico enviado para o Telegram com sucesso!');
                    } else {
                        throw new Error(data.description || 'Erro desconhecido no Telegram');
                    }
                    
                    btn.innerText = originalText;
                    btn.disabled = false;
                }, 'image/png');

            } catch (e) {
                console.error(e);
                alert('‚ùå Erro ao enviar: ' + e.message);
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        function playAlertSound() {
            const soundToggle = document.getElementById('soundToggle');
            if (soundToggle && !soundToggle.checked) return;
            
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, ctx.currentTime); // A5
                osc.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.15); // Drop
                
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                
                osc.start();
                osc.stop(ctx.currentTime + 0.3);
            } catch (e) {
                console.error("Audio error:", e);
            }
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            const autoFetchToggle = document.getElementById('autoFetchToggle');
            if (autoFetchToggle) {
                autoFetchToggle.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        fetchData(); // Fetch immediately
                        if (autoFetchInterval) clearInterval(autoFetchInterval);
                        autoFetchInterval = setInterval(fetchData, 15000); // Check for updates every 15s
                    } else {
                        clearInterval(autoFetchInterval);
                    }
                });
                autoFetchToggle.checked = true;
                autoFetchToggle.dispatchEvent(new Event('change'));
            } else {
                fetchData(); 
                setInterval(fetchData, 15000);
            }

            // Panning functionality (Mouse and Touch)
            const chartContainer = document.getElementById('chart-container');

            const startPan = (clientX) => {
                if (isDrawMode) return;
                isPanning = true;
                panStartX = clientX;
                panStartViewIndex = viewStartIndex;
                chartContainer.style.cursor = 'grabbing';
            };

            const movePan = (clientX) => {
                if (!isPanning) return;
                const dx = clientX - panStartX;
                const candlePixelWidth = chartContainer.clientWidth / visibleCandleCount; // Based on visible candle count
                const candleShift = Math.round(dx / candlePixelWidth);
                
                const newIndex = panStartViewIndex - candleShift;
                if (newIndex !== viewStartIndex) {
                    viewStartIndex = newIndex;
                    renderVisibleCharts();
                }
            };

            const stopPan = () => {
                if (!isPanning) return;
                isPanning = false;
                chartContainer.style.cursor = isDrawMode ? 'crosshair' : 'default';
            };

            chartContainer.addEventListener('mousedown', (e) => { e.preventDefault(); startPan(e.clientX); });
            chartContainer.addEventListener('mousemove', (e) => { e.preventDefault(); movePan(e.clientX); });
            chartContainer.addEventListener('mouseup', stopPan);
            chartContainer.addEventListener('mouseleave', stopPan);
            chartContainer.addEventListener('touchstart', (e) => { e.preventDefault(); startPan(e.touches[0].clientX); }, { passive: false });
            chartContainer.addEventListener('touchmove', (e) => { e.preventDefault(); movePan(e.touches[0].clientX); }, { passive: false });
            chartContainer.addEventListener('touchend', stopPan);

            // Start Countdown Timer
            setInterval(() => {
                const timerEl = document.getElementById('candle-countdown');
                if (timerEl) {
                    const timeframe = document.getElementById('timeframeSelect').value;
                    if (timeframe !== 'tick') {
                        const now = new Date();
                        const tfMinutes = parseInt(timeframe);
                        const msPerCandle = tfMinutes * 60 * 1000;
                        const nextCandleTime = Math.ceil(now.getTime() / msPerCandle) * msPerCandle;
                        let diff = Math.ceil((nextCandleTime - now.getTime()) / 1000);
                        if (diff <= 0) diff = tfMinutes * 60;
                        const minutes = Math.floor(diff / 60);
                        const seconds = diff % 60;
                        timerEl.textContent = `‚è≥ ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            }, 1000);
        });
    </script>
</body>
</html>